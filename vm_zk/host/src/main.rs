mod prove;
mod verify;
mod lazy_vector;

use std::{env, fs};
// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use contracts;
use contracts::blockutil::{BlockUtilInterface, NodeBlockUtilInterface};
use contracts::read_contract::read_contract;
use contracts::merkle::merklize;
use risc0_zkvm::Receipt;
use crate::lazy_vector::HostVector;
use crate::prove::prove;
use rustc_hash::FxHashMap;
use crate::verify::verify;

fn main() {
    let args: Vec<String> = env::args().collect();
    if args[1] == "V" {
        // Verify
        let receipt_file = fs::read(args[2].clone()).unwrap();
        let receipt: Receipt = rmp_serde::from_slice(&*receipt_file).unwrap();
        assert!(verify(receipt));
        println!("Verification success!");
        return
    }

    let contracts_file = read_contract();
    let contract_contents_str = contracts_file.split("%").collect::<Vec<&str>>(); // % marks separation between contracts
    let mut contract_contents = Vec::new();
    for contract in contract_contents_str {
        contract_contents.push(std::string::String::from(contract));
    }
    let contract_hashes_str  = args[2].split("%").collect::<Vec<&str>>();
    let mut contract_hashes = Vec::new();
    for hash in contract_hashes_str {
        contract_hashes.push(std::string::String::from(hash));
    }
    let gas_limit_f64: f64 = args[3].parse().unwrap();
    let gas_limit = gas_limit_f64 as i64;
    let sender: Vec<u8> = args[4].clone().into();
  
    // Initialize merkle tree
    let mut data: FxHashMap<String, Vec<u8>> = FxHashMap::default();
    let merkle_file = fs::read_to_string(args[5].clone()).unwrap();
    let merkle_pairs: Vec<&str> = merkle_file.split("*").collect();
    for pair in merkle_pairs {
        let segments: Vec<&str> = pair.split(">").collect();
        let key = String::from(segments[0]);
        let value = hex::decode(segments[1].trim()).unwrap();
        data.insert(key, value);
    }
    let tree = merklize(data);
    let lazy_len = tree.len();
    let host_vector = HostVector::new(tree);
    
    // Create node blockutil for data fetching
    let node_blockutil = NodeBlockUtilInterface::new();
    
    // Fetch data from node
    let blockchain_len = node_blockutil.get_blockchain_len();
    
    let run_details = contracts::vm::VmRunDetails {
        contract_contents,
        contract_hash: contract_hashes,
        gas_limit,
        sender,
        lazy_len,
        blockchain_len
    };

    let receipt = prove(run_details, host_vector);
    let receipt_serialized = rmp_serde::to_vec(&receipt).unwrap();

    let out_file = args[6].clone();
    fs::write(out_file, receipt_serialized).unwrap();
}
