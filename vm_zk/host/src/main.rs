mod prove;
mod lazy_vector;

use std::env;
// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use methods::POLYCASH_ZK_GUEST_ID;
use contracts;
use contracts::msgpack::decode_pending_state;
use std::process::ExitCode;
use contracts::read_contract::read_contract;
use contracts::vm::ZkInfo;
use contracts::merkle::merklize_state;
use crate::lazy_vector::HostVector;
use crate::prove::prove;
use rustc_hash::FxHashMap;

fn main() -> ExitCode {
    // Initialize tracing. In order to view logs, run `RUST_LOG=info cargo run`
    tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env())
        .init();

    let contract_contents = read_contract();
    let args: Vec<String> = env::args().collect();
    let contract_hash  = &args[2];
    let gas_limit_f64: f64 = args[3].parse().unwrap();
    let gas_limit = gas_limit_f64 as i64;
    let sender: Vec<u8> = args[4].clone().into();
    let pending_state = decode_pending_state();
   
    let mut state: FxHashMap<String, Vec<u8>> = FxHashMap::default();
    state.insert(String::from("123"), "abc".as_bytes().to_vec());
    let tree = merklize_state(state);
    let host_vector = HostVector::new(tree);
    
    let run_details = contracts::vm::VmRunDetails {
        contract_contents: std::string::String::from(contract_contents),
        contract_hash: contract_hash.to_owned(),
        gas_limit,
        sender,
        pending_state
    };

    let receipt = prove(run_details, host_vector);
    let output: ZkInfo = receipt.journal.decode().unwrap();
    
    // The receipt was verified at the end of proving, but the below code is an
    // example of how someone else could verify this receipt.
    receipt
        .verify(POLYCASH_ZK_GUEST_ID)
        .unwrap();

    ExitCode::from(output.exit_code as u8)
}
