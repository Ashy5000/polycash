InitBfr 0x00001000 0x00000000
SetCnst 0x00001000 0x010000 0x00000000
InitBfr 0x00001001 0x00000000
ReadFromState 0x00001000 0x00001001 0x00000000
InitBfr 0x00001002 0x00000000
InitBfr 0x00001003 0x00000000
SetCnst 0x00001003 0x7a145cbd 0x00000000
Eq 0x00001003 0x00001001 0x00001002 0x00000000
JmpCond 0x00001002 86 0x00000000
Jmp 85
InitBfr 0x00000010 0x00000000
BfrLen 0x00000002 0x00000010 0x00000000
CpyBfr 0x00000010 0x00000001 0x00000000
Ret
InitBfr 0x00000010 0x00000000 ; Create bfr to hold exp res
InitBfr 0x00000014 0x00000000 ; Create bfr to hold 10
InitBfr 0x00000015 0x00000000 ; Create bfr
SetCnst 0x00000015 0x0000000000000000 0x00000000
SetCnst 0x00000014 0x000000000000000A 0x00000000 ; Set bfr cnst to hold 10
Exp 0x00000014 0x00000003 0x00000010 0x00000000 ; 10^digit
Mod 0x00000002 0x00000010 0x00000002 0x00000000 ; Chop off higher
InitBfr 0x00000012 0x00000000
SetCnst 0x00000012 0x0000000000000001 0x00000000 ; Set bfr cnst to hold 1
InitBfr 0x00000013 0x00000000 ; Create bfr to hold digit-1
Sub 0x00000003 0x00000012 0x00000013 0x00000000
Exp 0x00000014 0x00000013 0x00000010 0x00000000 ; 10^(digit-1)
InitBfr 0x00000011 0x00000000 ; Create bfr to hold mod res
Mod 0x00000002 0x00000010 0x00000011 0x00000000 ; Get value to be subtracted
Sub 0x00000002 0x00000011 0x00000002 0x00000000 ; Chop off lower
CpyBfr 0x00000002 0x00000001 0x00000000 ; Move into ret val
Less 0x00000001 0x00000014 0x00000015 0x00000000 ; Check if less than ten
JmpCond 0x00000015 35 0x00000000
Div 0x00000001 0x00000014 0x00000001 0x00000000 ; Div ret value by 10Z
Jmp 31
Ret
CpyBfr 0x00000002 0x00000001 0x00000000
InitBfr 0x00000010 0x00000000
SetCnst 0x00000010 0x0000000000000030 0x00000000
Add 0x00000001 0x00000010 0x00000001 0x00000000
Ret
InitBfr 0x00000010 0x00000000 ; Create bfr for input copy
CpyBfr 0x00000002 0x00000010 0x00000000; Copy input
InitBfr 0x00000011 0x00000000 ; Create bfr to hold 0
SetCnst 0x00000011 0x0000000000000000 0x00000000 ; Store 0 in bfr
InitBfr 0x00000012 0x00000000 ; Create bfr to hold 10
SetCnst 0x00000012 0x000000000000000A 0x00000000 ;  Store 10 in bfr
InitBfr 0x00000013 0x00000000 ; Create buffer to hold cmp res
InitBfr 0x00000014 0x00000000 ; Create bfr to hold len
SetCnst 0x00000014 0x0000000000000000 0x00000000 ; Store 0 in bfr
InitBfr 0x00000015 0x00000000 0x00000000 ; Create bfr to hold 1
SetCnst 0x00000015 0x0000000000000001 0x00000000 ; Store 1 in bfr
Eq 0x00000010 0x00000011 0x00000013 0x00000000 ; inputCopy == 0
JmpCond 0x00000013 57 0x00000000
Div 0x00000010 0x00000012 0x00000010 0x00000000 ; inputCopy /= 10
Add 0x00000014 0x00000015 0x00000014 0x00000000 ; increment length
Jmp 52
CpyBfr 0x00000014 0x00000001 0x00000000 ; Copy into result
Ret ; Return
InitBfr 0x00000016 0x00000000
CpyBfr 0x00000002 0x00000016 0x00000000
InitBfr 0x00000010 0x00000000 ; Create bfr to hold int len
Call 41
CpyBfr 0x00000001 0x00000010 0x00000000 ; Move int len into bfr
SetCnst 0x00000001 0x00000000 0x00000000 ; Clear ret val
InitBfr 0x00000011 0x00000000 ; Create bfr to hold 1
SetCnst 0x00000011 0x0000000000000001 0x00000000 ; Store 1 in bfr
InitBfr 0x00000012 0x00000000 ; Create bfr to hold 0
SetCnst 0x00000012 0x0000000000000000 0x00000000 ; Store 0 in bfr
InitBfr 0x00000013 0x00000000 ; Create bfr to hold cmp res
InitBfr 0x00000014 0x00000000 ; Create bfr to hold # of digits converted
InitBfr 0x00000015 0x00000000 ; Create bfr to hold result
CpyBfr 0x00000010 0x00000014 0x00000000
Eq 0x00000014 0x00000012 0x00000013 0x00000000 ; done == 0
JmpCond 0x00000013 83 0x00000000
CpyBfr 0x00000016 0x00000002 0x00000000
CpyBfr 0x00000014 0x00000003 0x00000000 ; Copy done into digit pos
Call 15
CpyBfr 0x00000001 0x00000002 0x00000000 ; Copy digit as int into param
Call 36
App 0x00000015 0x00000001 0x00000000 ; Append single-char string onto res
Sub 0x00000014 0x00000011 0x00000014 0x00000000 ; Increment # of digits converted
Jmp 73
CpyBfr 0x00000015 0x00000001 0x00000000 ; Copy res into ret
Ret
;^^^^BEGIN_SOURCE^^^^
; FN main RET uint64 
; PRELABEL 0
InitBfr 0x00001000 0x00000000
SetCnst 0x00001000 0x48656c6c6f2c20776f726c6421 0x00000000
InitBfr 0x00001001 0x00000000
SetCnst 0x00001001 0x0000000000000000 0x00000000
UpdateState 0x00001001 0x00001000 0x00000000
InitBfr 0x00001002 0x00000000
SetCnst 0x00001002 0x0000000000000000 0x00000000
InitBfr 0x00001003 0x00000000
GetFromState 0x00001002 0x00001003 0x00000000
InitBfr 0x00000002 0x00000000
CpyBfr 0x00001003 0x00000002 0x00000000
Call 11
InitBfr 0x00001003 0x00000000
SetCnst 0x00001003 0x000000000000000d 0x00000000
InitBfr 0x00001004 0x00000000
Eq 0x00000001 0x00001003 0x00001004 0x00000000
Not 0x00001004 0x00001004 0x00000000
JmpCond 0x00001004 110 0x00000000
InitBfr 0x00001005 0x00000000
SetCnst 0x00001005 0x537472696e672069732031332063686172616374657273206c6f6e672e 0x00000000
InitBfr 0x00001006 0x00000000
SetCnst 0x00001006 0x537472696e672069732031332063686172616374657273206c6f6e672e 0x00000000
PrintStr 0x00001006 0x00000000
; LABEL 0
CpyBfr 0x00000001 0x00000002 0x00000000
Call 59
PrintStr 0x00000001 0x00000000
InitBfr 0x00001009 0x00000000
SetCnst 0x00001009 0x0000000000000005 0x00000000
InitBfr 0x0000100b 0x00000000
SetCnst 0x0000100b 0x0000000000000000 0x00000000
Free 0x00001009 0x00000000
InitBfr 0x0000100c 0x00000000
SetCnst 0x0000100c 0x0000000000000000 0x00000000
InitBfr 0x0000100d 0x00000000
SetCnst 0x0000100d 0x000000000000000a 0x00000000
InitBfr 0x0000100e 0x00000000
SetCnst 0x0000100e 0x0000000000000001 0x00000000
InitBfr 0x0000100f 0x00000000
; LABEL 1
Add 0x0000100b 0x0000100e 0x0000100b 0x00000000
InitBfr 0x00001010 0x00000000
SetCnst 0x00001010 0x4c6f6f7021 0x00000000
InitBfr 0x00001011 0x00000000
SetCnst 0x00001011 0x4c6f6f7021 0x00000000
PrintStr 0x00001011 0x00000000
Eq 0x0000100b 0x0000100d 0x0000100f 0x00000000
Not 0x0000100f 0x0000100f 0x00000000
JmpCond 0x0000100f 126 0x00000000

