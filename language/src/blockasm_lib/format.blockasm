; @get_digit ->uint64 /uint64@0x00000002 /uint64@0x00000003
InitBfr 0x00000010 0x00000000 ; Create bfr to hold exp res
InitBfr 0x00000014 0x00000000 ; Create bfr to hold 10
InitBfr 0x00000015 0x00000000 ; Create bfr
SetCnst 0x00000015 0x0000000000000000 0x00000000
SetCnst 0x00000014 0x000000000000000A 0x00000000 ; Set bfr cnst to hold 10
Exp 0x00000014 0x00000003 0x00000010 0x00000000 ; 10^digit
Mod 0x00000002 0x00000010 0x00000002 0x00000000 ; Chop off higher
InitBfr 0x00000012 0x00000000
SetCnst 0x00000012 0x0000000000000001 0x00000000 ; Set bfr cnst to hold 1
InitBfr 0x00000013 0x00000000 ; Create bfr to hold digit-1
Sub 0x00000003 0x00000012 0x00000013 0x00000000
Exp 0x00000014 0x00000013 0x00000010 0x00000000 ; 10^(digit-1)
InitBfr 0x00000011 0x00000000 ; Create bfr to hold mod res
Mod 0x00000002 0x00000010 0x00000011 0x00000000 ; Get value to be subtracted
Sub 0x00000002 0x00000011 0x00000002 0x00000000 ; Chop off lower
CpyBfr 0x00000002 0x00000001 0x00000000 ; Move into ret val
Less 0x00000001 0x00000014 0x00000015 0x00000000 ; Check if less than ten
JmpCond 0x00000015 21 0x00000000
Div 0x00000001 0x00000014 0x00000001 0x00000000 ; Div ret value by 10Z
Jmp 17
Ret

; @digit_to_string ->string /uint64@0x00000002
CpyBfr 0x00000002 0x00000001 0x00000000
InitBfr 0x00000010 0x00000000
SetCnst 0x00000010 0x0000000000000030 0x00000000
Add 0x00000001 0x00000010 0x00000001 0x00000000
Ret

; @int_len ->uint64 /uint64@0x00000002
InitBfr 0x00000010 0x00000000 ; Create bfr for input copy
CpyBfr 0x00000002 0x00000010 0x00000000; Copy input
InitBfr 0x00000011 0x00000000 ; Create bfr to hold 0
SetCnst 0x00000011 0x0000000000000000 0x00000000 ; Store 0 in bfr
InitBfr 0x00000012 0x00000000 ; Create bfr to hold 10
SetCnst 0x00000012 0x000000000000000A 0x00000000 ;  Store 10 in bfr
InitBfr 0x00000013 0x00000000 ; Create buffer to hold cmp res
InitBfr 0x00000014 0x00000000 ; Create bfr to hold len
SetCnst 0x00000014 0x0000000000000000 0x00000000 ; Store 0 in bfr
InitBfr 0x00000015 0x00000000 0x00000000 ; Create bfr to hold 1
SetCnst 0x00000015 0x0000000000000001 0x00000000 ; Store 1 in bfr
Eq 0x00000010 0x00000011 0x00000013 0x00000000 ; inputCopy == 0
JmpCond 0x00000013 17 0x00000000
Div 0x00000010 0x00000012 0x00000010 0x00000000 ; inputCopy /= 10
Add 0x00000014 0x00000015 0x00000014 0x00000000 ; increment length
Jmp 12
CpyBfr 0x00000014 0x00000001 0x00000000 ; Copy into result
Ret ; Return

; @int_to_string ->string /uint64@0x00000002
InitBfr 0x00000016 0x00000000
CpyBfr 0x00000002 0x00000016 0x00000000
InitBfr 0x00000010 0x00000000 ; Create bfr to hold int len
%int_len
CpyBfr 0x00000001 0x00000010 0x00000000 ; Move int len into bfr
SetCnst 0x00000001 0x00000000 0x00000000 ; Clear ret val
InitBfr 0x00000011 0x00000000 ; Create bfr to hold 1
SetCnst 0x00000011 0x0000000000000001 0x00000000 ; Store 1 in bfr
InitBfr 0x00000012 0x00000000 ; Create bfr to hold 0
SetCnst 0x00000012 0x0000000000000000 0x00000000 ; Store 0 in bfr
InitBfr 0x00000013 0x00000000 ; Create bfr to hold cmp res
InitBfr 0x00000014 0x00000000 ; Create bfr to hold # of digits converted
InitBfr 0x00000015 0x00000000 ; Create bfr to hold result
CpyBfr 0x00000010 0x00000014 0x00000000
Eq 0x00000014 0x00000012 0x00000013 0x00000000 ; done == 0
JmpCond 0x00000013 25 0x00000000
CpyBfr 0x00000016 0x00000002 0x00000000
CpyBfr 0x00000014 0x00000003 0x00000000 ; Copy done into digit pos
%get_digit
CpyBfr 0x00000001 0x00000002 0x00000000 ; Copy digit as int into param
%digit_to_string
App 0x00000015 0x00000001 0x00000000 ; Append single-char string onto res
Sub 0x00000014 0x00000011 0x00000014 0x00000000 ; Increment # of digits converted
Jmp 15
CpyBfr 0x00000015 0x00000001 0x00000000 ; Copy res into ret
Ret