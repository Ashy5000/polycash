; @get_digit ->uint64 /uint64@0x00000002 /uint64@0x00000003
InitBfr 0x00000010 0x00000000 ; Create bfr to hold exp res
InitBfr 0x00000014 0x00000000 ; Create bfr to hold 10
InitBfr 0x00000015 0x00000000 ; Create bfr
SetCnst 0x00000015 0x0000000000000000 0x00000000
SetCnst 0x00000014 0x000000000000000A 0x00000000 ; Set bfr cnst to hold 10
Exp 0x00000014 0x00000003 0x00000010 0x00000000 ; 10^digit
Mod 0x00000002 0x00000010 0x00000002 0x00000000 ; Chop off higher
InitBfr 0x00000012 0x00000000
SetCnst 0x00000012 0x0000000000000001 0x00000000 ; Set bfr cnst to hold 1
InitBfr 0x00000013 0x00000000 ; Create bfr to hold digit-1
Sub 0x00000003 0x00000012 0x00000013 0x00000000
Exp 0x00000014 0x00000013 0x00000010 0x00000000 ; 10^(digit-1)
InitBfr 0x00000011 0x00000000 ; Create bfr to hold mod res
Mod 0x00000002 0x00000010 0x00000011 0x00000000 ; Get value to be subtracted
Sub 0x00000002 0x00000011 0x00000002 0x00000000 ; Chop off lower
CpyBfr 0x00000002 0x00000001 0x00000000 ; Move into ret val
Less 0x00000001 0x00000014 0x00000015 0x00000000 ; Check if less than ten
JmpCond 0x00000015 21 0x00000000
Div 0x00000001 0x00000014 0x00000001 0x00000000 ; Div ret value by 10Z
Jmp 17
Ret