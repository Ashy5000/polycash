--------------------------------------------------------------------------------
I1 cache:         32768 B, 64 B, 8-way associative
D1 cache:         49152 B, 64 B, 12-way associative
LL cache:         18874368 B, 64 B, 9-way associative
Command:          ./contracts/target/debug/contracts language/out.blockasm 0
Data file:        cachegrind.out.270685
Events recorded:  Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Events shown:     Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Event sort order: Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Thresholds:       0.1 100 100 100 100 100 100 100 100
Include dirs:     
User annotated:   
Auto-annotation:  on

--------------------------------------------------------------------------------
Ir                 I1mr             ILmr           Dr                 D1mr           DLmr           Dw                 D1mw           DLmw           
--------------------------------------------------------------------------------
9,486,216 (100.0%) 144,149 (100.0%) 7,102 (100.0%) 2,432,539 (100.0%) 5,767 (100.0%) 3,589 (100.0%) 3,153,619 (100.0%) 5,318 (100.0%) 4,190 (100.0%)  PROGRAM TOTALS

--------------------------------------------------------------------------------
Ir               I1mr           ILmr         Dr              D1mr           DLmr           Dw               D1mw           DLmw          file:function
--------------------------------------------------------------------------------
313,353 ( 3.30%)   109 ( 0.08%)   3 ( 0.04%) 50,814 ( 2.09%)     0              0          110,097 ( 3.49%)     0            0           /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/core/src/ptr/mod.rs:core::ptr::align_offset
249,170 ( 2.63%)   728 ( 0.51%)  13 ( 0.18%) 85,206 ( 3.50%)     4 ( 0.07%)     0           40,578 ( 1.29%)     0            0           /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/core/src/str/pattern.rs:core::str::pattern::TwoWaySearcher::next
167,720 ( 1.77%)   325 ( 0.23%)   2 ( 0.03%)      0              0              0            8,386 ( 0.27%)     0            0           /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/core/src/num/uint_macros.rs:core::ptr::const_ptr::<impl *const T>::align_offset
162,061 ( 1.71%) 4,360 ( 3.02%)  31 ( 0.44%) 36,121 ( 1.48%)     0              0           39,805 ( 1.26%)    28 ( 0.53%)   0           /home/ashy5000/dev/cryptocurrency/contracts/target/debug/build/tikv-jemalloc-sys-7365f40ecb99e085/out/build/src/jemalloc.c:_rjem_sdallocx
155,448 ( 1.64%)    73 ( 0.05%)   2 ( 0.03%) 43,180 ( 1.78%)     0              0           94,996 ( 3.01%)     1 ( 0.02%)   0           /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/core/src/slice/index.rs:<core::ops::range::Range<usize> as core::slice::index::SliceIndex<[T]>>::get_unchecked
147,670 ( 1.56%)     0            0               0              0              0           29,534 ( 0.94%)     0            0           /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/core/src/num/uint_macros.rs:core::num::<impl usize>::unchecked_sub::precondition_check
137,448 ( 1.45%)   235 ( 0.16%)   2 ( 0.03%)  7,636 ( 0.31%)     0              0          114,540 ( 3.63%)     0            0           /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/core/src/array/mod.rs:core::array::<impl core::ops::index::Index<I> for [T; N]>::index
129,812 ( 1.37%)   167 ( 0.12%)   1 ( 0.01%) 15,272 ( 0.63%)     0              0           38,180 ( 1.21%)     0            0           /home/ashy5000/.cargo/registry/src/index.crates.io-6f17d22bba15001f/smartstring-1.0.1/src/inline.rs:<smartstring::inline::InlineString as core::ops::deref::Deref>::deref
117,022 ( 1.23%) 3,126 ( 2.17%)  23 ( 0.32%) 26,023 ( 1.07%)     0              0           27,043 ( 0.86%)    19 ( 0.36%)   0           /home/ashy5000/dev/cryptocurrency/contracts/target/debug/build/tikv-jemalloc-sys-7365f40ecb99e085/out/build/include/jemalloc/internal/jemalloc_internal_inlines_c.h:_rjem_malloc
116,489 ( 1.23%)    86 ( 0.06%)   2 ( 0.03%) 36,786 ( 1.51%)     0              0           67,441 ( 2.14%)     1 ( 0.02%)   0           /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/core/src/slice/index.rs:<core::ops::range::Range<usize> as core::slice::index::SliceIndex<[T]>>::get_unchecked_mut
110,784 ( 1.17%)   210 ( 0.15%)   4 ( 0.06%) 35,629 ( 1.46%)    62 ( 1.08%)     0           28,740 ( 0.91%)     0            0           /home/ashy5000/dev/cryptocurrency/contracts/target/debug/build/tikv-jemalloc-sys-7365f40ecb99e085/out/build/include/jemalloc/internal/tsd.h:core::str::pattern::TwoWaySearcher::next
100,632 ( 1.06%)   199 ( 0.14%)   1 ( 0.01%) 41,930 ( 1.72%)     0              0           33,544 ( 1.06%)     1 ( 0.02%)   1 ( 0.02%)  /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/core/src/ptr/const_ptr.rs:core::ptr::const_ptr::<impl *const T>::align_offset
 99,749 ( 1.05%)    28 ( 0.02%)   1 ( 0.01%) 30,692 ( 1.26%)     0              0           30,692 ( 0.97%)     0            0           /home/ashy5000/.cargo/registry/src/index.crates.io-6f17d22bba15001f/smartstring-1.0.1/src/inline.rs:smartstring::inline::InlineString::len
 93,296 ( 0.98%)    26 ( 0.02%)   1 ( 0.01%) 21,952 ( 0.90%)     0              0           24,696 ( 0.78%)     0            0           /home/ashy5000/.cargo/registry/src/index.crates.io-6f17d22bba15001f/smartstring-1.0.1/src/marker_byte.rs:<smartstring::inline::InlineString as smartstring::ops::GenericString>::set_size
 92,982 ( 0.98%)   724 ( 0.50%)   3 ( 0.04%) 27,593 ( 1.13%)     0              0           44,675 ( 1.42%)     0            0           /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/core/src/slice/iter/macros.rs:<core::slice::iter::Iter<T> as core::iter::traits::iterator::Iterator>::next
 88,602 ( 0.93%)   129 ( 0.09%)   1 ( 0.01%) 14,767 ( 0.61%)     0              0           29,534 ( 0.94%)     0            0           /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/core/src/ub_checks.rs:core::num::<impl usize>::unchecked_sub::precondition_check
 86,360 ( 0.91%)    81 ( 0.06%)   2 ( 0.03%) 25,908 ( 1.07%)     0              0           43,180 ( 1.37%)     2 ( 0.04%)   0           /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/core/src/ub_checks.rs:<core::ops::range::Range<usize> as core::slice::index::SliceIndex<[T]>>::get_unchecked::precondition_check
 83,860 ( 0.88%)    32 ( 0.02%)   1 ( 0.01%) 25,158 ( 1.03%)     1 ( 0.02%)     0           25,158 ( 0.80%)     0            0           /home/ashy5000/.cargo/registry/src/index.crates.io-6f17d22bba15001f/smartstring-1.0.1/src/boxed.rs:smartstring::boxed::check_alignment
 82,850 ( 0.87%)   269 ( 0.19%)   2 ( 0.03%) 23,198 ( 0.95%)     0              0           33,140 ( 1.05%)     0            0           /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/core/src/slice/index.rs:<core::ops::range::Range<usize> as core::slice::index::SliceIndex<[T]>>::index_mut
 82,682 ( 0.87%)    62 ( 0.04%)   1 ( 0.01%) 32,980 ( 1.36%)     0              0           16,548 ( 0.52%)     0            0           /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/core/src/slice/index.rs:<usize as core::slice::index::SliceIndex<[T]>>::get
 75,474 ( 0.80%)    32 ( 0.02%)   0          16,772 ( 0.69%)   220 ( 3.81%)     0           25,158 ( 0.80%)     0            0           /home/ashy5000/.cargo/registry/src/index.crates.io-6f17d22bba15001f/smartstring-1.0.1/src/boxed.rs:smartstring::boxed::BoxedString::check_alignment
 75,474 ( 0.80%)    26 ( 0.02%)   1 ( 0.01%) 16,772 ( 0.69%)     1 ( 0.02%)     0           33,544 ( 1.06%)     0            0           /home/ashy5000/.cargo/registry/src/index.crates.io-6f17d22bba15001f/smartstring-1.0.1/src/lib.rs:smartstring::SmartString<Mode>::discriminant
 70,425 ( 0.74%)   529 ( 0.37%)   6 ( 0.08%) 28,170 ( 1.16%)     1 ( 0.02%)     1 ( 0.03%)  11,268 ( 0.36%)     0            0           /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/core/src/char/methods.rs:core::char::methods::encode_utf8_raw
 68,724 ( 0.72%)   110 ( 0.08%)   1 ( 0.01%) 15,272 ( 0.63%)     0              0            7,636 ( 0.24%)     0            0           /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/core/src/slice/index.rs:core::array::<impl core::ops::index::Index<I> for [T; N]>::index
 66,520 ( 0.70%) 3,728 ( 2.59%)  41 ( 0.58%) 12,486 ( 0.51%)     1 ( 0.02%)     0           23,008 ( 0.73%)     1 ( 0.02%)   0           /home/ashy5000/dev/cryptocurrency/contracts/src/syntax_tree.rs:contracts::syntax_tree::SyntaxTree::create
 64,560 ( 0.68%)   883 ( 0.61%)   6 ( 0.08%)      0              0              0            3,228 ( 0.10%)     0            0           /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/core/src/num/uint_macros.rs:core::intrinsics::copy_nonoverlapping::precondition_check
 61,310 ( 0.65%)    56 ( 0.04%)   1 ( 0.01%) 18,393 ( 0.76%)     0              0           30,655 ( 0.97%)     0            0           /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/core/src/ub_checks.rs:<core::ops::range::Range<usize> as core::slice::index::SliceIndex<[T]>>::get_unchecked_mut::precondition_check
 60,587 ( 0.64%)    47 ( 0.03%)  18 ( 0.25%) 20,378 ( 0.84%)   457 ( 7.92%)   246 ( 6.85%)   8,557 ( 0.27%)    12 ( 0.23%)   3 ( 0.07%)  ./elf/./elf/dl-lookup.c:do_lookup_x
 60,452 ( 0.64%)     0            0          43,180 ( 1.78%)     0              0           17,272 ( 0.55%)     0            0           /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/core/src/ub_checks.rs:<core::ops::range::Range<usize> as core::slice::index::SliceIndex<[T]>>::get_unchecked
 60,346 ( 0.64%)   272 ( 0.19%)   6 ( 0.08%)  9,284 ( 0.38%)     0              0           13,926 ( 0.44%)     0            0           /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/core/src/ub_checks.rs:core::slice::raw::from_raw_parts::precondition_check
 57,802 ( 0.61%)    62 ( 0.04%)   1 ( 0.01%)      0              0              0           41,370 ( 1.31%)     0            0           /home/ashy5000/dev/cryptocurrency/contracts/target/debug/build/tikv-jemalloc-sys-7365f40ecb99e085/out/build/include/jemalloc/internal/tcache_inlines.h:<usize as core::slice::index::SliceIndex<[T]>>::get
 56,121 ( 0.59%)   111 ( 0.08%)   2 ( 0.03%) 22,317 ( 0.92%)     4 ( 0.07%)     0           22,536 ( 0.71%)     0            0           /home/ashy5000/.cargo/registry/src/index.crates.io-6f17d22bba15001f/smartstring-1.0.1/src/ops.rs:smartstring::ops::Push::op
 53,996 ( 0.57%)    42 ( 0.03%)  42 ( 0.59%) 15,218 ( 0.63%)    13 ( 0.23%)     7 ( 0.20%)   7,120 ( 0.23%)     0            0           ./stdio-common/./stdio-common/vfscanf-internal.c:__vfscanf_internal
 52,315 ( 0.55%) 1,443 ( 1.00%)  11 ( 0.15%) 10,763 ( 0.44%)     0              0           19,843 ( 0.63%)     0            0           /home/ashy5000/.cargo/registry/src/index.crates.io-6f17d22bba15001f/smartstring-1.0.1/src/lib.rs:<smartstring::SmartString<Mode> as core::iter::traits::collect::FromIterator<char>>::from_iter
 50,742 ( 0.53%)   277 ( 0.19%)   2 ( 0.03%) 16,918 ( 0.70%)     1 ( 0.02%)     0           22,552 ( 0.72%)     0            0           /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/core/src/str/validations.rs:core::str::validations::next_code_point
 50,563 ( 0.53%)   270 ( 0.19%)   2 ( 0.03%) 15,144 ( 0.62%)     0              0           25,240 ( 0.80%)     0            0           /home/ashy5000/.cargo/registry/src/index.crates.io-6f17d22bba15001f/smartstring-1.0.1/src/lib.rs:smartstring::SmartString<Mode>::cast_mut
 49,290 ( 0.52%)    29 ( 0.02%)  11 ( 0.15%) 10,546 ( 0.43%)   143 ( 2.48%)   121 ( 3.37%)   5,593 ( 0.18%)    13 ( 0.24%)   1 ( 0.02%)  ./elf/./elf/dl-lookup.c:_dl_lookup_symbol_x
 48,577 ( 0.51%)    23 ( 0.02%)  23 ( 0.32%) 12,125 ( 0.50%) 1,118 (19.39%) 1,078 (30.04%)   5,583 ( 0.18%) 1,007 (18.94%) 997 (23.79%)  ./elf/../sysdeps/x86_64/dl-machine.h:_dl_relocate_object
 46,420 ( 0.49%)   317 ( 0.22%)   4 ( 0.06%)      0              0              0            2,321 ( 0.07%)     0            0           /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/core/src/num/uint_macros.rs:core::slice::raw::from_raw_parts::precondition_check
 45,515 ( 0.48%)   186 ( 0.13%)   1 ( 0.01%) 10,096 ( 0.42%)     0              0           10,179 ( 0.32%)     0            0           /home/ashy5000/dev/cryptocurrency/contracts/target/debug/build/tikv-jemalloc-sys-7365f40ecb99e085/out/build/include/jemalloc/internal/sz.h:smartstring::SmartString<Mode>::cast_mut
 44,216 ( 0.47%) 4,093 ( 2.84%) 348 ( 4.90%) 10,730 ( 0.44%)     7 ( 0.12%)     3 ( 0.08%)  11,148 ( 0.35%)    77 ( 1.45%)  15 ( 0.36%)  /home/ashy5000/dev/cryptocurrency/contracts/src/vm.rs:contracts::vm::run_vm
 44,057 ( 0.46%)    69 ( 0.05%)   1 ( 0.01%)  3,389 ( 0.14%)     0              0           20,334 ( 0.64%)     0            0           /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/core/src/str/traits.rs:core::str::traits::<impl core::cmp::PartialEq for str>::eq
 42,917 ( 0.45%)     0            0          30,655 ( 1.26%)     0              0           12,262 ( 0.39%)     0            0           /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/core/src/ub_checks.rs:<core::ops::range::Range<usize> as core::slice::index::SliceIndex<[T]>>::get_unchecked_mut
 41,080 ( 0.43%)    74 ( 0.05%)   1 ( 0.01%)  8,216 ( 0.34%)     0              0           16,432 ( 0.52%)     0            0           /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/core/src/ub_checks.rs:<usize as core::slice::index::SliceIndex<[T]>>::get_unchecked::precondition_check
 40,697 ( 0.43%)   128 ( 0.09%)   1 ( 0.01%) 24,648 ( 1.01%)     0              0                0              0            0           /home/ashy5000/dev/cryptocurrency/contracts/src/main.rs:core::str::pattern::TwoWaySearcher::next
 40,046 ( 0.42%)     1 ( 0.00%)   1 ( 0.01%) 10,005 ( 0.41%)     0              0           13,353 ( 0.42%)     0            0           /home/ashy5000/dev/cryptocurrency/contracts/target/debug/build/tikv-jemalloc-sys-7365f40ecb99e085/out/build/src/jemalloc.c:smartstring::SmartString<Mode>::cast
 38,974 ( 0.41%) 1,204 ( 0.84%)  13 ( 0.18%) 12,001 ( 0.49%)     2 ( 0.03%)     1 ( 0.03%)  13,480 ( 0.43%)     0            0           /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/alloc/src/raw_vec.rs:alloc::raw_vec::RawVec<T,A>::try_allocate_in
 38,960 ( 0.41%)    81 ( 0.06%)   0           7,792 ( 0.32%)     0              0           15,584 ( 0.49%)     0            0           /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/core/src/str/converts.rs:core::str::converts::from_utf8_unchecked
 38,225 ( 0.40%)     5 ( 0.00%)   5 ( 0.07%)  6,917 ( 0.28%)    80 ( 1.39%)    80 ( 2.23%)       6 ( 0.00%)     1 ( 0.02%)   1 ( 0.02%)  ./elf/./elf/dl-tunables.c:__GI___tunables_init
 36,786 ( 0.39%)     0            0           6,131 ( 0.25%)     0              0           24,524 ( 0.78%)     0            0           /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/core/src/ptr/mut_ptr.rs:<core::ops::range::Range<usize> as core::slice::index::SliceIndex<[T]>>::get_unchecked_mut
 36,287 ( 0.38%)   178 ( 0.12%)   1 ( 0.01%)  4,188 ( 0.17%)     0              0           29,307 ( 0.93%)     0            0           /home/ashy5000/dev/cryptocurrency/contracts/target/debug/build/tikv-jemalloc-sys-7365f40ecb99e085/out/build/src/jemalloc.c:<[A] as core::slice::cmp::SlicePartialEq<B>>::equal
 36,286 ( 0.38%)   169 ( 0.12%)   3 ( 0.04%)  5,707 ( 0.23%)     0              0           22,262 ( 0.71%)     0            0           /home/ashy5000/.cargo/registry/src/index.crates.io-6f17d22bba15001f/smartstring-1.0.1/src/ops.rs:smartstring::SmartString<Mode>::push
 34,689 ( 0.37%)   147 ( 0.10%)   2 ( 0.03%) 10,966 ( 0.45%)     1 ( 0.02%)     0            1,993 ( 0.06%)     0            0           /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/core/src/slice/cmp.rs:<[A] as core::slice::cmp::SlicePartialEq<B>>::equal
 34,544 ( 0.36%)     0            0          17,272 ( 0.71%)     0              0            8,636 ( 0.27%)     0            0           /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/core/src/num/uint_macros.rs:<core::ops::range::Range<usize> as core::slice::index::SliceIndex<[T]>>::get_unchecked
 34,544 ( 0.36%)     0            0           8,636 ( 0.36%)     0              0           17,272 ( 0.55%)     0            0           /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/core/src/ptr/const_ptr.rs:<core::ops::range::Range<usize> as core::slice::index::SliceIndex<[T]>>::get_unchecked
 34,544 ( 0.36%)     0            0               0              0              0                0              0            0           /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/core/src/slice/index.rs:<core::ops::range::Range<usize> as core::slice::index::SliceIndex<[T]>>::get_unchecked::precondition_check
 33,804 ( 0.36%)   209 ( 0.14%)   2 ( 0.03%)  5,634 ( 0.23%)     0              0           11,268 ( 0.36%)     0            0           /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/core/src/slice/index.rs:<core::ops::range::RangeFrom<usize> as core::slice::index::SliceIndex<[T]>>::index_mut
 33,664 ( 0.35%)   477 ( 0.33%)   4 ( 0.06%)  8,416 ( 0.35%)     0              0            9,468 ( 0.30%)     0            0           /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/core/src/alloc/layout.rs:core::alloc::layout::Layout::array::inner
 33,544 ( 0.35%)     0            0               0              0              0           25,158 ( 0.80%)     0            0           /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/core/src/fmt/mod.rs:core::ptr::const_ptr::<impl *const T>::align_offset
 33,492 ( 0.35%)   473 ( 0.33%)  10 ( 0.14%)  8,063 ( 0.33%)    31 ( 0.54%)     3 ( 0.08%)   5,438 ( 0.17%)   463 ( 8.71%) 428 (10.21%)  ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms
 32,964 ( 0.35%)   106 ( 0.07%)   1 ( 0.01%)  5,494 ( 0.23%)     0              0           13,735 ( 0.44%)     0            0           /home/ashy5000/dev/cryptocurrency/contracts/target/debug/build/tikv-jemalloc-sys-7365f40ecb99e085/out/build/include/jemalloc/internal/tcache_inlines.h:smartstring::ops::Push::cap
 32,864 ( 0.35%)    27 ( 0.02%)   1 ( 0.01%) 16,432 ( 0.68%)     0              0            8,216 ( 0.26%)     0            0           /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/core/src/ub_checks.rs:<usize as core::slice::index::SliceIndex<[T]>>::get
 32,864 ( 0.35%)     0            0           8,216 ( 0.34%)     0              0                0              0            0           /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/core/src/str/pattern.rs:<core::str::pattern::MatchOnly as core::str::pattern::TwoWayStrategy>::use_early_reject
 32,400 ( 0.34%)     2 ( 0.00%)   2 ( 0.03%) 10,800 ( 0.44%)     0              0           13,200 ( 0.42%)     0            0           /home/ashy5000/dev/cryptocurrency/contracts/target/debug/build/tikv-jemalloc-sys-7365f40ecb99e085/out/build/src/eset.c:eset_bin_stats_init
 32,395 ( 0.34%)   202 ( 0.14%)   5 ( 0.07%) 10,812 ( 0.44%)     0              0            4,660 ( 0.15%)     0            0           /home/ashy5000/dev/cryptocurrency/contracts/target/debug/build/tikv-jemalloc-sys-7365f40ecb99e085/out/build/src/base.c:base_alloc_impl
 32,375 ( 0.34%)   678 ( 0.47%)   6 ( 0.08%)  7,400 ( 0.30%)     7 ( 0.12%)     0            3,700 ( 0.12%)     1 ( 0.02%)   0           /home/ashy5000/dev/cryptocurrency/contracts/target/debug/build/tikv-jemalloc-sys-7365f40ecb99e085/out/build/include/jemalloc/internal/sz.h:_rjem_sdallocx
 32,100 ( 0.34%)    31 ( 0.02%)   0          12,840 ( 0.53%)     0              0            6,420 ( 0.20%)     0            0           /home/ashy5000/dev/cryptocurrency/contracts/target/debug/build/tikv-jemalloc-sys-7365f40ecb99e085/out/build/include/jemalloc/internal/bit_util.h:cfs_lu
 31,094 ( 0.33%)   104 ( 0.07%)   0          15,547 ( 0.64%)     0              0           13,326 ( 0.42%)    53 ( 1.00%)   6 ( 0.14%)  /home/ashy5000/.cargo/registry/src/index.crates.io-6f17d22bba15001f/smartstring-1.0.1/src/lib.rs:smartstring::SmartString<Mode>::from_inline
 31,071 ( 0.33%)   390 ( 0.27%)   1 ( 0.01%) 10,357 ( 0.43%)     0              0           10,357 ( 0.33%)     0            0           /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/core/src/ptr/non_null.rs:<core::slice::iter::Iter<T> as core::iter::traits::iterator::Iterator>::next
 31,031 ( 0.33%)   200 ( 0.14%)   2 ( 0.03%)  8,463 ( 0.35%)     1 ( 0.02%)     1 ( 0.03%)   5,642 ( 0.18%)     0            0           /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/core/src/option.rs:core::str::validations::next_code_point
 29,443 ( 0.31%)   580 ( 0.40%)   8 ( 0.11%)  5,459 ( 0.22%)    43 ( 0.75%)     7 ( 0.20%)       0              0            0           ./string/../sysdeps/x86_64/multiarch/memcmp-avx2-movbe.S:__memcmp_avx2_movbe
 29,340 ( 0.31%)    72 ( 0.05%)   1 ( 0.01%)  7,824 ( 0.32%)     0              0            9,780 ( 0.31%)     0            0           /home/ashy5000/.cargo/registry/src/index.crates.io-6f17d22bba15001f/tikv-jemallocator-0.6.0/src/lib.rs:tikv_jemallocator::layout_to_flags
 28,868 ( 0.30%)   139 ( 0.10%)   3 ( 0.04%)  8,248 ( 0.34%)    23 ( 0.40%)    15 ( 0.42%)  10,310 ( 0.33%)    31 ( 0.58%)  27 ( 0.64%)  /home/ashy5000/dev/cryptocurrency/contracts/target/debug/build/tikv-jemalloc-sys-7365f40ecb99e085/out/build/src/edata.c:_rjem_je_edata_heap_remove_first
 28,550 ( 0.30%)   248 ( 0.17%)   8 ( 0.11%) 10,660 ( 0.44%)     2 ( 0.03%)     0            6,044 ( 0.19%)   139 ( 2.61%) 139 ( 3.32%)  /home/ashy5000/dev/cryptocurrency/contracts/target/debug/build/tikv-jemalloc-sys-7365f40ecb99e085/out/build/src/arena.c:arena_slab_reg_alloc_batch
 28,316 ( 0.30%)    32 ( 0.02%)   2 ( 0.03%)    219 ( 0.01%)     1 ( 0.02%)     0           19,646 ( 0.62%)     0            0           /home/ashy5000/dev/cryptocurrency/contracts/target/debug/build/tikv-jemalloc-sys-7365f40ecb99e085/out/build/include/jemalloc/internal/sz.h:smartstring::ops::Push::op
 28,170 ( 0.30%)   201 ( 0.14%)   1 ( 0.01%)  8,451 ( 0.35%)     0              0            5,634 ( 0.18%)     0            0           /home/ashy5000/dev/cryptocurrency/contracts/target/debug/build/tikv-jemalloc-sys-7365f40ecb99e085/out/build/include/jemalloc/internal/sz.h:core::char::convert::from_u32_unchecked::precondition_check
 27,724 ( 0.29%)   507 ( 0.35%)   3 ( 0.04%)  9,242 ( 0.38%)     0              0            3,696 ( 0.12%)     0            0           /home/ashy5000/dev/cryptocurrency/contracts/target/debug/build/tikv-jemalloc-sys-7365f40ecb99e085/out/build/include/jemalloc/internal/tsd.h:_rjem_sdallocx
 27,720 ( 0.29%)   371 ( 0.26%)   2 ( 0.03%) 13,860 ( 0.57%)     3 ( 0.05%)     0            2,772 ( 0.09%)    26 ( 0.49%)   0           /home/ashy5000/dev/cryptocurrency/contracts/target/debug/build/tikv-jemalloc-sys-7365f40ecb99e085/out/build/include/jemalloc/internal/cache_bin.h:_rjem_sdallocx
 27,585 ( 0.29%)   832 ( 0.58%)   7 ( 0.10%)  9,200 ( 0.38%)     0              0            3,674 ( 0.12%)     3 ( 0.06%)   0           /home/ashy5000/dev/cryptocurrency/contracts/target/debug/build/tikv-jemalloc-sys-7365f40ecb99e085/out/build/include/jemalloc/internal/tsd.h:_rjem_malloc
 27,440 ( 0.29%)    26 ( 0.02%)   1 ( 0.01%)  2,744 ( 0.11%)     0              0           16,464 ( 0.52%)     0            0           /home/ashy5000/.cargo/registry/src/index.crates.io-6f17d22bba15001f/smartstring-1.0.1/src/inline.rs:<smartstring::inline::InlineString as smartstring::ops::GenericString>::set_size
 27,438 ( 0.29%)   505 ( 0.35%)   5 ( 0.07%)  3,228 ( 0.13%)     0              0           11,298 ( 0.36%)     1 ( 0.02%)   0           /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/core/src/ub_checks.rs:core::intrinsics::copy_nonoverlapping::precondition_check
 27,438 ( 0.29%)   477 ( 0.33%)   6 ( 0.08%) 11,298 ( 0.46%)     0              0            3,228 ( 0.10%)     0            0           /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/core/src/ptr/const_ptr.rs:core::intrinsics::copy_nonoverlapping::precondition_check
 27,324 ( 0.29%)   160 ( 0.11%)   2 ( 0.03%)  6,839 ( 0.28%)     0              0            8,605 ( 0.27%)     0            0           /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/core/src/cmp.rs:core::cmp::max_by
 26,400 ( 0.28%)     2 ( 0.00%)   2 ( 0.03%)  7,200 ( 0.30%)     2 ( 0.03%)     2 ( 0.06%)       0              0            0           /home/ashy5000/dev/cryptocurrency/contracts/target/debug/build/tikv-jemalloc-sys-7365f40ecb99e085/out/build/include/jemalloc/internal/atomic_gcc_atomic.h:eset_bin_stats_init
 26,124 ( 0.28%)    17 ( 0.01%)  17 ( 0.24%)  6,117 ( 0.25%)   628 (10.89%)   605 (16.86%)     778 ( 0.02%)     3 ( 0.06%)   0           ./elf/./elf/do-rel.h:_dl_relocate_object
 26,027 ( 0.27%)   404 ( 0.28%)   3 ( 0.04%)  2,678 ( 0.11%)     0              0           10,088 ( 0.32%)     0            0           /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/core/src/num/uint_macros.rs:core::ub_checks::is_nonoverlapping::runtime
 25,962 ( 0.27%)   546 ( 0.38%)   7 ( 0.10%) 13,749 ( 0.57%)    41 ( 0.71%)    10 ( 0.28%)   4,839 ( 0.15%)     0            0           /home/ashy5000/dev/cryptocurrency/contracts/target/debug/build/tikv-jemalloc-sys-7365f40ecb99e085/out/build/include/jemalloc/internal/cache_bin.h:_rjem_malloc
 25,872 ( 0.27%) 1,544 ( 1.07%)  38 ( 0.54%)  7,840 ( 0.32%)     4 ( 0.07%)     0            5,292 ( 0.17%)    38 ( 0.71%)  22 ( 0.53%)  /home/ashy5000/dev/cryptocurrency/contracts/target/debug/build/tikv-jemalloc-sys-7365f40ecb99e085/out/build/include/jemalloc/internal/tsd.h:do_rallocx
 25,540 ( 0.27%)    12 ( 0.01%)  12 ( 0.17%)  2,952 ( 0.12%)     5 ( 0.09%)     4 ( 0.11%)   1,100 ( 0.03%)     0            0           ./stdlib/../stdlib/strtol_l.c:____strtoul_l_internal
 25,377 ( 0.27%)    29 ( 0.02%)   1 ( 0.01%)  5,638 ( 0.23%)     0              0           11,276 ( 0.36%)     0            0           /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/core/src/option.rs:<core::str::iter::Chars as core::iter::traits::iterator::Iterator>::next
 25,353 ( 0.27%)     0            0           5,634 ( 0.23%)     0              0           19,719 ( 0.63%)     0            0           /home/ashy5000/dev/cryptocurrency/contracts/target/debug/build/tikv-jemalloc-sys-7365f40ecb99e085/out/build/include/jemalloc/internal/tsd.h:<core::ops::range::RangeFrom<usize> as core::slice::index::SliceIndex<[T]>>::index_mut
 25,353 ( 0.27%)     0            0           2,817 ( 0.12%)     0              0           16,902 ( 0.54%)     0            0           /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/core/src/char/methods.rs:core::char::methods::<impl char>::encode_utf8
 25,350 ( 0.27%)   232 ( 0.16%)   2 ( 0.03%)  6,339 ( 0.26%)     0              0           12,678 ( 0.40%)     0            0           /home/ashy5000/.cargo/registry/src/index.crates.io-6f17d22bba15001f/smartstring-1.0.1/src/lib.rs:smartstring::SmartString<Mode>::as_str
 25,340 ( 0.27%) 1,264 ( 0.88%)   7 ( 0.10%)  6,335 ( 0.26%)     0              0            9,050 ( 0.29%)     0            0           /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/alloc/src/alloc.rs:alloc::alloc::Global::alloc_impl
 25,254 ( 0.27%)   200 ( 0.14%)   1 ( 0.01%)  8,386 ( 0.34%)     0              0            8,386 ( 0.27%)     0            0           /home/ashy5000/.cargo/registry/src/index.crates.io-6f17d22bba15001f/smartstring-1.0.1/src/marker_byte.rs:smartstring::SmartString<Mode>::discriminant
 25,158 ( 0.27%)     0            0               0              0              0            8,386 ( 0.27%)     0            0           /home/ashy5000/dev/cryptocurrency/contracts/target/debug/build/tikv-jemalloc-sys-7365f40ecb99e085/out/build/src/jemalloc.c:smartstring::SmartString<Mode>::discriminant
 25,059 ( 0.26%)   195 ( 0.14%)   2 ( 0.03%)  5,530 ( 0.23%)     0              0            6,004 ( 0.19%)     0            0           /home/ashy5000/dev/cryptocurrency/contracts/target/debug/build/tikv-jemalloc-sys-7365f40ecb99e085/out/build/include/jemalloc/internal/tsd.h:<smartstring::SmartString<Mode> as core::iter::traits::collect::FromIterator<char>>::from_iter
 24,794 ( 0.26%)    90 ( 0.06%)   2 ( 0.03%)  9,702 ( 0.40%)     0              0            9,702 ( 0.31%)     0            0           /home/ashy5000/.cargo/registry/src/index.crates.io-6f17d22bba15001f/smartstring-1.0.1/src/inline.rs:smartstring::inline::InlineString::new
 24,524 ( 0.26%)   102 ( 0.07%)   0               0              0              0                0              0            0           /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/core/src/slice/index.rs:<core::ops::range::Range<usize> as core::slice::index::SliceIndex<[T]>>::get_unchecked_mut::precondition_check
 24,524 ( 0.26%)    41 ( 0.03%)   1 ( 0.01%) 12,262 ( 0.50%)     0              0            6,131 ( 0.19%)     0            0           /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/core/src/num/uint_macros.rs:<core::ops::range::Range<usize> as core::slice::index::SliceIndex<[T]>>::get_unchecked_mut
 24,206 ( 0.26%) 1,308 ( 0.91%)  39 ( 0.55%)  5,978 ( 0.25%)    54 ( 0.94%)     2 ( 0.06%)   5,586 ( 0.18%)    60 ( 1.13%)  33 ( 0.79%)  /home/ashy5000/dev/cryptocurrency/contracts/target/debug/build/tikv-jemalloc-sys-7365f40ecb99e085/out/build/src/jemalloc.c:do_rallocx
 24,160 ( 0.25%)   298 ( 0.21%)   3 ( 0.04%)  9,006 ( 0.37%)     0              0            7,263 ( 0.23%)     0            0           /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/core/src/ptr/const_ptr.rs:core::ptr::const_ptr::<impl *const T>::sub_ptr
 23,592 ( 0.25%)     0            0          15,728 ( 0.65%)     0              0            7,864 ( 0.25%)     0            0           /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/core/src/alloc/layout.rs:core::alloc::layout::Layout::size
 23,345 ( 0.25%)    49 ( 0.03%)   1 ( 0.01%)  6,670 ( 0.27%)     0              0           10,005 ( 0.32%)     0            0           /home/ashy5000/.cargo/registry/src/index.crates.io-6f17d22bba15001f/smartstring-1.0.1/src/lib.rs:smartstring::SmartString<Mode>::cast
 23,221 ( 0.24%)     7 ( 0.00%)   1 ( 0.01%)  8,444 ( 0.35%)     0              0            4,222 ( 0.13%)     0            0           /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/core/src/iter/adapters/skip.rs:<core::iter::adapters::skip::Skip<I> as core::iter::traits::iterator::Iterator>::next
 23,216 ( 0.24%)   316 ( 0.22%)   8 ( 0.11%)  9,114 ( 0.37%)     0              0            9,120 ( 0.29%)     0            0           /rust/deps/hashbrown-0.14.5/src/raw/mod.rs:hashbrown::raw::RawTable<T,A>::find
 22,944 ( 0.24%)     3 ( 0.00%)   3 ( 0.04%)  7,242 ( 0.30%)     0              0            2,442 ( 0.08%)     1 ( 0.02%)   1 ( 0.02%)  /home/ashy5000/dev/cryptocurrency/contracts/target/debug/build/tikv-jemalloc-sys-7365f40ecb99e085/out/build/src/eset.c:_rjem_je_eset_init
 22,830 ( 0.24%)   916 ( 0.64%)  16 ( 0.23%)  8,731 ( 0.36%)     0              0           10,272 ( 0.33%)     0            0           /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/alloc/src/raw_vec.rs:alloc::raw_vec::RawVec<T,A>::current_memory
 22,811 ( 0.24%)     0            0           5,760 ( 0.24%)     0              0            9,405 ( 0.30%)     0            0           /home/ashy5000/dev/cryptocurrency/contracts/target/debug/build/tikv-jemalloc-sys-7365f40ecb99e085/out/build/include/jemalloc/internal/sz.h:<core::iter::adapters::take::Take<I> as core::iter::traits::iterator::Iterator>::next
 22,583 ( 0.24%)   198 ( 0.14%)   2 ( 0.03%) 10,115 ( 0.42%)     0              0            6,470 ( 0.21%)     0            0           /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/core/src/iter/adapters/take.rs:<core::iter::adapters::take::Take<I> as core::iter::traits::iterator::Iterator>::next
 22,564 ( 0.24%)    50 ( 0.03%)   2 ( 0.03%)  8,459 ( 0.35%)     0              0            8,463 ( 0.27%)     0            0           /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/core/src/str/iter.rs:<core::str::iter::Chars as core::iter::traits::iterator::Iterator>::next
 22,536 ( 0.24%)   144 ( 0.10%)   3 ( 0.04%)  2,817 ( 0.12%)     0              0           11,268 ( 0.36%)     0            0           /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/core/src/char/methods.rs:core::char::methods::<impl char>::len_utf8
 22,536 ( 0.24%)     0            0               0              0              0            8,451 ( 0.27%)     0            0           /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/core/src/char/convert.rs:core::char::convert::from_u32_unchecked::precondition_check
 21,936 ( 0.23%)   819 ( 0.57%)   6 ( 0.08%)  5,484 ( 0.23%)     1 ( 0.02%)     0           10,054 ( 0.32%)     0            0           /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/alloc/src/alloc.rs:<alloc::alloc::Global as core::alloc::Allocator>::deallocate
 20,812 ( 0.22%)   285 ( 0.20%)   3 ( 0.04%)  6,292 ( 0.26%)     0              0           10,164 ( 0.32%)     0            0           /home/ashy5000/.cargo/registry/src/index.crates.io-6f17d22bba15001f/smartstring-1.0.1/src/inline.rs:<smartstring::inline::InlineString as core::convert::From<&str>>::from
 20,683 ( 0.22%)    95 ( 0.07%)  73 ( 1.03%)  3,961 ( 0.16%)   217 ( 3.76%)   153 ( 4.26%)       0              0            0           ./string/../sysdeps/x86_64/strcmp.S:strcmp
 20,678 ( 0.22%)   954 ( 0.66%)  25 ( 0.35%)  6,566 ( 0.27%)     1 ( 0.02%)     1 ( 0.03%)   5,782 ( 0.18%)    19 ( 0.36%)  17 ( 0.41%)  /home/ashy5000/dev/cryptocurrency/contracts/target/debug/build/tikv-jemalloc-sys-7365f40ecb99e085/out/build/include/jemalloc/internal/rtree.h:rtree_metadata_read
 20,637 ( 0.22%)     0            0               0              0              0            6,879 ( 0.22%)     0            0           /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/core/src/ptr/mod.rs:<core::slice::iter::Iter<T> as core::iter::traits::iterator::Iterator>::next
 20,527 ( 0.22%)   267 ( 0.19%)   4 ( 0.06%)  5,191 ( 0.21%)     0              0            8,072 ( 0.26%)     1 ( 0.02%)   0           /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/core/src/ub_checks.rs:core::ub_checks::is_nonoverlapping::runtime
 20,394 ( 0.21%)    66 ( 0.05%)   1 ( 0.01%)  9,687 ( 0.40%)     0              0            1,020 ( 0.03%)     0            0           /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/core/src/str/mod.rs:core::str::<impl str>::len
 20,384 ( 0.21%) 1,154 ( 0.80%)  25 ( 0.35%)  6,370 ( 0.26%)     2 ( 0.03%)     1 ( 0.03%)   5,684 ( 0.18%)    31 ( 0.58%)  27 ( 0.64%)  /home/ashy5000/dev/cryptocurrency/contracts/target/debug/build/tikv-jemalloc-sys-7365f40ecb99e085/out/build/include/jemalloc/internal/rtree.h:rtree_read
 20,372 ( 0.21%)   544 ( 0.38%)   3 ( 0.04%)  7,408 ( 0.30%)     5 ( 0.09%)     0            2,778 ( 0.09%)     5 ( 0.09%)   0           /home/ashy5000/dev/cryptocurrency/contracts/target/debug/build/tikv-jemalloc-sys-7365f40ecb99e085/out/build/include/jemalloc/internal/sz.h:_rjem_malloc
 20,118 ( 0.21%)   254 ( 0.18%)   2 ( 0.03%)  4,488 ( 0.18%)     1 ( 0.02%)     0            8,950 ( 0.28%)     0            0           /home/ashy5000/.cargo/registry/src/index.crates.io-6f17d22bba15001f/smartstring-1.0.1/src/lib.rs:<smartstring::SmartString<Mode> as core::ops::drop::Drop>::drop
 19,624 ( 0.21%)   189 ( 0.13%)   2 ( 0.03%)  5,577 ( 0.23%)     0              0            3,718 ( 0.12%)     0            0           /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/core/src/cmp.rs:core::cmp::impls::<impl core::cmp::Ord for usize>::cmp
 19,573 ( 0.21%)   107 ( 0.07%)   2 ( 0.03%)  5,561 ( 0.23%)     0              0            8,451 ( 0.27%)     0            0           /home/ashy5000/dev/cryptocurrency/contracts/target/debug/build/tikv-jemalloc-sys-7365f40ecb99e085/out/build/include/jemalloc/internal/tcache_inlines.h:smartstring::ops::Push::op
 19,521 ( 0.21%)   110 ( 0.08%)   1 ( 0.01%)  5,739 ( 0.24%)    40 ( 0.69%)     0           10,329 ( 0.33%)     0            0           /home/ashy5000/dev/cryptocurrency/contracts/target/debug/build/tikv-jemalloc-sys-7365f40ecb99e085/out/build/include/jemalloc/internal/sz.h:<smartstring::SmartString<Mode> as core::clone::Clone>::clone
 19,208 ( 0.20%)   106 ( 0.07%)   1 ( 0.01%)  5,488 ( 0.23%)     0              0            8,232 ( 0.26%)     0            0           /home/ashy5000/.cargo/registry/src/index.crates.io-6f17d22bba15001f/smartstring-1.0.1/src/inline.rs:<smartstring::inline::InlineString as smartstring::ops::GenericString>::as_mut_capacity_slice
 18,695 ( 0.20%)   328 ( 0.23%)   5 ( 0.07%)  1,194 ( 0.05%)     2 ( 0.03%)     0            6,608 ( 0.21%)   199 ( 3.74%) 184 ( 4.39%)  ./string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:__memset_avx2_unaligned_erms
 18,580 ( 0.20%)   362 ( 0.25%)   2 ( 0.03%)  4,645 ( 0.19%)     0              0            8,361 ( 0.27%)     1 ( 0.02%)   0           /home/ashy5000/dev/cryptocurrency/contracts/src/main.rs:__rust_dealloc
 18,580 ( 0.20%)   328 ( 0.23%)   2 ( 0.03%)  4,645 ( 0.19%)     1 ( 0.02%)     0            6,503 ( 0.21%)     0            0           /home/ashy5000/.cargo/registry/src/index.crates.io-6f17d22bba15001f/tikv-jemallocator-0.6.0/src/lib.rs:<tikv_jemallocator::Jemalloc as core::alloc::global::GlobalAlloc>::dealloc
 18,469 ( 0.19%)   220 ( 0.15%)   6 ( 0.08%)  5,767 ( 0.24%)     0              0            4,818 ( 0.15%)     0            0           /home/ashy5000/dev/cryptocurrency/contracts/src/buffer.rs:contracts::buffer::Buffer::as_u64
 18,409 ( 0.19%)   798 ( 0.55%)  13 ( 0.18%)  7,831 ( 0.32%)     1 ( 0.02%)     0            6,229 ( 0.20%)     0            0           /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/alloc/src/vec/mod.rs:alloc::vec::Vec<T,A>::push
 18,354 ( 0.19%)     0            0               0              0              0           18,354 ( 0.58%)     0            0           /home/ashy5000/dev/cryptocurrency/contracts/target/debug/build/tikv-jemalloc-sys-7365f40ecb99e085/out/build/include/jemalloc/internal/prof_inlines.h:core::str::<impl str>::len
 17,632 ( 0.19%)    63 ( 0.04%)   3 ( 0.04%)  5,510 ( 0.23%)     0              0            3,306 ( 0.10%)     0            0           /home/ashy5000/dev/cryptocurrency/contracts/target/debug/build/tikv-jemalloc-sys-7365f40ecb99e085/out/build/include/jemalloc/internal/bit_util.h:ffs_lu
 17,560 ( 0.19%)   382 ( 0.27%)   9 ( 0.13%)  5,469 ( 0.22%)     0              0            4,747 ( 0.15%)     0            0           /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/alloc/src/raw_vec.rs:<alloc::raw_vec::RawVec<T,A> as core::ops::drop::Drop>::drop
 17,248 ( 0.18%)    38 ( 0.03%)   1 ( 0.01%)  3,234 ( 0.13%)     0              0            6,468 ( 0.21%)     0            0           /home/ashy5000/.cargo/registry/src/index.crates.io-6f17d22bba15001f/smartstring-1.0.1/src/marker_byte.rs:smartstring::inline::InlineString::new
 16,945 ( 0.18%)     2 ( 0.00%)   0          13,556 ( 0.56%)     0              0            3,389 ( 0.11%)     0            0           /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/core/src/slice/cmp.rs:core::str::traits::<impl core::cmp::PartialEq for str>::eq
 16,772 ( 0.18%)     0            0               0              0              0            8,386 ( 0.27%)     0            0           /home/ashy5000/dev/cryptocurrency/contracts/target/debug/build/tikv-jemalloc-sys-7365f40ecb99e085/out/build/include/jemalloc/internal/tsd.h:smartstring::SmartString<Mode>::discriminant
 16,716 ( 0.18%)   208 ( 0.14%)   2 ( 0.03%)  5,970 ( 0.25%)     1 ( 0.02%)     0            3,582 ( 0.11%)     0            0           /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/core/src/cmp.rs:core::cmp::impls::<impl core::cmp::PartialEq<&B> for &A>::eq
 16,650 ( 0.18%)   601 ( 0.42%)   7 ( 0.10%)  4,440 ( 0.18%)     0              0            4,440 ( 0.14%)     6 ( 0.11%)   2 ( 0.05%)  /home/ashy5000/dev/cryptocurrency/contracts/target/debug/build/tikv-jemalloc-sys-7365f40ecb99e085/out/build/include/jemalloc/internal/cache_bin.h:cache_bin_assert_earlier
 16,548 ( 0.17%)     0            0               0              0              0           16,548 ( 0.52%)     0            0           /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/core/src/slice/mod.rs:core::str::pattern::TwoWaySearcher::next
 16,464 ( 0.17%)   810 ( 0.56%)  18 ( 0.25%)  6,860 ( 0.28%)     0              0            5,194 ( 0.16%)    15 ( 0.28%)   6 ( 0.14%)  /home/ashy5000/dev/cryptocurrency/contracts/target/debug/build/tikv-jemalloc-sys-7365f40ecb99e085/out/build/include/jemalloc/internal/thread_event.h:do_rallocx
 16,432 ( 0.17%)    74 ( 0.05%)   1 ( 0.01%)      0              0              0                0              0            0           /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/core/src/slice/index.rs:<usize as core::slice::index::SliceIndex<[T]>>::get_unchecked::precondition_check
 16,247 ( 0.17%)   340 ( 0.24%)   3 ( 0.04%)  4,642 ( 0.19%)     0              0            2,321 ( 0.07%)     0            0           /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/core/src/ptr/const_ptr.rs:core::slice::raw::from_raw_parts::precondition_check
 16,140 ( 0.17%)   122 ( 0.08%)   0           3,228 ( 0.13%)     0              0            6,456 ( 0.20%)     0            0           /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/core/src/array/mod.rs:core::array::<impl core::convert::AsMut<[T]> for [T; N]>::as_mut
 15,858 ( 0.17%)     6 ( 0.00%)   6 ( 0.08%)  5,973 ( 0.25%)     0              0            3,980 ( 0.13%)     1 ( 0.02%)   0           /home/ashy5000/dev/cryptocurrency/contracts/target/debug/build/tikv-jemalloc-sys-7365f40ecb99e085/out/build/src/sc.c:size_class
 15,793 ( 0.17%)   121 ( 0.08%)   2 ( 0.03%)  5,574 ( 0.23%)     0              0            4,645 ( 0.15%)    15 ( 0.28%)   0           /home/ashy5000/dev/cryptocurrency/contracts/target/debug/build/tikv-jemalloc-sys-7365f40ecb99e085/out/build/src/jemalloc.c:_rjem_malloc
 15,601 ( 0.16%)   830 ( 0.58%)   3 ( 0.04%)  6,533 ( 0.27%)     0              0            5,403 ( 0.17%)     0            0           /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/core/src/str/iter.rs:core::str::iter::SplitInternal<P>::next
 15,500 ( 0.16%)   246 ( 0.17%)   5 ( 0.07%)  3,000 ( 0.12%)     0              0            7,500 ( 0.24%)     3 ( 0.06%)   0           /home/ashy5000/.cargo/registry/src/index.crates.io-6f17d22bba15001f/rustc-hash-2.0.0/src/lib.rs:rustc_hash::hash_bytes
 15,498 ( 0.16%)   940 ( 0.65%)  28 ( 0.39%)  4,662 ( 0.19%)     1 ( 0.02%)     0            3,276 ( 0.10%)    19 ( 0.36%)  14 ( 0.33%)  /home/ashy5000/dev/cryptocurrency/contracts/target/debug/build/tikv-jemalloc-sys-7365f40ecb99e085/out/build/include/jemalloc/internal/rtree.h:_rjem_je_emap_update_edata_state
 15,336 ( 0.16%)   330 ( 0.23%)  34 ( 0.48%)  5,718 ( 0.24%)   104 ( 1.80%)     0            1,147 ( 0.04%)    51 ( 0.96%)  41 ( 0.98%)  /home/ashy5000/dev/cryptocurrency/contracts/target/debug/build/tikv-jemalloc-sys-7365f40ecb99e085/out/build/include/jemalloc/internal/ph.h:_rjem_je_edata_heap_remove_first
 14,994 ( 0.16%)   294 ( 0.20%)   4 ( 0.06%)  4,284 ( 0.18%)     0              0            4,998 ( 0.16%)     0            0           /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/core/src/str/iter.rs:<core::str::iter::Chars as core::iter::traits::iterator::Iterator>::advance_by
 14,899 ( 0.16%)    80 ( 0.06%)   6 ( 0.08%)  3,134 ( 0.13%)     0              0            3,530 ( 0.11%)     0            0           /home/ashy5000/.cargo/registry/src/index.crates.io-6f17d22bba15001f/hex-0.4.3/src/lib.rs:hex::val
 14,760 ( 0.16%)    25 ( 0.02%)  25 ( 0.35%)  6,357 ( 0.26%)     0              0            1,420 ( 0.05%)     3 ( 0.06%)   2 ( 0.05%)  /home/ashy5000/dev/cryptocurrency/contracts/target/debug/build/tikv-jemalloc-sys-7365f40ecb99e085/out/build/src/sc.c:size_classes
 14,684 ( 0.15%)   774 ( 0.54%)  29 ( 0.41%)  3,624 ( 0.15%)     0              0            2,250 ( 0.07%)    13 ( 0.24%)   8 ( 0.19%)  /home/ashy5000/dev/cryptocurrency/contracts/target/debug/build/tikv-jemalloc-sys-7365f40ecb99e085/out/build/include/jemalloc/internal/sz.h:_rjem_je_arena_ralloc_no_move
 14,526 ( 0.15%)   264 ( 0.18%)   2 ( 0.03%)      0              0              0           11,298 ( 0.36%)     0            0           /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/core/src/fmt/mod.rs:core::intrinsics::copy_nonoverlapping::precondition_check
 14,236 ( 0.15%)    19 ( 0.01%)   6 ( 0.08%)  4,744 ( 0.20%)   288 ( 4.99%)   207 ( 5.77%)   1,664 ( 0.05%)     4 ( 0.08%)   1 ( 0.02%)  ./elf/./elf/dl-lookup.c:check_match
 14,085 ( 0.15%)   203 ( 0.14%)   1 ( 0.01%)      0              0              0           14,085 ( 0.45%)     0            0           /home/ashy5000/dev/cryptocurrency/contracts/target/debug/build/tikv-jemalloc-sys-7365f40ecb99e085/out/build/include/jemalloc/internal/tsd.h:core::char::methods::encode_utf8_raw
 14,085 ( 0.15%)     0            0           2,817 ( 0.12%)     0              0            5,634 ( 0.18%)     0            0           /home/ashy5000/dev/cryptocurrency/contracts/target/debug/build/tikv-jemalloc-sys-7365f40ecb99e085/out/build/include/jemalloc/internal/prof_inlines.h:core::char::methods::encode_utf8_raw
 14,085 ( 0.15%)     0            0               0              0              0           14,085 ( 0.45%)     0            0           /home/ashy5000/dev/cryptocurrency/contracts/target/debug/build/tikv-jemalloc-sys-7365f40ecb99e085/out/build/src/jemalloc.c:smartstring::SmartString<Mode>::push
 13,939 ( 0.15%)    24 ( 0.02%)   0           8,305 ( 0.34%)     0              0                0              0            0           /home/ashy5000/.cargo/registry/src/index.crates.io-6f17d22bba15001f/smartstring-1.0.1/src/lib.rs:smartstring::SmartString<Mode>::push
 13,926 ( 0.15%)   154 ( 0.11%)   2 ( 0.03%)      0              0              0           11,605 ( 0.37%)     0            0           /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/core/src/fmt/mod.rs:core::slice::raw::from_raw_parts::precondition_check
 13,862 ( 0.15%)   416 ( 0.29%)   3 ( 0.04%)  5,542 ( 0.23%)     0              0            3,690 ( 0.12%)     0            0           /home/ashy5000/dev/cryptocurrency/contracts/target/debug/build/tikv-jemalloc-sys-7365f40ecb99e085/out/build/include/jemalloc/internal/thread_event.h:_rjem_malloc
 13,746 ( 0.14%)    14 ( 0.01%)   1 ( 0.01%)      0              0              0            2,600 ( 0.08%)     0            0           /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/core/src/num/uint_macros.rs:core::num::<impl usize>::unchecked_mul::precondition_check
 13,556 ( 0.14%)     0            0               0              0              0           13,556 ( 0.43%)     0            0           /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/core/src/str/mod.rs:core::str::traits::<impl core::cmp::PartialEq for str>::eq
 13,548 ( 0.14%) 1,172 ( 0.81%)  57 ( 0.80%)  4,058 ( 0.17%)     0              0            2,700 ( 0.09%)     9 ( 0.17%)   5 ( 0.12%)  /home/ashy5000/dev/cryptocurrency/contracts/target/debug/build/tikv-jemalloc-sys-7365f40ecb99e085/out/build/include/jemalloc/internal/tsd.h:malloc_mutex_lock
 13,332 ( 0.14%)   751 ( 0.52%)  28 ( 0.39%)  3,806 ( 0.16%)     1 ( 0.02%)     1 ( 0.03%)   2,333 ( 0.07%)    23 ( 0.43%)  15 ( 0.36%)  /home/ashy5000/dev/cryptocurrency/contracts/target/debug/build/tikv-jemalloc-sys-7365f40ecb99e085/out/build/include/jemalloc/internal/rtree.h:emap_rtree_leaf_elms_lookup
 13,326 ( 0.14%)   112 ( 0.08%)   1 ( 0.01%)  6,663 ( 0.27%)     0              0            6,663 ( 0.21%)     0            0           /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/core/src/mem/manually_drop.rs:smartstring::SmartString<Mode>::from_inline
 13,326 ( 0.14%)     0            0           6,663 ( 0.27%)     0              0            6,663 ( 0.21%)     0            0           /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/core/src/mem/maybe_uninit.rs:smartstring::SmartString<Mode>::from_inline
 13,212 ( 0.14%)     1 ( 0.00%)   1 ( 0.01%)  4,404 ( 0.18%)     0              0            4,404 ( 0.14%)     0            0           /home/ashy5000/dev/cryptocurrency/contracts/target/debug/build/tikv-jemalloc-sys-7365f40ecb99e085/out/build/src/edata.c:_rjem_je_edata_heap_new
 13,200 ( 0.14%)     2 ( 0.00%)   2 ( 0.03%)  3,600 ( 0.15%)     0              0            3,600 ( 0.11%)     0            0           /home/ashy5000/dev/cryptocurrency/contracts/target/debug/build/tikv-jemalloc-sys-7365f40ecb99e085/out/build/src/eset.c:eset_bin_init
 13,182 ( 0.14%)   419 ( 0.29%)   6 ( 0.08%)  5,577 ( 0.23%)     0              0            1,014 ( 0.03%)     0            0           /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/core/src/str/pattern.rs:<core::str::pattern::StrSearcher as core::str::pattern::Searcher>::next_match
 12,852 ( 0.14%)     5 ( 0.00%)   0           1,504 ( 0.06%)     0              0            4,941 ( 0.16%)     0            0           /home/ashy5000/dev/cryptocurrency/contracts/target/debug/build/tikv-jemalloc-sys-7365f40ecb99e085/out/build/src/jemalloc.c:<hashbrown::raw::bitmask::BitMaskIter as core::iter::traits::iterator::Iterator>::next
 12,807 ( 0.14%)   140 ( 0.10%)   1 ( 0.01%)  3,025 ( 0.12%)     0              0            6,050 ( 0.19%)     0            0           /home/ashy5000/dev/cryptocurrency/contracts/target/debug/build/tikv-jemalloc-sys-7365f40ecb99e085/out/build/include/jemalloc/internal/sz.h:core::ub_checks::is_nonoverlapping::runtime
 12,520 ( 0.13%)     0            0           4,695 ( 0.19%)     0              0            4,695 ( 0.15%)     0            0           /home/ashy5000/dev/cryptocurrency/contracts/target/debug/build/tikv-jemalloc-sys-7365f40ecb99e085/out/build/include/jemalloc/internal/tsd.h:core::core_arch::x86::m128iExt::as_i8x16
 12,288 ( 0.13%)    59 ( 0.04%)   2 ( 0.03%)  2,560 ( 0.11%)     0              0            7,168 ( 0.23%)     0            0           /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/alloc/src/slice.rs:<T as alloc::slice::hack::ConvertVec>::to_vec
 12,285 ( 0.13%)    76 ( 0.05%)   2 ( 0.03%)  4,095 ( 0.17%)     0              0            4,680 ( 0.15%)     0            0           /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/core/src/../../stdarch/crates/core_arch/src/x86/sse2.rs:core::core_arch::x86::sse2::_mm_movemask_epi8
 12,035 ( 0.13%)   146 ( 0.10%)   2 ( 0.03%)    415 ( 0.02%)     0              0            7,885 ( 0.25%)     0            0           /home/ashy5000/dev/cryptocurrency/contracts/target/debug/build/tikv-jemalloc-sys-7365f40ecb99e085/out/build/include/jemalloc/internal/sz.h:hashbrown::raw::RawTable<T,A>::find
 12,025 ( 0.13%)   182 ( 0.13%)   2 ( 0.03%)  4,625 ( 0.19%)     0              0            2,775 ( 0.09%)     0            0           /home/ashy5000/dev/cryptocurrency/contracts/target/debug/build/tikv-jemalloc-sys-7365f40ecb99e085/out/build/include/jemalloc/internal/thread_event.h:_rjem_sdallocx
 12,000 ( 0.13%)    20 ( 0.01%)   2 ( 0.03%)  6,000 ( 0.25%)     0              0            6,000 ( 0.19%)     0            0           /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/core/src/result.rs:core::array::<impl core::convert::TryFrom<&[T]> for [T; N]>::try_from
 11,917 ( 0.13%)   794 ( 0.55%)   2 ( 0.03%)      0              0              0              539 ( 0.02%)     0            0           /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/core/src/num/uint_macros.rs:core::ptr::read_volatile::precondition_check
 11,898 ( 0.13%)   108 ( 0.07%)   2 ( 0.03%)  5,774 ( 0.24%)     0              0            3,167 ( 0.10%)     0            0           /home/ashy5000/.cargo/registry/src/index.crates.io-6f17d22bba15001f/smartstring-1.0.1/src/ops.rs:smartstring::ops::Push::cap
 11,605 ( 0.12%)     0            0           4,642 ( 0.19%)     0              0            2,321 ( 0.07%)     0            0           /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/core/src/slice/raw.rs:core::slice::raw::from_raw_parts::precondition_check
 11,522 ( 0.12%)    61 ( 0.04%)   2 ( 0.03%)  3,565 ( 0.15%)     0              0            4,908 ( 0.16%)     0            0           /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/core/src/ops/function.rs:core::ops::function::FnOnce::call_once
 11,478 ( 0.12%)     3 ( 0.00%)   1 ( 0.01%)  2,817 ( 0.12%)     0              0            5,634 ( 0.18%)     0            0           /home/ashy5000/dev/cryptocurrency/contracts/target/debug/build/tikv-jemalloc-sys-7365f40ecb99e085/out/build/include/jemalloc/internal/arena_inlines_b.h:smartstring::ops::Push::cap
 11,459 ( 0.12%)   348 ( 0.24%)  10 ( 0.14%)  4,516 ( 0.19%)     8 ( 0.14%)     0            1,710 ( 0.05%)     0            0           /home/ashy5000/dev/cryptocurrency/contracts/target/debug/build/tikv-jemalloc-sys-7365f40ecb99e085/out/build/include/jemalloc/internal/fb.h:fb_ffs
 11,431 ( 0.12%)   260 ( 0.18%)   3 ( 0.04%)  3,479 ( 0.14%)     0              0            5,964 ( 0.19%)     0            0           /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/core/src/slice/mod.rs:core::slice::<impl [T]>::copy_from_slice
 11,386 ( 0.12%)   142 ( 0.10%)   4 ( 0.06%)  5,712 ( 0.23%)     0              0            3,551 ( 0.11%)     0            0           /rust/deps/hashbrown-0.14.5/src/raw/bitmask.rs:<hashbrown::raw::bitmask::BitMaskIter as core::iter::traits::iterator::Iterator>::next
 11,298 ( 0.12%)   188 ( 0.13%)   2 ( 0.03%)  3,228 ( 0.13%)     0              0            1,614 ( 0.05%)     0            0           /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/core/src/intrinsics.rs:core::intrinsics::copy_nonoverlapping::precondition_check
 11,269 ( 0.12%)    25 ( 0.02%)   1 ( 0.01%)  2,111 ( 0.09%)     0              0            6,809 ( 0.22%)     0            0           /home/ashy5000/dev/cryptocurrency/contracts/target/debug/build/tikv-jemalloc-sys-7365f40ecb99e085/out/build/include/jemalloc/internal/sz.h:<core::iter::adapters::skip::Skip<I> as core::iter::traits::iterator::Iterator>::next
 11,155 ( 0.12%)    23 ( 0.02%)   0           4,462 ( 0.18%)     0              0            6,693 ( 0.21%)     0            0           /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<smartstring::SmartString<smartstring::config::LazyCompact>>
 11,148 ( 0.12%)   386 ( 0.27%)   2 ( 0.03%)      0              0              0            3,716 ( 0.12%)     0            0           /home/ashy5000/.cargo/registry/src/index.crates.io-6f17d22bba15001f/tikv-jemallocator-0.6.0/src/lib.rs:<tikv_jemallocator::Jemalloc as core::alloc::global::GlobalAlloc>::alloc
 10,780 ( 0.11%) 1,334 ( 0.93%)  49 ( 0.69%)  3,410 ( 0.14%)     0              0            2,695 ( 0.09%)     0            0           /home/ashy5000/dev/cryptocurrency/contracts/target/debug/build/tikv-jemalloc-sys-7365f40ecb99e085/out/build/include/jemalloc/internal/rtree.h:_rjem_je_emap_remap
 10,660 ( 0.11%)   117 ( 0.08%)   1 ( 0.01%)  2,013 ( 0.08%)     0              0            2,684 ( 0.09%)     0            0           /home/ashy5000/dev/cryptocurrency/contracts/target/debug/build/tikv-jemalloc-sys-7365f40ecb99e085/out/build/include/jemalloc/internal/sz.h:core::cmp::min_by
 10,648 ( 0.11%)    81 ( 0.06%)   2 ( 0.03%)  2,420 ( 0.10%)     0              0            2,904 ( 0.09%)     0            0           /home/ashy5000/.cargo/registry/src/index.crates.io-6f17d22bba15001f/smartstring-1.0.1/src/marker_byte.rs:<smartstring::inline::InlineString as core::convert::From<&str>>::from
 10,557 ( 0.11%)     6 ( 0.00%)   0           6,333 ( 0.26%)     0              0            6,330 ( 0.20%)     0            0           /home/ashy5000/dev/cryptocurrency/contracts/target/debug/build/tikv-jemalloc-sys-7365f40ecb99e085/out/build/include/jemalloc/internal/sz.h:smartstring::SmartString<Mode>::as_str
 10,530 ( 0.11%)    25 ( 0.02%)   2 ( 0.03%)  3,510 ( 0.14%)     0              0            3,510 ( 0.11%)     0            0           /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/core/src/result.rs:<core::result::Result<T,E> as core::ops::try_trait::Try>::branch
 10,335 ( 0.11%)   260 ( 0.18%)   3 ( 0.04%)  4,590 ( 0.19%)     0              0            3,447 ( 0.11%)     0            0           /home/ashy5000/.cargo/registry/src/index.crates.io-6f17d22bba15001f/smartstring-1.0.1/src/lib.rs:<smartstring::SmartString<Mode> as core::clone::Clone>::clone
 10,219 ( 0.11%)   191 ( 0.13%)   1 ( 0.01%)  1,858 ( 0.08%)     0              0            5,574 ( 0.18%)     0            0           /home/ashy5000/dev/cryptocurrency/contracts/target/debug/build/tikv-jemalloc-sys-7365f40ecb99e085/out/build/include/jemalloc/internal/tcache_inlines.h:<tikv_jemallocator::Jemalloc as core::alloc::global::GlobalAlloc>::dealloc
 10,219 ( 0.11%)     0            0             929 ( 0.04%)     0              0            3,716 ( 0.12%)     0            0           /home/ashy5000/dev/cryptocurrency/contracts/target/debug/build/tikv-jemalloc-sys-7365f40ecb99e085/out/build/include/jemalloc/internal/tsd.h:<tikv_jemallocator::Jemalloc as core::alloc::global::GlobalAlloc>::dealloc
 10,140 ( 0.11%)   608 ( 0.42%)  19 ( 0.27%)  3,380 ( 0.14%)     0              0            3,120 ( 0.10%)     0            0           /home/ashy5000/dev/cryptocurrency/contracts/target/debug/build/tikv-jemalloc-sys-7365f40ecb99e085/out/build/include/jemalloc/internal/rtree.h:emap_rtree_write_acquired
 10,000 ( 0.11%)    32 ( 0.02%)   2 ( 0.03%)  3,000 ( 0.12%)     0              0            3,000 ( 0.10%)     0            0           /home/ashy5000/dev/cryptocurrency/contracts/target/debug/build/tikv-jemalloc-sys-7365f40ecb99e085/out/build/include/jemalloc/internal/jemalloc_internal_inlines_c.h:rustc_hash::hash_bytes
  9,846 ( 0.10%)   205 ( 0.14%)   2 ( 0.03%)  1,982 ( 0.08%)     0              0            2,600 ( 0.08%)     0            0           /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/core/src/ub_checks.rs:core::num::<impl usize>::unchecked_mul::precondition_check
  9,780 ( 0.10%)    57 ( 0.04%)   2 ( 0.03%)  1,956 ( 0.08%)     0              0            3,912 ( 0.12%)     0            0           /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/core/src/alloc/layout.rs:core::alloc::layout::Layout::from_size_align_unchecked
  9,764 ( 0.10%)   153 ( 0.11%)   2 ( 0.03%)  2,924 ( 0.12%)     0              0            3,420 ( 0.11%)     0            0           /home/ashy5000/dev/cryptocurrency/contracts/target/debug/build/tikv-jemalloc-sys-7365f40ecb99e085/out/build/include/jemalloc/internal/sz.h:<smartstring::SmartString<Mode> as core::convert::From<&str>>::from
  9,538 ( 0.10%)   552 ( 0.38%)  17 ( 0.24%)  2,624 ( 0.11%)     0              0            2,994 ( 0.09%)    24 ( 0.45%)  17 ( 0.41%)  /home/ashy5000/dev/cryptocurrency/contracts/target/debug/build/tikv-jemalloc-sys-7365f40ecb99e085/out/build/src/arena.c:_rjem_je_arena_ralloc_no_move

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/ashy5000/dev/cryptocurrency/contracts/target/debug/build/tikv-jemalloc-sys-7365f40ecb99e085/out/build/include/jemalloc/internal/ph.h
--------------------------------------------------------------------------------
Ir             I1mr        ILmr       Dr             D1mr        DLmr       Dw             D1mw         DLmw         

-- line 68 ----------------------------------------
    .           .          .              .           .          .              .            .            .           	 * happened since, and we don't track whether or not those removals are
    .           .          .              .           .          .              .            .            .           	 * from the aux list.
    .           .          .              .           .          .              .            .            .           	 */
    .           .          .              .           .          .              .            .            .           	size_t auxcount;
    .           .          .              .           .          .              .            .            .           };
    .           .          .              .           .          .              .            .            .           
    .           .          .              .           .          .              .            .            .           JEMALLOC_ALWAYS_INLINE phn_link_t *
    .           .          .              .           .          .              .            .            .           phn_link_get(void *phn, size_t offset) {
1,536 ( 0.02%) 37 ( 0.03%) 5 ( 0.07%)   974 ( 0.04%)  0          0              0            0            0           	return (phn_link_t *)(((uintptr_t)phn) + offset);
    .           .          .              .           .          .              .            .            .           }
    .           .          .              .           .          .              .            .            .           
    .           .          .              .           .          .              .            .            .           JEMALLOC_ALWAYS_INLINE void
    .           .          .              .           .          .              .            .            .           phn_link_init(void *phn, size_t offset) {
  350 ( 0.00%) 34 ( 0.02%) 1 ( 0.01%)   140 ( 0.01%)  0          0            210 ( 0.01%)   3 ( 0.06%)   3 ( 0.07%)  	phn_link_get(phn, offset)->prev = NULL;
  350 ( 0.00%) 35 ( 0.02%) 1 ( 0.01%)   140 ( 0.01%)  0          0            210 ( 0.01%)   4 ( 0.08%)   4 ( 0.10%)  	phn_link_get(phn, offset)->next = NULL;
   70 ( 0.00%)  0          0              0           0          0             70 ( 0.00%)   0            0           	phn_link_get(phn, offset)->lchild = NULL;
   70 ( 0.00%)  0          0              0           0          0              0            0            0           }
    .           .          .              .           .          .              .            .            .           
    .           .          .              .           .          .              .            .            .           /* Internal utility helpers. */
    .           .          .              .           .          .              .            .            .           JEMALLOC_ALWAYS_INLINE void *
    .           .          .              .           .          .              .            .            .           phn_lchild_get(void *phn, size_t offset) {
   68 ( 0.00%)  0          0             68 ( 0.00%)  0          0              0            0            0           	return phn_link_get(phn, offset)->lchild;
    .           .          .              .           .          .              .            .            .           }
    .           .          .              .           .          .              .            .            .           
    .           .          .              .           .          .              .            .            .           JEMALLOC_ALWAYS_INLINE void
    .           .          .              .           .          .              .            .            .           phn_lchild_set(void *phn, void *lchild, size_t offset) {
   68 ( 0.00%)  0          0             34 ( 0.00%)  0          0             34 ( 0.00%)   0            0           	phn_link_get(phn, offset)->lchild = lchild;
   34 ( 0.00%)  0          0              0           0          0              0            0            0           }
    .           .          .              .           .          .              .            .            .           
    .           .          .              .           .          .              .            .            .           JEMALLOC_ALWAYS_INLINE void *
    .           .          .              .           .          .              .            .            .           phn_next_get(void *phn, size_t offset) {
  143 ( 0.00%)  2 ( 0.00%) 2 ( 0.03%)   138 ( 0.01%) 18 ( 0.31%) 0              5 ( 0.00%)   1 ( 0.02%)   1 ( 0.02%)  	return phn_link_get(phn, offset)->next;
    .           .          .              .           .          .              .            .            .           }
    .           .          .              .           .          .              .            .            .           
    .           .          .              .           .          .              .            .            .           JEMALLOC_ALWAYS_INLINE void
    .           .          .              .           .          .              .            .            .           phn_next_set(void *phn, void *next, size_t offset) {
    8 ( 0.00%)  1 ( 0.00%) 1 ( 0.01%)     4 ( 0.00%)  0          0              4 ( 0.00%)   0            0           	phn_link_get(phn, offset)->next = next;
   13 ( 0.00%)  1 ( 0.00%) 1 ( 0.01%)     4 ( 0.00%)  0          0              5 ( 0.00%)   1 ( 0.02%)   1 ( 0.02%)  }
    .           .          .              .           .          .              .            .            .           
    .           .          .              .           .          .              .            .            .           JEMALLOC_ALWAYS_INLINE void *
    .           .          .              .           .          .              .            .            .           phn_prev_get(void *phn, size_t offset) {
    .           .          .              .           .          .              .            .            .           	return phn_link_get(phn, offset)->prev;
    .           .          .              .           .          .              .            .            .           }
    .           .          .              .           .          .              .            .            .           
    .           .          .              .           .          .              .            .            .           JEMALLOC_ALWAYS_INLINE void
    .           .          .              .           .          .              .            .            .           phn_prev_set(void *phn, void *prev, size_t offset) {
   74 ( 0.00%)  0          0             37 ( 0.00%)  0          0             37 ( 0.00%)   0            0           	phn_link_get(phn, offset)->prev = prev;
   61 ( 0.00%)  4 ( 0.00%) 4 ( 0.06%)    12 ( 0.00%)  0          0             12 ( 0.00%)   2 ( 0.04%)   2 ( 0.05%)  }
    .           .          .              .           .          .              .            .            .           
    .           .          .              .           .          .              .            .            .           JEMALLOC_ALWAYS_INLINE void
    .           .          .              .           .          .              .            .            .           phn_merge_ordered(void *phn0, void *phn1, size_t offset,
    .           .          .              .           .          .              .            .            .               ph_cmp_t cmp) {
    .           .          .              .           .          .              .            .            .           	void *phn0child;
    .           .          .              .           .          .              .            .            .           
    4 ( 0.00%)  0          0              0           0          0              0            0            0           	assert(phn0 != NULL);
    4 ( 0.00%)  2 ( 0.00%) 2 ( 0.03%)     0           0          0              0            0            0           	assert(phn1 != NULL);
   14 ( 0.00%)  3 ( 0.00%) 3 ( 0.04%)     5 ( 0.00%)  0          0              5 ( 0.00%)   0            0           	assert(cmp(phn0, phn1) <= 0);
    .           .          .              .           .          .              .            .            .           
    .           .          .              .           .          .              .            .            .           	phn_prev_set(phn1, phn0, offset);
   11 ( 0.00%)  1 ( 0.00%) 1 ( 0.01%)     5 ( 0.00%)  0          0              6 ( 0.00%)   1 ( 0.02%)   1 ( 0.02%)  	phn0child = phn_lchild_get(phn0, offset);
    .           .          .              .           .          .              .            .            .           	phn_next_set(phn1, phn0child, offset);
    2 ( 0.00%)  0          0              1 ( 0.00%)  0          0              0            0            0           	if (phn0child != NULL) {
    .           .          .              .           .          .              .            .            .           		phn_prev_set(phn0child, phn1, offset);
    .           .          .              .           .          .              .            .            .           	}
    .           .          .              .           .          .              .            .            .           	phn_lchild_set(phn0, phn1, offset);
    1 ( 0.00%)  0          0              0           0          0              0            0            0           }
    .           .          .              .           .          .              .            .            .           
    .           .          .              .           .          .              .            .            .           JEMALLOC_ALWAYS_INLINE void *
    .           .          .              .           .          .              .            .            .           phn_merge(void *phn0, void *phn1, size_t offset, ph_cmp_t cmp) {
    .           .          .              .           .          .              .            .            .           	void *result;
    2 ( 0.00%)  0          0              1 ( 0.00%)  0          0              0            0            0           	if (phn0 == NULL) {
    .           .          .              .           .          .              .            .            .           		result = phn1;
    2 ( 0.00%)  0          0              1 ( 0.00%)  0          0              0            0            0           	} else if (phn1 == NULL) {
    .           .          .              .           .          .              .            .            .           		result = phn0;
   16 ( 0.00%)  2 ( 0.00%) 2 ( 0.03%)     7 ( 0.00%)  0          0              5 ( 0.00%)   1 ( 0.02%)   1 ( 0.02%)  	} else if (cmp(phn0, phn1) < 0) {
    .           .          .              .           .          .              .            .            .           		phn_merge_ordered(phn0, phn1, offset, cmp);
    3 ( 0.00%)  0          0              1 ( 0.00%)  0          0              1 ( 0.00%)   0            0           		result = phn0;
    .           .          .              .           .          .              .            .            .           	} else {
    .           .          .              .           .          .              .            .            .           		phn_merge_ordered(phn1, phn0, offset, cmp);
    .           .          .              .           .          .              .            .            .           		result = phn1;
    .           .          .              .           .          .              .            .            .           	}
    1 ( 0.00%)  0          0              1 ( 0.00%)  0          0              0            0            0           	return result;
    .           .          .              .           .          .              .            .            .           }
    .           .          .              .           .          .              .            .            .           
    .           .          .              .           .          .              .            .            .           JEMALLOC_ALWAYS_INLINE void *
    .           .          .              .           .          .              .            .            .           phn_merge_siblings(void *phn, size_t offset, ph_cmp_t cmp) {
   34 ( 0.00%)  0          0              0           0          0             34 ( 0.00%)   0            0           	void *head = NULL;
   34 ( 0.00%) 32 ( 0.02%) 1 ( 0.01%)     0           0          0             34 ( 0.00%)   2 ( 0.04%)   1 ( 0.02%)  	void *tail = NULL;
  340 ( 0.00%) 33 ( 0.02%) 2 ( 0.03%)   170 ( 0.01%)  0          0            170 ( 0.01%)   2 ( 0.04%)   2 ( 0.05%)  	void *phn0 = phn;
   34 ( 0.00%)  0          0              0           0          0             34 ( 0.00%)   0            0           	void *phn1 = phn_next_get(phn0, offset);
    .           .          .              .           .          .              .            .            .           
    .           .          .              .           .          .              .            .            .           	/*
    .           .          .              .           .          .              .            .            .           	 * Multipass merge, wherein the first two elements of a FIFO
    .           .          .              .           .          .              .            .            .           	 * are repeatedly merged, and each result is appended to the
    .           .          .              .           .          .              .            .            .           	 * singly linked FIFO, until the FIFO contains only a single
    .           .          .              .           .          .              .            .            .           	 * element.  We start with a sibling list but no reference to
    .           .          .              .           .          .              .            .            .           	 * its tail, so we do a single pass over the sibling list to
    .           .          .              .           .          .              .            .            .           	 * populate the FIFO.
    .           .          .              .           .          .              .            .            .           	 */
   68 ( 0.00%)  0          0             34 ( 0.00%)  0          0              0            0            0           	if (phn1 != NULL) {
    .           .          .              .           .          .              .            .            .           		void *phnrest = phn_next_get(phn1, offset);
    .           .          .              .           .          .              .            .            .           		if (phnrest != NULL) {
    .           .          .              .           .          .              .            .            .           			phn_prev_set(phnrest, NULL, offset);
    .           .          .              .           .          .              .            .            .           		}
    .           .          .              .           .          .              .            .            .           		phn_prev_set(phn0, NULL, offset);
    .           .          .              .           .          .              .            .            .           		phn_next_set(phn0, NULL, offset);
    .           .          .              .           .          .              .            .            .           		phn_prev_set(phn1, NULL, offset);
    .           .          .              .           .          .              .            .            .           		phn_next_set(phn1, NULL, offset);
-- line 175 ----------------------------------------
-- line 212 ----------------------------------------
    .           .          .              .           .          .              .            .            .           				}
    .           .          .              .           .          .              .            .            .           				phn_next_set(tail, phn0, offset);
    .           .          .              .           .          .              .            .            .           				tail = phn0;
    .           .          .              .           .          .              .            .            .           				phn0 = head;
    .           .          .              .           .          .              .            .            .           				phn1 = phn_next_get(phn0, offset);
    .           .          .              .           .          .              .            .            .           			}
    .           .          .              .           .          .              .            .            .           		}
    .           .          .              .           .          .              .            .            .           	}
   34 ( 0.00%) 34 ( 0.02%) 1 ( 0.01%)    34 ( 0.00%)  0          0              0            0            0           	return phn0;
    .           .          .              .           .          .              .            .            .           }
    .           .          .              .           .          .              .            .            .           
    .           .          .              .           .          .              .            .            .           JEMALLOC_ALWAYS_INLINE void
    .           .          .              .           .          .              .            .            .           ph_merge_aux(ph_t *ph, size_t offset, ph_cmp_t cmp) {
  134 ( 0.00%)  0          0             67 ( 0.00%)  0          0             67 ( 0.00%)   0            0           	ph->auxcount = 0;
  670 ( 0.01%) 97 ( 0.07%) 3 ( 0.04%)   335 ( 0.01%)  0          0            335 ( 0.01%)   6 ( 0.11%)   5 ( 0.12%)  	void *phn = phn_next_get(ph->root, offset);
  134 ( 0.00%)  0          0             67 ( 0.00%)  0          0              0            0            0           	if (phn != NULL) {
   10 ( 0.00%)  2 ( 0.00%) 2 ( 0.03%)     5 ( 0.00%)  0          0              5 ( 0.00%)   0            0           		phn_prev_set(ph->root, NULL, offset);
   10 ( 0.00%)  1 ( 0.00%) 1 ( 0.01%)     5 ( 0.00%)  0          0              5 ( 0.00%)   1 ( 0.02%)   1 ( 0.02%)  		phn_next_set(ph->root, NULL, offset);
    .           .          .              .           .          .              .            .            .           		phn_prev_set(phn, NULL, offset);
    1 ( 0.00%)  0          0              0           0          0              1 ( 0.00%)   0            0           		phn = phn_merge_siblings(phn, offset, cmp);
    4 ( 0.00%)  1 ( 0.00%) 1 ( 0.01%)     0           0          0              0            0            0           		assert(phn_next_get(phn, offset) == NULL);
   11 ( 0.00%)  2 ( 0.00%) 2 ( 0.03%)     6 ( 0.00%)  0          0              5 ( 0.00%)   0            0           		ph->root = phn_merge(ph->root, phn, offset, cmp);
    .           .          .              .           .          .              .            .            .           	}
   67 ( 0.00%) 54 ( 0.04%) 1 ( 0.01%)     0           0          0              0            0            0           }
    .           .          .              .           .          .              .            .            .           
    .           .          .              .           .          .              .            .            .           JEMALLOC_ALWAYS_INLINE void *
    .           .          .              .           .          .              .            .            .           ph_merge_children(void *phn, size_t offset, ph_cmp_t cmp) {
    .           .          .              .           .          .              .            .            .           	void *result;
   36 ( 0.00%)  0          0              0           0          0             36 ( 0.00%)   5 ( 0.09%)   3 ( 0.07%)  	void *lchild = phn_lchild_get(phn, offset);
   72 ( 0.00%)  0          0             36 ( 0.00%)  0          0              0            0            0           	if (lchild == NULL) {
  204 ( 0.00%) 34 ( 0.02%) 1 ( 0.01%)    99 ( 0.00%)  0          0            102 ( 0.00%)   3 ( 0.06%)   3 ( 0.07%)  		result = NULL;
    .           .          .              .           .          .              .            .            .           	} else {
   33 ( 0.00%)  0          0              0           0          0             33 ( 0.00%)   0            0           		result = phn_merge_siblings(lchild, offset, cmp);
    .           .          .              .           .          .              .            .            .           	}
   36 ( 0.00%)  2 ( 0.00%) 1 ( 0.01%)    36 ( 0.00%)  0          0              0            0            0           	return result;
    .           .          .              .           .          .              .            .            .           }
    .           .          .              .           .          .              .            .            .           
    .           .          .              .           .          .              .            .            .           JEMALLOC_ALWAYS_INLINE void
    .           .          .              .           .          .              .            .            .           ph_new(ph_t *ph) {
2,938 ( 0.03%)  0          0          1,469 ( 0.06%)  0          0          1,469 ( 0.05%) 401 ( 7.54%) 401 ( 9.57%)  	ph->root = NULL;
2,938 ( 0.03%)  1 ( 0.00%) 1 ( 0.01%) 1,469 ( 0.06%)  0          0          1,469 ( 0.05%) 256 ( 4.81%) 256 ( 6.11%)  	ph->auxcount = 0;
1,469 ( 0.02%)  0          0              0           0          0              0            0            0           }
    .           .          .              .           .          .              .            .            .           
    .           .          .              .           .          .              .            .            .           JEMALLOC_ALWAYS_INLINE bool
    .           .          .              .           .          .              .            .            .           ph_empty(ph_t *ph) {
  252 ( 0.00%)  0          0            126 ( 0.01%)  1 ( 0.02%) 0              0            0            0           	return ph->root == NULL;
    .           .          .              .           .          .              .            .            .           }
    .           .          .              .           .          .              .            .            .           
    .           .          .              .           .          .              .            .            .           JEMALLOC_ALWAYS_INLINE void *
    .           .          .              .           .          .              .            .            .           ph_first(ph_t *ph, size_t offset, ph_cmp_t cmp) {
  256 ( 0.00%)  0          0            128 ( 0.01%)  3 ( 0.05%) 0              0            0            0           	if (ph->root == NULL) {
  252 ( 0.00%) 31 ( 0.02%) 1 ( 0.01%)    93 ( 0.00%)  0          0             93 ( 0.00%)   5 ( 0.09%)   4 ( 0.10%)  		return NULL;
    .           .          .              .           .          .              .            .            .           	}
    .           .          .              .           .          .              .            .            .           	ph_merge_aux(ph, offset, cmp);
   62 ( 0.00%)  0          0             62 ( 0.00%)  0          0              0            0            0           	return ph->root;
    .           .          .              .           .          .              .            .            .           }
    .           .          .              .           .          .              .            .            .           
    .           .          .              .           .          .              .            .            .           JEMALLOC_ALWAYS_INLINE void *
    .           .          .              .           .          .              .            .            .           ph_any(ph_t *ph, size_t offset) {
    .           .          .              .           .          .              .            .            .           	if (ph->root == NULL) {
    .           .          .              .           .          .              .            .            .           		return NULL;
    .           .          .              .           .          .              .            .            .           	}
    .           .          .              .           .          .              .            .            .           	void *aux = phn_next_get(ph->root, offset);
-- line 274 ----------------------------------------
-- line 311 ----------------------------------------
    .           .          .              .           .          .              .            .            .           
    .           .          .              .           .          .              .            .            .           	/*
    .           .          .              .           .          .              .            .            .           	 * Treat the root as an aux list during insertion, and lazily merge
    .           .          .              .           .          .              .            .            .           	 * during a_prefix##remove_first().  For elements that are inserted,
    .           .          .              .           .          .              .            .            .           	 * then removed via a_prefix##remove() before the aux list is ever
    .           .          .              .           .          .              .            .            .           	 * processed, this makes insert/remove constant-time, whereas eager
    .           .          .              .           .          .              .            .            .           	 * merging would make insert O(log n).
    .           .          .              .           .          .              .            .            .           	 */
  280 ( 0.00%)  0          0            140 ( 0.01%)  0          0              0            0            0           	if (ph->root == NULL) {
  144 ( 0.00%)  2 ( 0.00%) 1 ( 0.01%)    72 ( 0.00%)  0          0             36 ( 0.00%)   0            0           		ph->root = phn;
    .           .          .              .           .          .              .            .            .           	} else {
    .           .          .              .           .          .              .            .            .           		/*
    .           .          .              .           .          .              .            .            .           		 * As a special case, check to see if we can replace the root.
    .           .          .              .           .          .              .            .            .           		 * This is practically common in some important cases, and lets
    .           .          .              .           .          .              .            .            .           		 * us defer some insertions (hopefully, until the point where
    .           .          .              .           .          .              .            .            .           		 * some of the items in the aux list have been removed, savings
    .           .          .              .           .          .              .            .            .           		 * us from linking them at all).
    .           .          .              .           .          .              .            .            .           		 */
  306 ( 0.00%) 32 ( 0.02%) 0            136 ( 0.01%)  0          0             34 ( 0.00%)   1 ( 0.02%)   1 ( 0.02%)  		if (cmp(phn, ph->root) < 0) {
  363 ( 0.00%) 33 ( 0.02%) 1 ( 0.01%)   198 ( 0.01%)  0          0            165 ( 0.01%)   5 ( 0.09%)   2 ( 0.05%)  			phn_lchild_set(phn, ph->root, offset);
  363 ( 0.00%) 33 ( 0.02%) 1 ( 0.01%)   198 ( 0.01%)  0          0            165 ( 0.01%)   3 ( 0.06%)   2 ( 0.05%)  			phn_prev_set(ph->root, phn, offset);
   99 ( 0.00%) 32 ( 0.02%) 0             66 ( 0.00%)  0          0             33 ( 0.00%)   0            0           			ph->root = phn;
   66 ( 0.00%)  0          0             33 ( 0.00%)  0          0             33 ( 0.00%)   0            0           			ph->auxcount = 0;
   33 ( 0.00%)  0          0              0           0          0              0            0            0           			return;
    .           .          .              .           .          .              .            .            .           		}
    5 ( 0.00%)  1 ( 0.00%) 1 ( 0.01%)     3 ( 0.00%)  0          0              1 ( 0.00%)   0            0           		ph->auxcount++;
    9 ( 0.00%)  1 ( 0.00%) 1 ( 0.01%)     5 ( 0.00%)  0          0              4 ( 0.00%)   1 ( 0.02%)   1 ( 0.02%)  		phn_next_set(phn, phn_next_get(ph->root, offset), offset);
   11 ( 0.00%)  2 ( 0.00%) 2 ( 0.03%)     5 ( 0.00%)  0          0              4 ( 0.00%)   0            0           		if (phn_next_get(ph->root, offset) != NULL) {
    .           .          .              .           .          .              .            .            .           			phn_prev_set(phn_next_get(ph->root, offset), phn,
    .           .          .              .           .          .              .            .            .           			    offset);
    .           .          .              .           .          .              .            .            .           		}
   11 ( 0.00%)  2 ( 0.00%) 2 ( 0.03%)     6 ( 0.00%)  0          0              5 ( 0.00%)   2 ( 0.04%)   0           		phn_prev_set(phn, ph->root, offset);
   11 ( 0.00%)  1 ( 0.00%) 1 ( 0.01%)     6 ( 0.00%)  0          0              5 ( 0.00%)   0            0           		phn_next_set(ph->root, phn, offset);
    .           .          .              .           .          .              .            .            .           	}
  148 ( 0.00%) 33 ( 0.02%) 1 ( 0.01%)    74 ( 0.00%)  0          0              0            0            0           	if (ph->auxcount > 1) {
    .           .          .              .           .          .              .            .            .           		unsigned nmerges = ffs_zu(ph->auxcount - 1);
    .           .          .              .           .          .              .            .            .           		bool done = false;
    .           .          .              .           .          .              .            .            .           		for (unsigned i = 0; i < nmerges && !done; i++) {
    .           .          .              .           .          .              .            .            .           			done = ph_try_aux_merge_pair(ph, offset, cmp);
    .           .          .              .           .          .              .            .            .           		}
    .           .          .              .           .          .              .            .            .           	}
    .           .          .              .           .          .              .            .            .           }
    .           .          .              .           .          .              .            .            .           
    .           .          .              .           .          .              .            .            .           JEMALLOC_ALWAYS_INLINE void *
    .           .          .              .           .          .              .            .            .           ph_remove_first(ph_t *ph, size_t offset, ph_cmp_t cmp) {
    .           .          .              .           .          .              .            .            .           	void *ret;
    .           .          .              .           .          .              .            .            .           
8,248 ( 0.09%)  0          0          4,124 ( 0.17%) 87 ( 1.51%) 0              0            0            0           	if (ph->root == NULL) {
4,268 ( 0.04%) 35 ( 0.02%) 1 ( 0.01%)   108 ( 0.00%)  0          0            108 ( 0.00%)   5 ( 0.09%)   5 ( 0.12%)  		return NULL;
    .           .          .              .           .          .              .            .            .           	}
    .           .          .              .           .          .              .            .            .           	ph_merge_aux(ph, offset, cmp);
  108 ( 0.00%)  0          0             72 ( 0.00%)  0          0             36 ( 0.00%)  17 ( 0.32%)  11 ( 0.26%)  	ret = ph->root;
  612 ( 0.01%) 68 ( 0.05%) 2 ( 0.03%)   324 ( 0.01%)  0          0            288 ( 0.01%)   6 ( 0.11%)   6 ( 0.14%)  	ph->root = ph_merge_children(ph->root, offset, cmp);
    .           .          .              .           .          .              .            .            .           
   36 ( 0.00%)  0          0             36 ( 0.00%)  0          0              0            0            0           	return ret;
    .           .          .              .           .          .              .            .            .           
    .           .          .              .           .          .              .            .            .           }
    .           .          .              .           .          .              .            .            .           
    .           .          .              .           .          .              .            .            .           JEMALLOC_ALWAYS_INLINE void
    .           .          .              .           .          .              .            .            .           ph_remove(ph_t *ph, void *phn, size_t offset, ph_cmp_t cmp) {
    .           .          .              .           .          .              .            .            .           	void *replace;
    .           .          .              .           .          .              .            .            .           	void *parent;
    .           .          .              .           .          .              .            .            .           
  372 ( 0.00%) 62 ( 0.04%) 2 ( 0.03%)   217 ( 0.01%)  0          0            124 ( 0.00%)   3 ( 0.06%)   3 ( 0.07%)  	if (ph->root == phn) {
    .           .          .              .           .          .              .            .            .           		/*
    .           .          .              .           .          .              .            .            .           		 * We can delete from aux list without merging it, but we need
    .           .          .              .           .          .              .            .            .           		 * to merge if we are dealing with the root node and it has
    .           .          .              .           .          .              .            .            .           		 * children.
    .           .          .              .           .          .              .            .            .           		 */
  310 ( 0.00%) 31 ( 0.02%) 1 ( 0.01%)   124 ( 0.01%)  0          0            124 ( 0.00%)   5 ( 0.09%)   5 ( 0.12%)  		if (phn_lchild_get(phn, offset) == NULL) {
   62 ( 0.00%)  0          0             31 ( 0.00%)  0          0             31 ( 0.00%)   0            0           			ph->root = phn_next_get(phn, offset);
  124 ( 0.00%) 31 ( 0.02%) 1 ( 0.01%)    62 ( 0.00%)  0          0              0            0            0           			if (ph->root != NULL) {
    .           .          .              .           .          .              .            .            .           				phn_prev_set(ph->root, NULL, offset);
    .           .          .              .           .          .              .            .            .           			}
   31 ( 0.00%) 31 ( 0.02%) 1 ( 0.01%)     0           0          0              0            0            0           			return;
    .           .          .              .           .          .              .            .            .           		}
    .           .          .              .           .          .              .            .            .           		ph_merge_aux(ph, offset, cmp);
    .           .          .              .           .          .              .            .            .           		if (ph->root == phn) {
    .           .          .              .           .          .              .            .            .           			ph->root = ph_merge_children(ph->root, offset, cmp);
    .           .          .              .           .          .              .            .            .           			return;
    .           .          .              .           .          .              .            .            .           		}
    .           .          .              .           .          .              .            .            .           	}
    .           .          .              .           .          .              .            .            .           
-- line 393 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/ashy5000/.cargo/registry/src/index.crates.io-6f17d22bba15001f/hex-0.4.3/src/lib.rs
--------------------------------------------------------------------------------
Ir             I1mr         ILmr        Dr             D1mr       DLmr       Dw             D1mw       DLmw       

-- line 167 ----------------------------------------
    .            .           .              .          .          .              .          .          .               /// Creates an instance of type `Self` from the given hex string, or fails
    .            .           .              .          .          .              .          .          .               /// with a custom error type.
    .            .           .              .          .          .              .          .          .               ///
    .            .           .              .          .          .              .          .          .               /// Both, upper and lower case characters are valid and can even be
    .            .           .              .          .          .              .          .          .               /// mixed (e.g. `f9b4ca`, `F9B4CA` and `f9B4Ca` are all valid strings).
    .            .           .              .          .          .              .          .          .               fn from_hex<T: AsRef<[u8]>>(hex: T) -> Result<Self, Self::Error>;
    .            .           .              .          .          .              .          .          .           }
    .            .           .              .          .          .              .          .          .           
3,120 ( 0.03%)  24 ( 0.02%)  1 ( 0.01%)     0          0          0          2,340 ( 0.07%) 0          0           fn val(c: u8, idx: usize) -> Result<u8, FromHexError> {
    .            .           .              .          .          .              .          .          .               match c {
1,255 ( 0.01%)   0           0              0          0          0             12 ( 0.00%) 0          0                   b'A'..=b'F' => Ok(c - b'A' + 10),
1,820 ( 0.02%)  35 ( 0.02%)  3 ( 0.04%)     0          0          0             68 ( 0.00%) 0          0                   b'a'..=b'f' => Ok(c - b'a' + 10),
5,180 ( 0.05%)   0           0              0          0          0          1,110 ( 0.04%) 0          0                   b'0'..=b'9' => Ok(c - b'0'),
    .            .           .              .          .          .              .          .          .                   _ => Err(FromHexError::InvalidHexCharacter {
    .            .           .              .          .          .              .          .          .                       c: c as char,
    .            .           .              .          .          .              .          .          .                       index: idx,
    .            .           .              .          .          .              .          .          .                   }),
    .            .           .              .          .          .              .          .          .               }
  780 ( 0.01%)   0           0            390 ( 0.02%) 0          0              0          0          0           }
    .            .           .              .          .          .              .          .          .           
    .            .           .              .          .          .              .          .          .           #[cfg(feature = "alloc")]
    .            .           .              .          .          .              .          .          .           impl FromHex for Vec<u8> {
    .            .           .              .          .          .              .          .          .               type Error = FromHexError;
    .            .           .              .          .          .              .          .          .           
   19 ( 0.00%)  19 ( 0.01%)  1 ( 0.01%)     0          0          0              0          0          0               fn from_hex<T: AsRef<[u8]>>(hex: T) -> Result<Self, Self::Error> {
   38 ( 0.00%)   0           0              0          0          0             38 ( 0.00%) 0          0                   let hex = hex.as_ref();
    .            .           .              .          .          .              .          .          .                   if hex.len() % 2 != 0 {
    .            .           .              .          .          .              .          .          .                       return Err(FromHexError::OddLength);
    .            .           .              .          .          .              .          .          .                   }
    .            .           .              .          .          .              .          .          .           
  114 ( 0.00%)   3 ( 0.00%)  0              0          0          0             57 ( 0.00%) 0          0                   hex.chunks(2)
    .            .           .              .          .          .              .          .          .                       .enumerate()
6,240 ( 0.07%)  26 ( 0.02%)  2 ( 0.03%)   975 ( 0.04%) 0          0          1,365 ( 0.04%) 0          0                       .map(|(i, pair)| Ok(val(pair[0], 2 * i)? << 4 | val(pair[1], 2 * i + 1)?))
    .            .           .              .          .          .              .          .          .                       .collect()
   57 ( 0.00%)   0           0             19 ( 0.00%) 0          0             19 ( 0.00%) 0          0               }
    .            .           .              .          .          .              .          .          .           }
    .            .           .              .          .          .              .          .          .           
    .            .           .              .          .          .              .          .          .           // Helper macro to implement the trait for a few fixed sized arrays. Once Rust
    .            .           .              .          .          .              .          .          .           // has type level integers, this should be removed.
    .            .           .              .          .          .              .          .          .           macro_rules! from_hex_array_impl {
    .            .           .              .          .          .              .          .          .               ($($len:expr)+) => {$(
    .            .           .              .          .          .              .          .          .                   impl FromHex for [u8; $len] {
    .            .           .              .          .          .              .          .          .                       type Error = FromHexError;
-- line 209 ----------------------------------------
-- line 288 ----------------------------------------
    .            .           .              .          .          .              .          .          .           ///     hex::decode("48656c6c6f20776f726c6421"),
    .            .           .              .          .          .              .          .          .           ///     Ok("Hello world!".to_owned().into_bytes())
    .            .           .              .          .          .              .          .          .           /// );
    .            .           .              .          .          .              .          .          .           ///
    .            .           .              .          .          .              .          .          .           /// assert_eq!(hex::decode("123"), Err(hex::FromHexError::OddLength));
    .            .           .              .          .          .              .          .          .           /// assert!(hex::decode("foo").is_err());
    .            .           .              .          .          .              .          .          .           /// ```
    .            .           .              .          .          .              .          .          .           #[cfg(feature = "alloc")]
   57 ( 0.00%)  14 ( 0.01%)  1 ( 0.01%)     0          0          0             38 ( 0.00%) 0          0           pub fn decode<T: AsRef<[u8]>>(data: T) -> Result<Vec<u8>, FromHexError> {
   19 ( 0.00%)   0           0              0          0          0             19 ( 0.00%) 0          0               FromHex::from_hex(data)
    .            .           .              .          .          .              .          .          .           }
    .            .           .              .          .          .              .          .          .           
    .            .           .              .          .          .              .          .          .           /// Decode a hex string into a mutable bytes slice.
    .            .           .              .          .          .              .          .          .           ///
    .            .           .              .          .          .              .          .          .           /// Both, upper and lower case characters are valid in the input string and can
    .            .           .              .          .          .              .          .          .           /// even be mixed (e.g. `f9b4ca`, `F9B4CA` and `f9B4Ca` are all valid strings).
    .            .           .              .          .          .              .          .          .           ///
    .            .           .              .          .          .              .          .          .           /// # Example
-- line 305 ----------------------------------------

5,450 ( 0.06%) 145 ( 0.10%) 11 ( 0.15%) 5,198 ( 0.21%) 0          0            195 ( 0.01%) 0          0           <counts for unidentified lines in /home/ashy5000/.cargo/registry/src/index.crates.io-6f17d22bba15001f/hex-0.4.3/src/lib.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/ashy5000/dev/cryptocurrency/contracts/src/vm.rs
--------------------------------------------------------------------------------
Ir              I1mr           ILmr         Dr             D1mr       DLmr       Dw           D1mw        DLmw       

-- line 20 ----------------------------------------
     .              .            .              .          .          .            .           .          .           const VM_NIL: *const c_void = 0x0000 as *const c_void;
     .              .            .              .          .          .            .           .          .           
     .              .            .              .          .          .            .           .          .           #[inline(always)]
     .              .            .              .          .          .            .           .          .           pub fn vm_access_buffer_contents(
     .              .            .              .          .          .            .           .          .               buffers: &mut FxHashMap<String, Buffer>,
     .              .            .              .          .          .            .           .          .               loc: String,
     .              .            .              .          .          .            .           .          .               err_loc: String,
     .              .            .              .          .          .            .           .          .           ) -> Vec<u8> {
   200 ( 0.00%)    20 ( 0.01%)   3 ( 0.04%)     0          0          0           75 ( 0.00%)  0          0               if !vm_check_buffer_initialization(buffers, loc.to_owned()) {
     .              .            .              .          .          .            .           .          .                   vm_throw_local_error(buffers, err_loc);
     .              .            .              .          .          .            .           .          .                   return vec![];
     .              .            .              .          .          .            .           .          .               }
   400 ( 0.00%)     6 ( 0.00%)   4 ( 0.06%)    50 ( 0.00%) 0          0          125 ( 0.00%)  2 ( 0.04%) 0               if let Some(x) = buffers.get(&(loc.to_owned())) {
    50 ( 0.00%)    23 ( 0.02%)   2 ( 0.03%)     0          0          0           25 ( 0.00%)  0          0                   return x.contents.clone();
    50 ( 0.00%)     0            0              0          0          0           25 ( 0.00%)  0          0               }
     .              .            .              .          .          .            .           .          .               vec![]
   200 ( 0.00%)    27 ( 0.02%)   5 ( 0.07%)    25 ( 0.00%) 0          0           50 ( 0.00%)  0          0           }
     .              .            .              .          .          .            .           .          .           
     .              .            .              .          .          .            .           .          .           #[inline(always)]
     .              .            .              .          .          .            .           .          .           pub fn vm_access_buffer(
     .              .            .              .          .          .            .           .          .               buffers: &mut FxHashMap<String, Buffer>,
     .              .            .              .          .          .            .           .          .               loc: String,
     .              .            .              .          .          .            .           .          .               err_loc: String,
     .              .            .              .          .          .            .           .          .           ) -> *mut Buffer {
   224 ( 0.00%)    15 ( 0.01%)   2 ( 0.03%)     0          0          0           84 ( 0.00%)  0          0               if !vm_check_buffer_initialization(buffers, loc.to_owned()) {
     .              .            .              .          .          .            .           .          .                   vm_throw_local_error(buffers, err_loc);
     .              .            .              .          .          .            .           .          .                   return VM_NIL as *mut Buffer;
     .              .            .              .          .          .            .           .          .               }
   420 ( 0.00%)    34 ( 0.02%)   3 ( 0.04%)    56 ( 0.00%) 0          0          140 ( 0.00%)  2 ( 0.04%) 1 ( 0.02%)      if let Some(x) = buffers.get_mut(&(loc.to_owned())) {
    56 ( 0.00%)     2 ( 0.00%)   1 ( 0.01%)     0          0          0           28 ( 0.00%)  0          0                   return x;
    56 ( 0.00%)    17 ( 0.01%)   1 ( 0.01%)     0          0          0           28 ( 0.00%)  0          0               }
     .              .            .              .          .          .            .           .          .               VM_NIL as *mut Buffer
   252 ( 0.00%)    32 ( 0.02%)   5 ( 0.07%)    56 ( 0.00%) 0          0           84 ( 0.00%)  0          0           }
     .              .            .              .          .          .            .           .          .           
     .              .            .              .          .          .            .           .          .           #[inline(always)]
     .              .            .              .          .          .            .           .          .           pub fn vm_check_buffer_initialization(buffers: &mut FxHashMap<String, Buffer>, loc: String) -> bool {
 1,145 ( 0.01%)    90 ( 0.06%)  24 ( 0.34%)     0          0          0          687 ( 0.02%)  8 ( 0.15%) 0               buffers.contains_key(&(loc.clone()))
 1,145 ( 0.01%)   197 ( 0.14%)  37 ( 0.52%)     0          0          0          458 ( 0.01%)  0          0           }
     .              .            .              .          .          .            .           .          .           
     .              .            .              .          .          .            .           .          .           #[inline(always)]
     .              .            .              .          .          .            .           .          .           pub fn vm_throw_global_error(buffers: &mut FxHashMap<String, Buffer>) {
    66 ( 0.00%)     2 ( 0.00%)   1 ( 0.01%)     6 ( 0.00%) 0          0           18 ( 0.00%)  3 ( 0.06%) 0               if let Some(x) = buffers.get_mut::<String>(&("00000000".into())) {
    63 ( 0.00%)     2 ( 0.00%)   1 ( 0.01%)    15 ( 0.00%) 0          0           30 ( 0.00%)  0          0                   *x = Buffer { contents: vec![1] };
     .              .            .              .          .          .            .           .          .               }
     9 ( 0.00%)     2 ( 0.00%)   1 ( 0.01%)     0          0          0            3 ( 0.00%)  0          0           }
     .              .            .              .          .          .            .           .          .           
     .              .            .              .          .          .            .           .          .           #[inline(always)]
     .              .            .              .          .          .            .           .          .           pub fn vm_throw_local_error(buffers: &mut FxHashMap<String, Buffer>, loc: String) {
     .              .            .              .          .          .            .           .          .               if !vm_check_buffer_initialization(buffers, loc.clone()) {
     .              .            .              .          .          .            .           .          .                   vm_throw_global_error(buffers);
     .              .            .              .          .          .            .           .          .                   return;
     .              .            .              .          .          .            .           .          .               }
     .              .            .              .          .          .            .           .          .               if let Some(x) = buffers.get_mut(&(loc.clone())) {
     .              .            .              .          .          .            .           .          .                   *x = Buffer { contents: vec![1] };
     .              .            .              .          .          .            .           .          .               }
     .              .            .              .          .          .            .           .          .           }
     .              .            .              .          .          .            .           .          .           
    48 ( 0.00%)     2 ( 0.00%)   2 ( 0.03%)     0          0          0           15 ( 0.00%)  7 ( 0.13%) 2 ( 0.05%)  pub fn run_vm(
     .              .            .              .          .          .            .           .          .               syntax_tree: SyntaxTree,
     .              .            .              .          .          .            .           .          .               buffers: &mut FxHashMap<String, Buffer>,
     .              .            .              .          .          .            .           .          .               blockutil_interface: BlockUtilInterface,
     .              .            .              .          .          .            .           .          .               contract_hash: String
     .              .            .              .          .          .            .           .          .           ) -> (i64, f64) {
    71 ( 0.00%)     9 ( 0.01%)   9 ( 0.13%)     0          0          0           71 ( 0.00%)  3 ( 0.06%) 1 ( 0.02%)      let mut line_number = 0;
     .              .            .              .          .          .            .           .          .               let mut should_increment;
     2 ( 0.00%)     0            0              0          0          0            1 ( 0.00%)  0          0               let mut gas_used = 0.0;
     2 ( 0.00%)     0            0              0          0          0            1 ( 0.00%)  0          0               let mut origins = vec![];
     8 ( 0.00%)     1 ( 0.00%)   1 ( 0.01%)     3 ( 0.00%) 0          0            4 ( 0.00%)  0          0               let mut stack = Stack{frames: vec![]};
 1,043 ( 0.01%)     9 ( 0.01%)   1 ( 0.01%)   149 ( 0.01%) 0          0          447 ( 0.01%)  0          0               while line_number < syntax_tree.lines.len() {
   888 ( 0.01%)     0            0            148 ( 0.01%) 0          0          444 ( 0.01%)  0          0                   let line = &syntax_tree.lines[line_number];
   148 ( 0.00%)     0            0              0          0          0          148 ( 0.00%)  0          0                   should_increment = true;
 1,332 ( 0.01%)    43 ( 0.03%)   1 ( 0.01%)     0          0          0          740 ( 0.02%)  0          0                   match line.command.as_str() {
 1,184 ( 0.01%)    17 ( 0.01%)   1 ( 0.01%)     0          0          0          296 ( 0.01%)  0          0                       "Exit" => {
     .              .            .              .          .          .            .           .          .                           gas_used += 1.0;
     .              .            .              .          .          .            .           .          .                           return (line.args[0].parse::<i64>().unwrap(), gas_used);
     .              .            .              .          .          .            .           .          .                       }
 1,184 ( 0.01%)     0            0              0          0          0          296 ( 0.01%)  0          0                       "ExitBfr" => {
     .              .            .              .          .          .            .           .          .                           gas_used += 1.0;
     .              .            .              .          .          .            .           .          .                           if !vm_check_buffer_initialization(buffers, line.args[0].clone()) {
     .              .            .              .          .          .            .           .          .                               vm_throw_local_error(buffers, line.args[1].clone())
     .              .            .              .          .          .            .           .          .                           }
     .              .            .              .          .          .            .           .          .                           let exit_code = buffers
     .              .            .              .          .          .            .           .          .                               .get(&line.args[0].clone())
     .              .            .              .          .          .            .           .          .                               .expect("Unable to read exit code buffer")
     .              .            .              .          .          .            .           .          .                               .as_u64()
     .              .            .              .          .          .            .           .          .                               .expect("Could not convert exit code to u64");
     .              .            .              .          .          .            .           .          .                           return (exit_code as i64, gas_used);
     .              .            .              .          .          .            .           .          .                       }
 1,184 ( 0.01%)    25 ( 0.02%)   1 ( 0.01%)     0          0          0          296 ( 0.01%)  0          0                       "InitBfr" => {
   222 ( 0.00%)    18 ( 0.01%)   1 ( 0.01%)     0          0          0           74 ( 0.00%)  0          0                           buffers.insert(
   370 ( 0.00%)    32 ( 0.02%)   1 ( 0.01%)     0          0          0          148 ( 0.00%)  0          0                               line.args[0].clone(),
   148 ( 0.00%)     0            0             74 ( 0.00%) 0          0           74 ( 0.00%)  0          0                               Buffer {
    74 ( 0.00%)     0            0              0          0          0           37 ( 0.00%)  0          0                                   contents: Vec::new(),
     .              .            .              .          .          .            .           .          .                               },
   148 ( 0.00%)     0            0              0          0          0           74 ( 0.00%)  3 ( 0.06%) 0                           );
   148 ( 0.00%)    29 ( 0.02%)   1 ( 0.01%)    74 ( 0.00%) 4 ( 0.07%) 1 ( 0.03%)  37 ( 0.00%)  0          0                           gas_used += 2.0;
   777 ( 0.01%)    36 ( 0.02%)   1 ( 0.01%)   148 ( 0.01%) 1 ( 0.02%) 1 ( 0.03%) 185 ( 0.01%)  0          0                           gas_used += line.args[0].len() as f64 / 10.0;
     .              .            .              .          .          .            .           .          .                       }
   866 ( 0.01%)     0            0              0          0          0          222 ( 0.01%)  0          0                       "CpyBfr" => {
   220 ( 0.00%)    20 ( 0.01%)   1 ( 0.01%)     0          0          0           66 ( 0.00%)  0          0                           if !vm_check_buffer_initialization(buffers, line.args[0].clone())
     .              .            .              .          .          .            .           .          .                           {
     .              .            .              .          .          .            .           .          .                               vm_throw_local_error(buffers, line.args[2].clone());
     .              .            .              .          .          .            .           .          .                           }
   202 ( 0.00%)     0            0              0          0          0           66 ( 0.00%)  0          0                           if !vm_check_buffer_initialization(buffers, line.args[1].clone()) {
    12 ( 0.00%)     2 ( 0.00%)   1 ( 0.01%)     0          0          0            4 ( 0.00%)  0          0                               buffers.insert(
    18 ( 0.00%)     0            0              0          0          0            8 ( 0.00%)  0          0                                   line.args[1].clone(),
     8 ( 0.00%)     0            0              4 ( 0.00%) 0          0            4 ( 0.00%)  0          0                                   Buffer {
     4 ( 0.00%)     0            0              0          0          0            2 ( 0.00%)  0          0                                       contents: Vec::new(),
     .              .            .              .          .          .            .           .          .                                   },
     8 ( 0.00%)     0            0              0          0          0            4 ( 0.00%)  0          0                               );
     6 ( 0.00%)     1 ( 0.00%)   0              4 ( 0.00%) 0          0            2 ( 0.00%)  0          0                               gas_used += 2.0;
     .              .            .              .          .          .            .           .          .                           }
     .              .            .              .          .          .            .           .          .                           let src_contents: Vec<u8> =
   418 ( 0.00%)    27 ( 0.02%)   2 ( 0.03%)     0          0          0          220 ( 0.01%)  1 ( 0.02%) 1 ( 0.02%)                      vm_access_buffer_contents(buffers, line.args[0].clone(), line.args[2].clone());
   528 ( 0.01%)    34 ( 0.02%)   2 ( 0.03%)    44 ( 0.00%) 0          0          176 ( 0.01%)  2 ( 0.04%) 1 ( 0.02%)                  if let Some(dst) = buffers.get_mut(&(line.args[1].clone())) {
   220 ( 0.00%)     0            0             44 ( 0.00%) 0          0           88 ( 0.00%)  0          0                               dst.contents = src_contents.clone();
   330 ( 0.00%)    44 ( 0.03%)   2 ( 0.03%)    88 ( 0.00%) 0          0           66 ( 0.00%)  0          0                               gas_used += src_contents.len() as f64 / 10.0;
    44 ( 0.00%)     0            0              0          0          0           22 ( 0.00%)  0          0                           }
    88 ( 0.00%)     0            0             44 ( 0.00%) 0          0           22 ( 0.00%)  0          0                           gas_used += 2.0;
    88 ( 0.00%)    22 ( 0.02%)   0              0          0          0           22 ( 0.00%)  0          0                       }
   712 ( 0.01%)    27 ( 0.02%)   1 ( 0.01%)     0          0          0          178 ( 0.01%)  0          0                       "FreeBfr" => {
     .              .            .              .          .          .            .           .          .                           if !vm_check_buffer_initialization(buffers, line.args[0].clone()) {
     .              .            .              .          .          .            .           .          .                               vm_throw_local_error(buffers, line.args[1].clone())
     .              .            .              .          .          .            .           .          .                           }
     .              .            .              .          .          .            .           .          .                           buffers
     .              .            .              .          .          .            .           .          .                               .remove(&line.args[0].clone())
     .              .            .              .          .          .            .           .          .                               .expect("Failed to free memory");
     .              .            .              .          .          .            .           .          .                           gas_used += 2.0;
     .              .            .              .          .          .            .           .          .                       }
   712 ( 0.01%)     0            0              0          0          0          178 ( 0.01%)  0          0                       "BfrStat" => {
     .              .            .              .          .          .            .           .          .                           let status = vm_check_buffer_initialization(buffers, line.args[0].clone());
     .              .            .              .          .          .            .           .          .                           if let Some(x) = buffers.get_mut(&(line.args[1].clone())) {
     .              .            .              .          .          .            .           .          .                               if status {
     .              .            .              .          .          .            .           .          .                                   x.contents = vec![1];
     .              .            .              .          .          .            .           .          .                               } else {
     .              .            .              .          .          .            .           .          .                                   x.contents = vec![0];
     .              .            .              .          .          .            .           .          .                               }
     .              .            .              .          .          .            .           .          .                           }
     .              .            .              .          .          .            .           .          .                           gas_used += 1.0;
     .              .            .              .          .          .            .           .          .                       }
   711 ( 0.01%)    73 ( 0.05%)   1 ( 0.01%)     0          0          0          178 ( 0.01%)  0          0                       "BfrLen" => {
    10 ( 0.00%)     1 ( 0.00%)   0              0          0          0            3 ( 0.00%)  0          0                           if !vm_check_buffer_initialization(buffers, line.args[0].clone())
     9 ( 0.00%)     0            0              0          0          0            3 ( 0.00%)  0          0                               || !vm_check_buffer_initialization(buffers, line.args[1].clone())
     .              .            .              .          .          .            .           .          .                           {
     .              .            .              .          .          .            .           .          .                               vm_throw_local_error(buffers, line.args[2].clone())
     .              .            .              .          .          .            .           .          .                           }
    19 ( 0.00%)     1 ( 0.00%)   1 ( 0.01%)     0          0          0           10 ( 0.00%)  1 ( 0.02%) 1 ( 0.02%)                  let x = vm_access_buffer_contents(buffers, line.args[0].clone(), line.args[2].clone());
    22 ( 0.00%)     3 ( 0.00%)   3 ( 0.04%)     2 ( 0.00%) 0          0            8 ( 0.00%)  1 ( 0.02%) 1 ( 0.02%)                  if let Some(y) = buffers.get_mut(&(line.args[1].clone())) {
    10 ( 0.00%)     2 ( 0.00%)   2 ( 0.03%)     0          0          0            6 ( 0.00%)  0          0                               y.load_u64(x.len().try_into().unwrap());
     .              .            .              .          .          .            .           .          .                           }
     6 ( 0.00%)     0            0              0          0          0            2 ( 0.00%)  0          0                       }
   704 ( 0.01%)     0            0              0          0          0          176 ( 0.01%)  0          0                       "Add" => {
    36 ( 0.00%)     8 ( 0.01%)   1 ( 0.01%)     0          0          0           16 ( 0.00%)  0          0                           execute_math_operation(
     .              .            .              .          .          .            .           .          .                               Add {},
     .              .            .              .          .          .            .           .          .                               buffers,
    36 ( 0.00%)     3 ( 0.00%)   1 ( 0.01%)     0          0          0           16 ( 0.00%)  0          0                               line.args[0].clone(),
    32 ( 0.00%)     0            0              0          0          0           16 ( 0.00%)  1 ( 0.02%) 0                               line.args[1].clone(),
    32 ( 0.00%)     4 ( 0.00%)   1 ( 0.01%)     0          0          0           16 ( 0.00%)  0          0                               line.args[2].clone(),
    28 ( 0.00%)     4 ( 0.00%)   1 ( 0.01%)     0          0          0           12 ( 0.00%)  0          0                               line.args[3].clone(),
    12 ( 0.00%)     0            0              0          0          0           12 ( 0.00%)  0          0                           );
    12 ( 0.00%)     0            0              8 ( 0.00%) 0          0            4 ( 0.00%)  0          0                           gas_used += 0.5;
     .              .            .              .          .          .            .           .          .                       }
   672 ( 0.01%)     0            0              0          0          0          168 ( 0.01%)  0          0                       "Sub" => {
    54 ( 0.00%)     6 ( 0.00%)   1 ( 0.01%)     0          0          0           24 ( 0.00%)  0          0                           execute_math_operation(
     .              .            .              .          .          .            .           .          .                               Subtract {},
     .              .            .              .          .          .            .           .          .                               buffers,
    54 ( 0.00%)     0            0              0          0          0           24 ( 0.00%)  0          0                               line.args[0].clone(),
    48 ( 0.00%)     0            0              0          0          0           24 ( 0.00%)  0          0                               line.args[1].clone(),
    48 ( 0.00%)     6 ( 0.00%)   1 ( 0.01%)     0          0          0           24 ( 0.00%)  0          0                               line.args[2].clone(),
    42 ( 0.00%)     0            0              0          0          0           18 ( 0.00%)  0          0                               line.args[3].clone(),
    18 ( 0.00%)     0            0              0          0          0           18 ( 0.00%)  0          0                           );
    18 ( 0.00%)     0            0             12 ( 0.00%) 0          0            6 ( 0.00%)  0          0                           gas_used += 0.5;
     .              .            .              .          .          .            .           .          .                       }
   624 ( 0.01%)    64 ( 0.04%)   1 ( 0.01%)     0          0          0          156 ( 0.00%)  0          0                       "Mul" => {
     .              .            .              .          .          .            .           .          .                           execute_math_operation(
     .              .            .              .          .          .            .           .          .                               Multiply {},
     .              .            .              .          .          .            .           .          .                               buffers,
     .              .            .              .          .          .            .           .          .                               line.args[0].clone(),
     .              .            .              .          .          .            .           .          .                               line.args[1].clone(),
     .              .            .              .          .          .            .           .          .                               line.args[2].clone(),
     .              .            .              .          .          .            .           .          .                               line.args[3].clone(),
     .              .            .              .          .          .            .           .          .                           );
     .              .            .              .          .          .            .           .          .                           gas_used += 1.0;
     .              .            .              .          .          .            .           .          .                       }
   624 ( 0.01%)     0            0              0          0          0          156 ( 0.00%)  0          0                       "Div" => {
    27 ( 0.00%)     6 ( 0.00%)   1 ( 0.01%)     0          0          0           12 ( 0.00%)  0          0                           execute_math_operation(
     .              .            .              .          .          .            .           .          .                               Divide {},
     .              .            .              .          .          .            .           .          .                               buffers,
    27 ( 0.00%)     2 ( 0.00%)   1 ( 0.01%)     0          0          0           12 ( 0.00%)  0          0                               line.args[0].clone(),
    24 ( 0.00%)     0            0              0          0          0           12 ( 0.00%)  1 ( 0.02%) 0                               line.args[1].clone(),
    24 ( 0.00%)     6 ( 0.00%)   2 ( 0.03%)     0          0          0           12 ( 0.00%)  0          0                               line.args[2].clone(),
    21 ( 0.00%)     0            0              0          0          0            9 ( 0.00%)  0          0                               line.args[3].clone(),
     9 ( 0.00%)     3 ( 0.00%)   1 ( 0.01%)     0          0          0            9 ( 0.00%)  0          0                           );
     9 ( 0.00%)     0            0              6 ( 0.00%) 0          0            3 ( 0.00%)  0          0                           gas_used += 1.0;
     .              .            .              .          .          .            .           .          .                       }
   600 ( 0.01%)    35 ( 0.02%)   1 ( 0.01%)     0          0          0          150 ( 0.00%)  0          0                       "Exp" => {
    36 ( 0.00%)     2 ( 0.00%)   1 ( 0.01%)     0          0          0           16 ( 0.00%)  0          0                           execute_math_operation(
     .              .            .              .          .          .            .           .          .                               Exp {},
     .              .            .              .          .          .            .           .          .                               buffers,
    36 ( 0.00%)     4 ( 0.00%)   0              0          0          0           16 ( 0.00%)  0          0                               line.args[0].clone(),
    32 ( 0.00%)     4 ( 0.00%)   1 ( 0.01%)     0          0          0           16 ( 0.00%)  0          0                               line.args[1].clone(),
    32 ( 0.00%)     4 ( 0.00%)   1 ( 0.01%)     0          0          0           16 ( 0.00%)  0          0                               line.args[2].clone(),
    28 ( 0.00%)     0            0              0          0          0           12 ( 0.00%)  0          0                               line.args[3].clone(),
    12 ( 0.00%)     4 ( 0.00%)   1 ( 0.01%)     0          0          0           12 ( 0.00%)  0          0                           );
    12 ( 0.00%)     0            0              8 ( 0.00%) 0          0            4 ( 0.00%)  0          0                           gas_used += 1.5;
     .              .            .              .          .          .            .           .          .                       }
   600 ( 0.01%)     4 ( 0.00%)   1 ( 0.01%)     0          0          0          158 ( 0.01%)  0          0                       "Mod" => execute_math_operation(
     .              .            .              .          .          .            .           .          .                           Modulo {},
     .              .            .              .          .          .            .           .          .                           buffers,
    36 ( 0.00%)     4 ( 0.00%)   1 ( 0.01%)     0          0          0           16 ( 0.00%)  0          0                           line.args[0].clone(),
    32 ( 0.00%)     0            0              0          0          0           16 ( 0.00%)  0          0                           line.args[1].clone(),
    32 ( 0.00%)     4 ( 0.00%)   1 ( 0.01%)     0          0          0           16 ( 0.00%)  0          0                           line.args[2].clone(),
    28 ( 0.00%)     0            0              0          0          0           12 ( 0.00%)  0          0                           line.args[3].clone(),
    16 ( 0.00%)     0            0              0          0          0           12 ( 0.00%)  0          0                       ),
   536 ( 0.01%)    54 ( 0.04%)   1 ( 0.01%)     0          0          0          134 ( 0.00%)  0          0                       "Eq" => {
    63 ( 0.00%)    14 ( 0.01%)   1 ( 0.01%)     0          0          0           28 ( 0.00%)  0          0                           execute_math_operation(
     .              .            .              .          .          .            .           .          .                               Eq {},
     .              .            .              .          .          .            .           .          .                               buffers,
    63 ( 0.00%)     3 ( 0.00%)   0              0          0          0           28 ( 0.00%)  0          0                               line.args[0].clone(),
    56 ( 0.00%)     0            0              0          0          0           28 ( 0.00%)  0          0                               line.args[1].clone(),
    56 ( 0.00%)     5 ( 0.00%)   1 ( 0.01%)     0          0          0           28 ( 0.00%)  0          0                               line.args[2].clone(),
    49 ( 0.00%)     0            0              0          0          0           21 ( 0.00%)  0          0                               line.args[3].clone(),
    21 ( 0.00%)     7 ( 0.00%)   1 ( 0.01%)     0          0          0           21 ( 0.00%)  0          0                           );
    21 ( 0.00%)     0            0             14 ( 0.00%) 0          0            7 ( 0.00%)  0          0                           gas_used += 0.5;
     .              .            .              .          .          .            .           .          .                       }
   480 ( 0.01%)     0            0              0          0          0          120 ( 0.00%)  0          0                       "Less" => {
    27 ( 0.00%)     2 ( 0.00%)   1 ( 0.01%)     0          0          0           12 ( 0.00%)  0          0                           execute_math_operation(
     .              .            .              .          .          .            .           .          .                               Less {},
     .              .            .              .          .          .            .           .          .                               buffers,
    27 ( 0.00%)     3 ( 0.00%)   1 ( 0.01%)     0          0          0           12 ( 0.00%)  0          0                               line.args[0].clone(),
    24 ( 0.00%)     0            0              0          0          0           12 ( 0.00%)  1 ( 0.02%) 0                               line.args[1].clone(),
    24 ( 0.00%)     3 ( 0.00%)   1 ( 0.01%)     0          0          0           12 ( 0.00%)  0          0                               line.args[2].clone(),
    21 ( 0.00%)     0            0              0          0          0            9 ( 0.00%)  0          0                               line.args[3].clone(),
     9 ( 0.00%)     3 ( 0.00%)   1 ( 0.01%)     0          0          0            9 ( 0.00%)  0          0                           );
     9 ( 0.00%)     0            0              6 ( 0.00%) 0          0            3 ( 0.00%)  0          0                           gas_used += 0.5;
     .              .            .              .          .          .            .           .          .                       }
   456 ( 0.00%)     0            0              0          0          0          114 ( 0.00%)  0          0                       "And" => {
     .              .            .              .          .          .            .           .          .                           execute_math_operation(
     .              .            .              .          .          .            .           .          .                               And {},
     .              .            .              .          .          .            .           .          .                               buffers,
     .              .            .              .          .          .            .           .          .                               line.args[0].clone(),
     .              .            .              .          .          .            .           .          .                               line.args[1].clone(),
     .              .            .              .          .          .            .           .          .                               line.args[2].clone(),
     .              .            .              .          .          .            .           .          .                               line.args[3].clone(),
     .              .            .              .          .          .            .           .          .                           );
     .              .            .              .          .          .            .           .          .                           gas_used += 1.0;
     .              .            .              .          .          .            .           .          .                       }
   456 ( 0.00%)    42 ( 0.03%)   1 ( 0.01%)     0          0          0          114 ( 0.00%)  0          0                       "Or" => {
     .              .            .              .          .          .            .           .          .                           execute_math_operation(
     .              .            .              .          .          .            .           .          .                               Or {},
     .              .            .              .          .          .            .           .          .                               buffers,
     .              .            .              .          .          .            .           .          .                               line.args[0].clone(),
     .              .            .              .          .          .            .           .          .                               line.args[1].clone(),
     .              .            .              .          .          .            .           .          .                               line.args[2].clone(),
     .              .            .              .          .          .            .           .          .                               line.args[3].clone(),
     .              .            .              .          .          .            .           .          .                           );
     .              .            .              .          .          .            .           .          .                           gas_used += 1.0;
     .              .            .              .          .          .            .           .          .                       }
   455 ( 0.00%)     0            0              0          0          0          114 ( 0.00%)  0          0                       "Not" => {
     9 ( 0.00%)     2 ( 0.00%)   1 ( 0.01%)     0          0          0            4 ( 0.00%)  0          0                           execute_math_operation(
     .              .            .              .          .          .            .           .          .                               Not {},
     .              .            .              .          .          .            .           .          .                               buffers,
     9 ( 0.00%)     1 ( 0.00%)   1 ( 0.01%)     0          0          0            4 ( 0.00%)  0          0                               line.args[0].clone(),
     8 ( 0.00%)     0            0              0          0          0            2 ( 0.00%)  0          0                               "".into(),
     8 ( 0.00%)     1 ( 0.00%)   1 ( 0.01%)     0          0          0            4 ( 0.00%)  1 ( 0.02%) 0                               line.args[1].clone(),
     7 ( 0.00%)     0            0              0          0          0            3 ( 0.00%)  0          0                               line.args[2].clone(),
     3 ( 0.00%)     0            0              0          0          0            3 ( 0.00%)  0          0                           );
     4 ( 0.00%)     1 ( 0.00%)   1 ( 0.01%)     2 ( 0.00%) 0          0            1 ( 0.00%)  0          0                           gas_used += 0.5
     .              .            .              .          .          .            .           .          .                       }
   446 ( 0.00%)    90 ( 0.06%)   2 ( 0.03%)     0          0          0          112 ( 0.00%)  0          0                       "App" => {
    20 ( 0.00%)     2 ( 0.00%)   0              0          0          0            6 ( 0.00%)  0          0                           if !vm_check_buffer_initialization(buffers, line.args[0].clone())
    18 ( 0.00%)     0            0              0          0          0            6 ( 0.00%)  1 ( 0.02%) 0                               || !vm_check_buffer_initialization(buffers, line.args[1].clone())
     .              .            .              .          .          .            .           .          .                           {
     .              .            .              .          .          .            .           .          .                               vm_throw_local_error(buffers, line.args[1].clone())
     .              .            .              .          .          .            .           .          .                           }
    38 ( 0.00%)     2 ( 0.00%)   1 ( 0.01%)     0          0          0           22 ( 0.00%)  3 ( 0.06%) 0                           let y = vm_access_buffer_contents(buffers, line.args[1].clone(), line.args[2].clone());
    46 ( 0.00%)     6 ( 0.00%)   3 ( 0.04%)     4 ( 0.00%) 0          0           16 ( 0.00%)  0          0                           if let Some(x) = buffers.get_mut(&(line.args[0].clone())) {
    16 ( 0.00%)     3 ( 0.00%)   1 ( 0.01%)     4 ( 0.00%) 0          0            8 ( 0.00%)  0          0                               x.contents.extend(y);
    30 ( 0.00%)     2 ( 0.00%)   1 ( 0.01%)     8 ( 0.00%) 0          0            6 ( 0.00%)  0          0                               gas_used += x.contents.len() as f64 / 10.0;
     4 ( 0.00%)     0            0              0          0          0            2 ( 0.00%)  0          0                           }
     6 ( 0.00%)     2 ( 0.00%)   1 ( 0.01%)     4 ( 0.00%) 0          0            2 ( 0.00%)  0          0                           gas_used += 2.0;
     8 ( 0.00%)     0            0              2 ( 0.00%) 0          0            2 ( 0.00%)  0          0                       }
   432 ( 0.00%)     0            0              0          0          0          108 ( 0.00%)  0          0                       "Slice" => unsafe {
     .              .            .              .          .          .            .           .          .                           if !vm_check_buffer_initialization(buffers, line.args[0].clone())
     .              .            .              .          .          .            .           .          .                               || !vm_check_buffer_initialization(buffers, line.args[1].clone())
     .              .            .              .          .          .            .           .          .                               || !vm_check_buffer_initialization(buffers, line.args[2].clone())
     .              .            .              .          .          .            .           .          .                           {
     .              .            .              .          .          .            .           .          .                               vm_throw_local_error(buffers, line.args[3].clone())
     .              .            .              .          .          .            .           .          .                           }
     .              .            .              .          .          .            .           .          .                           let start_buf = (*vm_access_buffer(buffers, line.args[1].clone(), line.args[3].clone())).as_u64().unwrap() as usize;
     .              .            .              .          .          .            .           .          .                           let end_buf = (*vm_access_buffer(buffers, line.args[2].clone(), line.args[3].clone())).as_u64().unwrap() as usize;
-- line 310 ----------------------------------------
-- line 312 ----------------------------------------
     .              .            .              .          .          .            .           .          .                               vm_access_buffer_contents(buffers, line.args[0].clone(), line.args[3].clone());
     .              .            .              .          .          .            .           .          .                           let sliced_buf = buf_to_slice[start_buf..end_buf].to_vec();
     .              .            .              .          .          .            .           .          .                           if let Some(x) = buffers.get_mut(&(line.args[0].clone())) {
     .              .            .              .          .          .            .           .          .                               x.contents = sliced_buf;
     .              .            .              .          .          .            .           .          .                               gas_used += x.contents.len() as f64 / 10.0;
     .              .            .              .          .          .            .           .          .                           }
     .              .            .              .          .          .            .           .          .                           gas_used += 2.0;
     .              .            .              .          .          .            .           .          .                       }
   432 ( 0.00%)    47 ( 0.03%)   1 ( 0.01%)     0          0          0          108 ( 0.00%)  0          0                       "Shiftl" => unsafe {
     .              .            .              .          .          .            .           .          .                           if !vm_check_buffer_initialization(buffers, line.args[0].clone())
     .              .            .              .          .          .            .           .          .                               || !vm_check_buffer_initialization(buffers, line.args[1].clone())
     .              .            .              .          .          .            .           .          .                           {
     .              .            .              .          .          .            .           .          .                               vm_throw_local_error(buffers, line.args[2].clone())
     .              .            .              .          .          .            .           .          .                           }
     .              .            .              .          .          .            .           .          .                           let mut buf_to_shift =
     .              .            .              .          .          .            .           .          .                               vm_access_buffer_contents(buffers, line.args[0].clone(), line.args[2].clone());
     .              .            .              .          .          .            .           .          .                           let shift_amount = (*vm_access_buffer(buffers, line.args[1].clone(), line.args[2].clone())).as_u64().unwrap() as usize;
-- line 328 ----------------------------------------
-- line 329 ----------------------------------------
     .              .            .              .          .          .            .           .          .                           buf_to_shift.drain(buf_to_shift.len() - shift_amount..);
     .              .            .              .          .          .            .           .          .                           let zeroes = vec![0; shift_amount];
     .              .            .              .          .          .            .           .          .                           buf_to_shift.extend(zeroes);
     .              .            .              .          .          .            .           .          .                           if let Some(x) = buffers.get_mut(&(line.args[0].clone())) {
     .              .            .              .          .          .            .           .          .                               x.contents = buf_to_shift;
     .              .            .              .          .          .            .           .          .                           }
     .              .            .              .          .          .            .           .          .                           gas_used += 2.0;
     .              .            .              .          .          .            .           .          .                       }
   432 ( 0.00%)     0            0              0          0          0          108 ( 0.00%)  0          0                       "Shiftr" => unsafe {
     .              .            .              .          .          .            .           .          .                           if !vm_check_buffer_initialization(buffers, line.args[0].clone())
     .              .            .              .          .          .            .           .          .                               || !vm_check_buffer_initialization(buffers, line.args[1].clone())
     .              .            .              .          .          .            .           .          .                           {
     .              .            .              .          .          .            .           .          .                               vm_throw_local_error(buffers, line.args[1].clone())
     .              .            .              .          .          .            .           .          .                           }
     .              .            .              .          .          .            .           .          .                           let mut buf_to_shift =
     .              .            .              .          .          .            .           .          .                               vm_access_buffer_contents(buffers, line.args[0].clone(), line.args[2].clone());
     .              .            .              .          .          .            .           .          .                           let shift_amount = (*vm_access_buffer(buffers, line.args[1].clone(), line.args[2].clone())).as_u64().unwrap() as usize;
-- line 345 ----------------------------------------
-- line 346 ----------------------------------------
     .              .            .              .          .          .            .           .          .                           buf_to_shift.drain(0..shift_amount);
     .              .            .              .          .          .            .           .          .                           let zeroes = vec![0; shift_amount];
     .              .            .              .          .          .            .           .          .                           buf_to_shift.splice(..0, zeroes.iter().cloned());
     .              .            .              .          .          .            .           .          .                           if let Some(x) = buffers.get_mut(&(line.args[0].clone())) {
     .              .            .              .          .          .            .           .          .                               x.contents = buf_to_shift;
     .              .            .              .          .          .            .           .          .                           }
     .              .            .              .          .          .            .           .          .                           gas_used += 2.0;
     .              .            .              .          .          .            .           .          .                       }
   432 ( 0.00%)    33 ( 0.02%)   1 ( 0.01%)     0          0          0          108 ( 0.00%)  0          0                       "Jmp" => {
    84 ( 0.00%)     3 ( 0.00%)   1 ( 0.01%)     0          0          0           30 ( 0.00%)  0          0                           line_number = line.args[0].parse::<usize>().unwrap() - 1;
     6 ( 0.00%)     0            0              0          0          0            6 ( 0.00%)  0          0                           should_increment = false;
    18 ( 0.00%)     6 ( 0.00%)   1 ( 0.01%)    12 ( 0.00%) 1 ( 0.02%) 1 ( 0.03%)   6 ( 0.00%)  0          0                           gas_used += 0.8;
     .              .            .              .          .          .            .           .          .                       }
   384 ( 0.00%)     0            0              0          0          0           96 ( 0.00%)  0          0                       "JmpCond" => {
   100 ( 0.00%)     0            0              0          0          0           30 ( 0.00%)  0          0                           if !vm_check_buffer_initialization(buffers, line.args[0].clone()) {
     .              .            .              .          .          .            .           .          .                               vm_throw_local_error(buffers, line.args[2].clone())
     .              .            .              .          .          .            .           .          .                           }
   190 ( 0.00%)    10 ( 0.01%)   1 ( 0.01%)     0          0          0           70 ( 0.00%)  2 ( 0.04%) 0                           if buffers.get(&line.args[0]).unwrap().as_u64() != Ok(0) {
    52 ( 0.00%)     4 ( 0.00%)   1 ( 0.01%)     0          0          0           20 ( 0.00%)  0          0                               line_number = line.args[1].parse::<usize>().unwrap() - 1;
     4 ( 0.00%)     0            0              0          0          0            4 ( 0.00%)  0          0                               should_increment = false;
     .              .            .              .          .          .            .           .          .                           }
    30 ( 0.00%)     6 ( 0.00%)   1 ( 0.01%)    20 ( 0.00%) 0          0           10 ( 0.00%)  0          0                           gas_used += 1.0;
     .              .            .              .          .          .            .           .          .                       }
   304 ( 0.00%)     0            0              0          0          0           76 ( 0.00%)  0          0                       "Call" => {
    14 ( 0.00%)     0            0              0          0          0            7 ( 0.00%)  0          0                           stack.push(buffers);
    49 ( 0.00%)    14 ( 0.01%)   2 ( 0.03%)     7 ( 0.00%) 0          0           14 ( 0.00%)  1 ( 0.02%) 0                           origins.push(line_number + 1);
    98 ( 0.00%)    12 ( 0.01%)   2 ( 0.03%)     0          0          0           35 ( 0.00%)  0          0                           line_number = line.args[0].parse::<usize>().unwrap() - 1;
     7 ( 0.00%)     0            0              0          0          0            7 ( 0.00%)  0          0                           should_increment = false;
     .              .            .              .          .          .            .           .          .                       }
   241 ( 0.00%)    24 ( 0.02%)   1 ( 0.01%)     0          0          0           62 ( 0.00%)  0          0                       "Ret" => unsafe {
    21 ( 0.00%)    14 ( 0.01%)   1 ( 0.01%)     0          0          0           14 ( 0.00%)  0          0                           let frame_buffers = stack.pop();
   126 ( 0.00%)    14 ( 0.01%)   2 ( 0.03%)     0          0          0           56 ( 0.00%)  2 ( 0.04%) 0                           let return_value_tmp = (*vm_access_buffer(buffers, "00000001".parse().unwrap(), "00000000".parse().unwrap())).clone();
    77 ( 0.00%)    14 ( 0.01%)   2 ( 0.03%)    28 ( 0.00%) 0          0           42 ( 0.00%)  2 ( 0.04%) 0                           *buffers = frame_buffers;
   126 ( 0.00%)     7 ( 0.00%)   1 ( 0.01%)    14 ( 0.00%) 0          0           42 ( 0.00%)  2 ( 0.04%) 0                           buffers.insert("00000001".into(), return_value_tmp);
   112 ( 0.00%)    14 ( 0.01%)   2 ( 0.03%)     7 ( 0.00%) 0          0           56 ( 0.00%)  0          0                           line_number = *origins.last().expect("Could not get last origin");
    84 ( 0.00%)    14 ( 0.01%)   2 ( 0.03%)     0          0          0           28 ( 0.00%)  0          0                           origins.remove(origins.len() - 1);
     7 ( 0.00%)     0            0              0          0          0            7 ( 0.00%)  0          0                           should_increment = false;
    21 ( 0.00%)     0            0              0          0          0           14 ( 0.00%)  0          0                       }
   192 ( 0.00%)     0            0              0          0          0           48 ( 0.00%)  0          0                       "Stdout" => {
     .              .            .              .          .          .            .           .          .                           if !vm_check_buffer_initialization(buffers, line.args[0].clone()) {
     .              .            .              .          .          .            .           .          .                               vm_throw_local_error(buffers, line.args[1].clone())
     .              .            .              .          .          .            .           .          .                           }
     .              .            .              .          .          .            .           .          .                           println!("{:?}", vm_access_buffer_contents(buffers, line.args[0].clone(), line.args[1].clone()));
     .              .            .              .          .          .            .           .          .                           gas_used += 0.5;
     .              .            .              .          .          .            .           .          .                       }
   190 ( 0.00%)     0            0              0          0          0           48 ( 0.00%)  0          0                       "PrintStr" => unsafe {
    20 ( 0.00%)     0            0              0          0          0            6 ( 0.00%)  0          0                           if !vm_check_buffer_initialization(buffers, line.args[0].clone()) {
     .              .            .              .          .          .            .           .          .                               vm_throw_local_error(buffers, line.args[1].clone())
     .              .            .              .          .          .            .           .          .                           }
    62 ( 0.00%)     4 ( 0.00%)   2 ( 0.03%)     0          0          0           34 ( 0.00%)  4 ( 0.08%) 2 ( 0.05%)                  let str = std::str::from_utf8(&(*vm_access_buffer(buffers, line.args[0].clone(), line.args[1].clone())).contents).unwrap();
    22 ( 0.00%)     3 ( 0.00%)   1 ( 0.01%)     2 ( 0.00%) 0          0            6 ( 0.00%)  0          0                           println!("{}", str);
     6 ( 0.00%)     0            0              4 ( 0.00%) 0          0            2 ( 0.00%)  0          0                           gas_used += 0.5;
     2 ( 0.00%)     0            0              0          0          0            0           0          0                       }
   176 ( 0.00%)    36 ( 0.02%)   2 ( 0.03%)     0          0          0           44 ( 0.00%)  0          0                       "Stderr" => {
     .              .            .              .          .          .            .           .          .                           if !vm_check_buffer_initialization(buffers, line.args[0].clone()) {
     .              .            .              .          .          .            .           .          .                               vm_throw_local_error(buffers, line.args[1].clone())
     .              .            .              .          .          .            .           .          .                           }
     .              .            .              .          .          .            .           .          .                           eprintln!("{:?}", vm_access_buffer_contents(buffers, line.args[0].clone(), line.args[1].clone()));
     .              .            .              .          .          .            .           .          .                           gas_used += 0.5;
     .              .            .              .          .          .            .           .          .                       }
   157 ( 0.00%)     0            0              0          0          0           44 ( 0.00%)  0          0                       "SetCnst" => unsafe {
   190 ( 0.00%)     0            0              0          0          0           57 ( 0.00%)  0          0                           if !vm_check_buffer_initialization(buffers, line.args[0].clone()) {
     .              .            .              .          .          .            .           .          .                               vm_throw_local_error(buffers, line.args[2].clone())
     .              .            .              .          .          .            .           .          .                           }
   380 ( 0.00%)    19 ( 0.01%)   1 ( 0.01%)     0          0          0          209 ( 0.01%)  3 ( 0.06%) 0                           let bfr_ptr: *mut Buffer = vm_access_buffer(buffers, line.args[0].clone(), line.args[2].clone());
   190 ( 0.00%)     0            0             38 ( 0.00%) 0          0           57 ( 0.00%)  0          0                           (*bfr_ptr).contents =
   304 ( 0.00%)    25 ( 0.02%)   2 ( 0.03%)     0          0          0           95 ( 0.00%)  0          0                               hex::decode(line.args[1].clone()).expect("Failed to parse raw hex value");
   285 ( 0.00%)    19 ( 0.01%)   1 ( 0.01%)    76 ( 0.00%) 0          0           57 ( 0.00%)  0          0                           gas_used += (*bfr_ptr).contents.len() as f64 / 10.0;
    57 ( 0.00%)     0            0             38 ( 0.00%) 0          0           19 ( 0.00%)  0          0                           gas_used += 2.0;
    19 ( 0.00%)     0            0              0          0          0            0           0          0                       }
    24 ( 0.00%)     2 ( 0.00%)   1 ( 0.01%)     0          0          0            6 ( 0.00%)  0          0                       "Tx" => {
     .              .            .              .          .          .            .           .          .                           let sender_bytes =
     .              .            .              .          .          .            .           .          .                               vm_access_buffer_contents(buffers, line.args[0].clone(), line.args[3].clone());
     .              .            .              .          .          .            .           .          .                           let sender = match std::string::String::from_utf8(sender_bytes) {
     .              .            .              .          .          .            .           .          .                               Ok(v) => v,
     .              .            .              .          .          .            .           .          .                               Err(_) => {
     .              .            .              .          .          .            .           .          .                                   vm_throw_local_error(buffers, line.args[3].clone());
     .              .            .              .          .          .            .           .          .                                   "".to_owned()
     .              .            .              .          .          .            .           .          .                               }
-- line 424 ----------------------------------------
-- line 439 ----------------------------------------
     .              .            .              .          .          .            .           .          .                               Err(_) => {
     .              .            .              .          .          .            .           .          .                                   vm_throw_local_error(buffers, line.args[3].clone());
     .              .            .              .          .          .            .           .          .                                   "".to_owned()
     .              .            .              .          .          .            .           .          .                               }
     .              .            .              .          .          .            .           .          .                           };
     .              .            .              .          .          .            .           .          .                           println!("TX {} {} {}", sender, receiver, amount);
     .              .            .              .          .          .            .           .          .                           gas_used += 4.0;
     .              .            .              .          .          .            .           .          .                       }
    24 ( 0.00%)     0            0              0          0          0            6 ( 0.00%)  0          0                       "GetNthBlk" => unsafe {
     .              .            .              .          .          .            .           .          .                           // Get a property of the nth block in the chain
     .              .            .              .          .          .            .           .          .                           if !vm_check_buffer_initialization(buffers, line.args[0].clone())
     .              .            .              .          .          .            .           .          .                               || !vm_check_buffer_initialization(buffers, line.args[1].clone())
     .              .            .              .          .          .            .           .          .                               || !vm_check_buffer_initialization(buffers, line.args[2].clone())
     .              .            .              .          .          .            .           .          .                           {
     .              .            .              .          .          .            .           .          .                               vm_throw_local_error(buffers, line.args[3].clone())
     .              .            .              .          .          .            .           .          .                           }
     .              .            .              .          .          .            .           .          .                           let block_number = (*vm_access_buffer(buffers, line.args[0].clone(), line.args[3].clone())).as_u64().unwrap() as usize;
-- line 455 ----------------------------------------
-- line 489 ----------------------------------------
     .              .            .              .          .          .            .           .          .                                   }
     .              .            .              .          .          .            .           .          .                               }
     .              .            .              .          .          .            .           .          .                               _ => {
     .              .            .              .          .          .            .           .          .                                   vm_throw_local_error(buffers, line.args[1].clone());
     .              .            .              .          .          .            .           .          .                               }
     .              .            .              .          .          .            .           .          .                           }
     .              .            .              .          .          .            .           .          .                           gas_used += 3.0;
     .              .            .              .          .          .            .           .          .                       }
    24 ( 0.00%)     2 ( 0.00%)   1 ( 0.01%)     0          0          0            6 ( 0.00%)  0          0                       "GetNthTx" => {
     .              .            .              .          .          .            .           .          .                           // Get a property of the nth transaction in the nth block in the chain
     .              .            .              .          .          .            .           .          .                           if !vm_check_buffer_initialization(buffers, line.args[0].clone())
     .              .            .              .          .          .            .           .          .                               || !vm_check_buffer_initialization(buffers, line.args[1].clone())
     .              .            .              .          .          .            .           .          .                               || !vm_check_buffer_initialization(buffers, line.args[2].clone())
     .              .            .              .          .          .            .           .          .                               || !vm_check_buffer_initialization(buffers, line.args[3].clone())
     .              .            .              .          .          .            .           .          .                           {
     .              .            .              .          .          .            .           .          .                               vm_throw_local_error(buffers, line.args[4].clone())
     .              .            .              .          .          .            .           .          .                           }
-- line 505 ----------------------------------------
-- line 551 ----------------------------------------
     .              .            .              .          .          .            .           .          .                                   }
     .              .            .              .          .          .            .           .          .                               }
     .              .            .              .          .          .            .           .          .                               _ => {
     .              .            .              .          .          .            .           .          .                                   vm_throw_local_error(buffers, line.args[2].clone());
     .              .            .              .          .          .            .           .          .                               }
     .              .            .              .          .          .            .           .          .                           }
     .              .            .              .          .          .            .           .          .                           gas_used += 3.0;
     .              .            .              .          .          .            .           .          .                       }
    24 ( 0.00%)     0            0              0          0          0            6 ( 0.00%)  0          0                       "ChainLen" => {
     .              .            .              .          .          .            .           .          .                           if !vm_check_buffer_initialization(buffers, line.args[0].clone()) {
     .              .            .              .          .          .            .           .          .                               vm_throw_local_error(buffers, line.args[1].clone());
     .              .            .              .          .          .            .           .          .                           }
     .              .            .              .          .          .            .           .          .                           let buf = buffers.get_mut(&line.args[0]).unwrap();
     .              .            .              .          .          .            .           .          .                           let len = blockutil_interface.get_blockchain_len();
     .              .            .              .          .          .            .           .          .                           buf.load_u64(len);
     .              .            .              .          .          .            .           .          .                       }
    24 ( 0.00%)     0            0              0          0          0            6 ( 0.00%)  0          0                       "UpdateState" => {
     .              .            .              .          .          .            .           .          .                           if !vm_check_buffer_initialization(buffers, line.args[0].clone())
     .              .            .              .          .          .            .           .          .                               || !vm_check_buffer_initialization(buffers, line.args[1].clone())
     .              .            .              .          .          .            .           .          .                           {
     .              .            .              .          .          .            .           .          .                               vm_throw_local_error(buffers, line.args[2].clone());
     .              .            .              .          .          .            .           .          .                           }
     .              .            .              .          .          .            .           .          .                           let location = buffers.get(&line.args[0]).unwrap().as_u64().unwrap() as usize;
     .              .            .              .          .          .            .           .          .                           let contents_vec_u8 =
     .              .            .              .          .          .            .           .          .                               vm_access_buffer_contents(buffers, line.args[1].clone(), line.args[2].clone());
     .              .            .              .          .          .            .           .          .                           let contents_hex = hex::encode(contents_vec_u8.clone());
     .              .            .              .          .          .            .           .          .                           println!("State change: {}{}|{}", contract_hash.clone(), location, contents_hex);
     .              .            .              .          .          .            .           .          .                           gas_used += 3.0;
     .              .            .              .          .          .            .           .          .                           gas_used += 0.6 * contents_vec_u8.len() as f64;
     .              .            .              .          .          .            .           .          .                       }
    24 ( 0.00%)     2 ( 0.00%)   1 ( 0.01%)     0          0          0            6 ( 0.00%)  1 ( 0.02%) 0                       "UpdateStateExternal" => {
     .              .            .              .          .          .            .           .          .                           if !vm_check_buffer_initialization(buffers, line.args[0].clone())
     .              .            .              .          .          .            .           .          .                               || !vm_check_buffer_initialization(buffers, line.args[1].clone())
     .              .            .              .          .          .            .           .          .                           {
     .              .            .              .          .          .            .           .          .                               vm_throw_local_error(buffers, line.args[2].clone());
     .              .            .              .          .          .            .           .          .                           }
     .              .            .              .          .          .            .           .          .                           let location = buffers.get(&line.args[0]).unwrap().as_u64().unwrap() as usize;
     .              .            .              .          .          .            .           .          .                           let contents_vec_u8 =
     .              .            .              .          .          .            .           .          .                               vm_access_buffer_contents(buffers, line.args[1].clone(), line.args[2].clone());
     .              .            .              .          .          .            .           .          .                           let contents_hex = hex::encode(contents_vec_u8.clone());
     .              .            .              .          .          .            .           .          .                           println!("External state change: {}|{}", location, contents_hex);
     .              .            .              .          .          .            .           .          .                           gas_used += 3.0;
     .              .            .              .          .          .            .           .          .                           gas_used += 0.6 * contents_vec_u8.len() as f64;
     .              .            .              .          .          .            .           .          .                       }
    24 ( 0.00%)     0            0              0          0          0            6 ( 0.00%)  0          0                       "GetFromState" => {
     .              .            .              .          .          .            .           .          .                           if !vm_check_buffer_initialization(buffers, line.args[0].clone())
     .              .            .              .          .          .            .           .          .                               || !vm_check_buffer_initialization(buffers, line.args[1].clone())
     .              .            .              .          .          .            .           .          .                           {
     .              .            .              .          .          .            .           .          .                               vm_throw_local_error(buffers, line.args[2].clone());
     .              .            .              .          .          .            .           .          .                           }
     .              .            .              .          .          .            .           .          .                           let location = std::str::from_utf8(&vm_access_buffer_contents(buffers, line.args[0].clone(), line.args[1].clone())).expect("Could not convert state location to string").to_owned();
     .              .            .              .          .          .            .           .          .                           let (contents_vec_u8, success) = blockutil_interface.get_from_state(location.parse().unwrap());
     .              .            .              .          .          .            .           .          .                           if !success {
     .              .            .              .          .          .            .           .          .                               vm_throw_local_error(buffers, line.args[2].clone());
     .              .            .              .          .          .            .           .          .                           }
     .              .            .              .          .          .            .           .          .                           let dst_buffer = buffers.get_mut(&line.args[1]).unwrap();
     .              .            .              .          .          .            .           .          .                           dst_buffer.contents = contents_vec_u8;
     .              .            .              .          .          .            .           .          .                       }
    24 ( 0.00%)     4 ( 0.00%)   2 ( 0.03%)     0          0          0            6 ( 0.00%)  0          0                       "GetFromStateWithPrefix" => {
     .              .            .              .          .          .            .           .          .                           if !vm_check_buffer_initialization(buffers, line.args[0].clone())
     .              .            .              .          .          .            .           .          .                               || !vm_check_buffer_initialization(buffers, line.args[1].clone())
     .              .            .              .          .          .            .           .          .                           {
     .              .            .              .          .          .            .           .          .                               vm_throw_local_error(buffers, line.args[2].clone());
     .              .            .              .          .          .            .           .          .                           }
     .              .            .              .          .          .            .           .          .                           let location = std::str::from_utf8(&vm_access_buffer_contents(buffers, line.args[0].clone(), line.args[1].clone())).expect("Could not convert state location to string").to_owned();
     .              .            .              .          .          .            .           .          .                           let (contents_vec_u8, success) = blockutil_interface.get_from_state(contract_hash.clone() + &*location);
     .              .            .              .          .          .            .           .          .                           if !success {
     .              .            .              .          .          .            .           .          .                               vm_throw_local_error(buffers, line.args[2].clone());
     .              .            .              .          .          .            .           .          .                           }
     .              .            .              .          .          .            .           .          .                           let dst_buffer = buffers.get_mut(&line.args[1]).unwrap();
     .              .            .              .          .          .            .           .          .                           dst_buffer.contents = contents_vec_u8;
     .              .            .              .          .          .            .           .          .                       }
     3 ( 0.00%)     0            0              0          0          0            0           0          0                       &_ => vm_throw_global_error(buffers),
     .              .            .              .          .          .            .           .          .                   }
   444 ( 0.00%)    82 ( 0.06%)   1 ( 0.01%)   148 ( 0.01%) 0          0            0           0          0                   if should_increment {
   744 ( 0.01%)    60 ( 0.04%)   1 ( 0.01%)   124 ( 0.01%) 0          0          248 ( 0.01%)  0          0                       line_number += 1;
     .              .            .              .          .          .            .           .          .                   }
     .              .            .              .          .          .            .           .          .               }
     4 ( 0.00%)     0            0              1 ( 0.00%) 0          0            2 ( 0.00%)  0          0               (0, gas_used)
    13 ( 0.00%)     2 ( 0.00%)   1 ( 0.01%)     3 ( 0.00%) 1 ( 0.02%) 0            5 ( 0.00%)  0          0           }

11,250 ( 0.12%) 2,514 ( 1.74%) 218 ( 3.07%) 9,318 ( 0.38%) 0          0          166 ( 0.01%) 19 ( 0.36%) 5 ( 0.12%)  <counts for unidentified lines in /home/ashy5000/dev/cryptocurrency/contracts/src/vm.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/ashy5000/dev/cryptocurrency/contracts/src/syntax_tree.rs
--------------------------------------------------------------------------------
Ir              I1mr           ILmr        Dr             D1mr       DLmr       Dw             D1mw       DLmw       

-- line 8 ----------------------------------------
     .              .           .              .          .          .              .          .          .           */
     .              .           .              .          .          .              .          .          .           use smartstring::alias::String;
     .              .           .              .          .          .              .          .          .           #[derive(Debug, Clone)]
     .              .           .              .          .          .              .          .          .           pub struct Line {
     .              .           .              .          .          .              .          .          .               pub command: String,
     .              .           .              .          .          .              .          .          .               pub args: Vec<String>,
     .              .           .              .          .          .              .          .          .           }
     .              .           .              .          .          .              .          .          .           
   309 ( 0.00%)   103 ( 0.07%)  1 ( 0.01%)     0          0          0            206 ( 0.01%) 0          0           pub(crate) fn build_line() -> Line {
 1,236 ( 0.01%)     0           0            618 ( 0.03%) 0          0            618 ( 0.02%) 0          0               Line {
   721 ( 0.01%)   103 ( 0.07%)  1 ( 0.01%)     0          0          0            103 ( 0.00%) 0          0                   command: "".into(),
   206 ( 0.00%)     0           0              0          0          0            103 ( 0.00%) 0          0                   args: Vec::new(),
     .              .           .              .          .          .              .          .          .               }
   206 ( 0.00%)   100 ( 0.07%)  0            103 ( 0.00%) 0          0              0          0          0           }
     .              .           .              .          .          .              .          .          .           
     .              .           .              .          .          .              .          .          .           #[derive(Debug)]
     .              .           .              .          .          .              .          .          .           pub struct SyntaxTree {
     .              .           .              .          .          .              .          .          .               pub lines: Vec<Line>
     .              .           .              .          .          .              .          .          .           }
     .              .           .              .          .          .              .          .          .           
     .              .           .              .          .          .              .          .          .           impl SyntaxTree {
     7 ( 0.00%)     2 ( 0.00%)  2 ( 0.03%)     1 ( 0.00%) 0          0              4 ( 0.00%) 0          0               pub fn create(&mut self, contract_contents: String) {
    11 ( 0.00%)     2 ( 0.00%)  2 ( 0.03%)     0          0          0              7 ( 0.00%) 0          0                   let asm_lines_iter = contract_contents.split("\n");
 1,787 ( 0.02%)   122 ( 0.08%)  3 ( 0.04%)   313 ( 0.01%) 0          0            735 ( 0.02%) 0          0                   for asm_line in asm_lines_iter {
   520 ( 0.01%)     0           0              0          0          0            104 ( 0.00%) 0          0                       let parts_iter = asm_line.split(" ");
   208 ( 0.00%)     0           0              0          0          0            104 ( 0.00%) 0          0                       let mut parts = Vec::new();
 8,216 ( 0.09%)   493 ( 0.34%)  2 ( 0.03%) 1,266 ( 0.05%) 0          0          3,314 ( 0.11%) 0          0                       for mut part in parts_iter {
 3,177 ( 0.03%)   356 ( 0.25%)  1 ( 0.01%)     0          0          0            806 ( 0.03%) 0          0                           if part == ";" {
     .              .           .              .          .          .              .          .          .                               break
     .              .           .              .          .          .              .          .          .                           }
 3,560 ( 0.04%)     0           0            712 ( 0.03%) 0          0          2,136 ( 0.07%) 0          0                           let part_chars = &part.chars();
 2,848 ( 0.03%)     0           0              0          0          0          1,780 ( 0.06%) 0          0                           let first_two_chars: String = part_chars.to_owned().take(2).collect();
     .              .           .              .          .          .              .          .          .                           let part_string;
 2,848 ( 0.03%)   108 ( 0.07%)  1 ( 0.01%)     0          0          0            712 ( 0.02%) 0          0                           if first_two_chars == "0x" {
 7,140 ( 0.08%)   203 ( 0.14%)  2 ( 0.03%)   952 ( 0.04%) 0          0          3,332 ( 0.11%) 1 ( 0.02%) 0                               part_string = part_chars.to_owned().skip(2).take(part.len() - 2).collect::<String>().to_owned();
 1,428 ( 0.02%)     0           0              0          0          0          1,190 ( 0.04%) 0          0                               part = part_string.as_str();
     .              .           .              .          .          .              .          .          .                           }
 2,492 ( 0.03%)   102 ( 0.07%)  1 ( 0.01%)   712 ( 0.03%) 0          0            712 ( 0.02%) 0          0                           parts.push(part.to_owned())
 2,612 ( 0.03%)   105 ( 0.07%)  1 ( 0.01%)   356 ( 0.01%) 0          0            950 ( 0.03%) 0          0                       }
   623 ( 0.01%)     3 ( 0.00%)  0              0          0          0            208 ( 0.01%) 0          0                       if parts.is_empty() {
     .              .           .              .          .          .              .          .          .                           continue
     .              .           .              .          .          .              .          .          .                       }
   206 ( 0.00%)     0           0              0          0          0            103 ( 0.00%) 0          0                       let mut line = build_line();
 2,678 ( 0.03%)    87 ( 0.06%)  3 ( 0.04%)   206 ( 0.01%) 0          0          1,236 ( 0.04%) 0          0                       line.command = parts[0].parse().unwrap();
   412 ( 0.00%)     1 ( 0.00%)  0              0          0          0            206 ( 0.01%) 0          0                       let args = parts.split_off(1);
   206 ( 0.00%)     0           0              0          0          0            103 ( 0.00%) 0          0                       let mut args_smart: Vec<smartstring::alias::String> = vec![];
 6,323 ( 0.07%)   290 ( 0.20%)  5 ( 0.07%) 1,480 ( 0.06%) 0          0          1,789 ( 0.06%) 0          0                       for arg in args {
 2,024 ( 0.02%)     0           0              0          0          0          1,265 ( 0.04%) 0          0                           args_smart.push(arg.parse().unwrap());
 1,218 ( 0.01%)    31 ( 0.02%)  1 ( 0.01%)     0          0          0            356 ( 0.01%) 0          0                       }
 1,339 ( 0.01%)   206 ( 0.14%)  2 ( 0.03%)   412 ( 0.02%) 0          0            721 ( 0.02%) 0          0                       line.args = args_smart;
 1,133 ( 0.01%)   109 ( 0.08%)  1 ( 0.01%)   309 ( 0.01%) 0          0            618 ( 0.02%) 0          0                       self.lines.push(line);
   723 ( 0.01%)   103 ( 0.07%)  1 ( 0.01%)     0          0          0            516 ( 0.02%) 0          0                   }
     3 ( 0.00%)     0           0              1 ( 0.00%) 1 ( 0.02%) 0              1 ( 0.00%) 0          0               }
     .              .           .              .          .          .              .          .          .           }
     .              .           .              .          .          .              .          .          .           
     3 ( 0.00%)     1 ( 0.00%)  1 ( 0.01%)     0          0          0              2 ( 0.00%) 0          0           pub fn build_syntax_tree() -> SyntaxTree {
     6 ( 0.00%)     0           0              3 ( 0.00%) 0          0              3 ( 0.00%) 1 ( 0.02%) 0               SyntaxTree {
     4 ( 0.00%)     1 ( 0.00%)  1 ( 0.01%)     2 ( 0.00%) 0          0              1 ( 0.00%) 0          0                   lines: Vec::new(),
     .              .           .              .          .          .              .          .          .               }
     2 ( 0.00%)     0           0              1 ( 0.00%) 0          0              0          0          0           }
12,984 ( 0.14%) 1,506 ( 1.04%) 14 ( 0.20%) 5,972 ( 0.25%) 0          0              0          0          0           <counts for unidentified lines in /home/ashy5000/dev/cryptocurrency/contracts/src/syntax_tree.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/ashy5000/.cargo/registry/src/index.crates.io-6f17d22bba15001f/smartstring-1.0.1/src/lib.rs
--------------------------------------------------------------------------------
Ir              I1mr         ILmr        Dr              D1mr       DLmr       Dw              D1mw        DLmw       

 9,161 ( 0.10%) 133 ( 0.09%)  1 ( 0.01%)      0          0          0               0           0          0           // This Source Code Form is subject to the terms of the Mozilla Public
     .            .           .               .          .          .               .           .          .           // License, v. 2.0. If a copy of the MPL was not distributed with this
     .            .           .               .          .          .               .           .          .           // file, You can obtain one at http://mozilla.org/MPL/2.0/.
     .            .           .               .          .          .               .           .          .           
     .            .           .               .          .          .               .           .          .           //! # Smart String
     .            .           .               .          .          .               .           .          .           //!
     .            .           .               .          .          .               .           .          .           //! [`SmartString`] is a wrapper around [`String`] which offers
     .            .           .               .          .          .               .           .          .           //! automatic inlining of small strings. It comes in two flavours:
     .            .           .               .          .          .               .           .          .           //! [`LazyCompact`], which takes up exactly as much space as a [`String`]
-- line 9 ----------------------------------------
-- line 189 ----------------------------------------
     .            .           .               .          .          .               .           .          .           /// one - not without also storing that state in the inline representation, which
     .            .           .               .          .          .               .           .          .           /// would waste precious bytes for inline string data.
     .            .           .               .          .          .               .           .          .           pub struct SmartString<Mode: SmartStringMode> {
     .            .           .               .          .          .               .           .          .               data: MaybeUninit<InlineString>,
     .            .           .               .          .          .               .           .          .               mode: PhantomData<Mode>,
     .            .           .               .          .          .               .           .          .           }
     .            .           .               .          .          .               .           .          .           
     .            .           .               .          .          .               .           .          .           impl<Mode: SmartStringMode> Drop for SmartString<Mode> {
 4,462 ( 0.05%) 208 ( 0.14%)  1 ( 0.01%)      0          0          0           2,231 ( 0.07%)  0          0               fn drop(&mut self) {
11,181 ( 0.12%)  46 ( 0.03%)  1 ( 0.01%)  2,244 ( 0.09%) 0          0           6,706 ( 0.21%)  0          0                   if let StringCastMut::Boxed(string) = self.cast_mut() {
     .            .           .               .          .          .               .           .          .                       #[allow(unsafe_code)]
     .            .           .               .          .          .               .           .          .                       unsafe {
    13 ( 0.00%)   0           0              13 ( 0.00%) 1 ( 0.02%) 0              13 ( 0.00%)  0          0                           drop_in_place(string)
     .            .           .               .          .          .               .           .          .                       };
     .            .           .               .          .          .               .           .          .                   }
 4,462 ( 0.05%)   0           0           2,231 ( 0.09%) 0          0               0           0          0               }
     .            .           .               .          .          .               .           .          .           }
     .            .           .               .          .          .               .           .          .           
     .            .           .               .          .          .               .           .          .           impl<Mode: SmartStringMode> Clone for SmartString<Mode> {
     .            .           .               .          .          .               .           .          .               /// Clone a [`SmartString`].
     .            .           .               .          .          .               .           .          .               ///
     .            .           .               .          .          .               .           .          .               /// If the string is inlined, this is a [`Copy`] operation. Otherwise,
     .            .           .               .          .          .               .           .          .               /// a string with the same capacity as the source is allocated.
 2,298 ( 0.02%)  32 ( 0.02%)  1 ( 0.01%)      0          0          0           1,149 ( 0.04%)  0          0               fn clone(&self) -> Self {
 2,298 ( 0.02%)   0           0               0          0          0           2,298 ( 0.07%)  0          0                   match self.cast() {
     6 ( 0.00%)   0           0               6 ( 0.00%) 0          0               0           0          0                       StringCast::Boxed(string) => Self::from_boxed(string.clone()),
 1,143 ( 0.01%)   0           0           1,143 ( 0.05%) 0          0               0           0          0                       StringCast::Inline(string) => Self::from_inline(*string),
     .            .           .               .          .          .               .           .          .                   }
 2,298 ( 0.02%)   0           0           1,149 ( 0.05%) 0          0               0           0          0               }
     .            .           .               .          .          .               .           .          .           }
     .            .           .               .          .          .               .           .          .           
     .            .           .               .          .          .               .           .          .           impl<Mode: SmartStringMode> Deref for SmartString<Mode> {
     .            .           .               .          .          .               .           .          .               type Target = str;
     .            .           .               .          .          .               .           .          .           
     .            .           .               .          .          .               .           .          .               #[inline(always)]
     .            .           .               .          .          .               .           .          .               fn deref(&self) -> &Self::Target {
12,943 ( 0.14%) 143 ( 0.10%)  7 ( 0.10%)  4,297 ( 0.18%) 0          0           6,498 ( 0.21%)  6 ( 0.11%) 1 ( 0.02%)          match self.cast() {
    28 ( 0.00%)   1 ( 0.00%)  1 ( 0.01%)     10 ( 0.00%) 0          0              18 ( 0.00%)  0          0                       StringCast::Boxed(string) => string.deref(),
 4,387 ( 0.05%)  40 ( 0.03%)  5 ( 0.07%)  2,142 ( 0.09%) 0          0           2,211 ( 0.07%)  4 ( 0.08%) 1 ( 0.02%)              StringCast::Inline(string) => string.deref(),
     .            .           .               .          .          .               .           .          .                   }
     1 ( 0.00%)   0           0               0          0          0               0           0          0               }
     .            .           .               .          .          .               .           .          .           }
     .            .           .               .          .          .               .           .          .           
     .            .           .               .          .          .               .           .          .           impl<Mode: SmartStringMode> DerefMut for SmartString<Mode> {
     .            .           .               .          .          .               .           .          .               #[inline(always)]
     .            .           .               .          .          .               .           .          .               fn deref_mut(&mut self) -> &mut Self::Target {
     .            .           .               .          .          .               .           .          .                   match self.cast_mut() {
     .            .           .               .          .          .               .           .          .                       StringCastMut::Boxed(string) => string.deref_mut(),
     .            .           .               .          .          .               .           .          .                       StringCastMut::Inline(string) => string.deref_mut(),
-- line 237 ----------------------------------------
-- line 268 ----------------------------------------
     .            .           .               .          .          .               .           .          .                   }
     .            .           .               .          .          .               .           .          .               }
     .            .           .               .          .          .               .           .          .           }
     .            .           .               .          .          .               .           .          .           
     .            .           .               .          .          .               .           .          .           impl<Mode: SmartStringMode> SmartString<Mode> {
     .            .           .               .          .          .               .           .          .               /// Construct an empty string.
     .            .           .               .          .          .               .           .          .               #[inline(always)]
     .            .           .               .          .          .               .           .          .               pub fn new() -> Self {
 2,020 ( 0.02%)   0           0               0          0          0             594 ( 0.02%)  0          0                   Self::from_inline(InlineString::new())
   594 ( 0.01%)   0           0               0          0          0               0           0          0               }
     .            .           .               .          .          .               .           .          .           
    20 ( 0.00%)  10 ( 0.01%)  1 ( 0.01%)      0          0          0              10 ( 0.00%)  0          0               fn from_boxed(boxed: BoxedString) -> Self {
    10 ( 0.00%)   0           0               0          0          0              10 ( 0.00%)  0          0                   let mut out = Self {
     .            .           .               .          .          .               .           .          .                       data: MaybeUninit::uninit(),
     .            .           .               .          .          .               .           .          .                       mode: PhantomData,
     .            .           .               .          .          .               .           .          .                   };
    20 ( 0.00%)   0           0               0          0          0              10 ( 0.00%)  0          0                   let data_ptr: *mut BoxedString = out.data.as_mut_ptr().cast();
     .            .           .               .          .          .               .           .          .                   #[allow(unsafe_code)]
     .            .           .               .          .          .               .           .          .                   unsafe {
    30 ( 0.00%)   0           0              10 ( 0.00%) 0          0              20 ( 0.00%)  0          0                       data_ptr.write(boxed)
     .            .           .               .          .          .               .           .          .                   };
    60 ( 0.00%)   5 ( 0.00%)  1 ( 0.01%)     30 ( 0.00%) 0          0              30 ( 0.00%)  1 ( 0.02%) 0                   out
    20 ( 0.00%)   0           0              10 ( 0.00%) 0          0               0           0          0               }
     .            .           .               .          .          .               .           .          .           
 2,221 ( 0.02%)  90 ( 0.06%)  0               0          0          0               0           0          0               fn from_inline(inline: InlineString) -> Self {
13,326 ( 0.14%)  14 ( 0.01%)  0           6,663 ( 0.27%) 0          0           6,663 ( 0.21%) 53 ( 1.00%) 6 ( 0.14%)          Self {
13,326 ( 0.14%)   0           0           6,663 ( 0.27%) 0          0           6,663 ( 0.21%)  0          0                       data: MaybeUninit::new(inline),
     .            .           .               .          .          .               .           .          .                       mode: PhantomData,
     .            .           .               .          .          .               .           .          .                   }
 2,221 ( 0.02%)   0           0           2,221 ( 0.09%) 0          0               0           0          0               }
     .            .           .               .          .          .               .           .          .           
25,158 ( 0.27%)  26 ( 0.02%)  1 ( 0.01%)      0          0          0          16,772 ( 0.53%)  0          0               fn discriminant(&self) -> Discriminant {
     .            .           .               .          .          .               .           .          .                   // unsafe { self.data.assume_init() }.marker.discriminant()
     .            .           .               .          .          .               .           .          .                   let str_ptr: *const BoxedString =
 8,386 ( 0.09%)   0           0               0          0          0           8,386 ( 0.27%)  0          0                       self.data.as_ptr().cast() as *const _ as *const BoxedString;
     .            .           .               .          .          .               .           .          .                   #[allow(unsafe_code)]
 8,386 ( 0.09%)   0           0           8,386 ( 0.34%) 1 ( 0.02%) 0           8,386 ( 0.27%)  0          0                   Discriminant::from_bit(BoxedString::check_alignment(unsafe { &*str_ptr }))
33,544 ( 0.35%)   0           0           8,386 ( 0.34%) 0          0               0           0          0               }
     .            .           .               .          .          .               .           .          .           
 6,670 ( 0.07%)  38 ( 0.03%)  1 ( 0.01%)      0          0          0           3,335 ( 0.11%)  0          0               fn cast(&self) -> StringCast<'_> {
     .            .           .               .          .          .               .           .          .                   #[allow(unsafe_code)]
 6,670 ( 0.07%)   0           0               0          0          0           3,335 ( 0.11%)  0          0                   match self.discriminant() {
 3,322 ( 0.04%)   0           0               0          0          0           3,322 ( 0.11%)  0          0                       Discriminant::Inline => StringCast::Inline(unsafe { &*self.data.as_ptr() }),
    13 ( 0.00%)   0           0               0          0          0              13 ( 0.00%)  0          0                       Discriminant::Boxed => StringCast::Boxed(unsafe { &*self.data.as_ptr().cast() }),
     .            .           .               .          .          .               .           .          .                   }
 3,335 ( 0.04%)   0           0           3,335 ( 0.14%) 0          0               0           0          0               }
     .            .           .               .          .          .               .           .          .           
10,096 ( 0.11%)  98 ( 0.07%)  1 ( 0.01%)      0          0          0           5,048 ( 0.16%)  0          0               fn cast_mut(&mut self) -> StringCastMut<'_> {
     .            .           .               .          .          .               .           .          .                   #[allow(unsafe_code)]
10,096 ( 0.11%)   0           0               0          0          0           5,048 ( 0.16%)  0          0                   match self.discriminant() {
 9,930 ( 0.10%)   0           0               0          0          0           9,930 ( 0.31%)  0          0                       Discriminant::Inline => StringCastMut::Inline(unsafe { &mut *self.data.as_mut_ptr() }),
     .            .           .               .          .          .               .           .          .                       Discriminant::Boxed => {
   166 ( 0.00%)   0           0               0          0          0             166 ( 0.01%)  0          0                           StringCastMut::Boxed(unsafe { &mut *self.data.as_mut_ptr().cast() })
    83 ( 0.00%)   0           0               0          0          0               0           0          0                       }
     .            .           .               .          .          .               .           .          .                   }
10,096 ( 0.11%) 172 ( 0.12%)  1 ( 0.01%) 10,096 ( 0.42%) 0          0               0           0          0               }
     .            .           .               .          .          .               .           .          .           
     .            .           .               .          .          .               .           .          .               fn cast_into(mut self) -> StringCastInto {
     .            .           .               .          .          .               .           .          .                   #[allow(unsafe_code)]
     .            .           .               .          .          .               .           .          .                   match self.discriminant() {
     .            .           .               .          .          .               .           .          .                       Discriminant::Inline => StringCastInto::Inline(unsafe { self.data.assume_init() }),
     .            .           .               .          .          .               .           .          .                       Discriminant::Boxed => StringCastInto::Boxed(unsafe {
     .            .           .               .          .          .               .           .          .                           let boxed_ptr: *mut BoxedString = self.data.as_mut_ptr().cast();
     .            .           .               .          .          .               .           .          .                           let string = boxed_ptr.read();
     .            .           .               .          .          .               .           .          .                           forget(self);
     .            .           .               .          .          .               .           .          .                           string
     .            .           .               .          .          .               .           .          .                       }),
     .            .           .               .          .          .               .           .          .                   }
     .            .           .               .          .          .               .           .          .               }
     .            .           .               .          .          .               .           .          .           
    12 ( 0.00%)   0           0               0          0          0               9 ( 0.00%)  0          0               fn promote_from(&mut self, string: BoxedString) {
    24 ( 0.00%)   0           0               0          0          0              12 ( 0.00%)  0          0                   debug_assert!(self.discriminant() == Discriminant::Inline);
     3 ( 0.00%)   0           0               0          0          0               3 ( 0.00%)  0          0                   let data: *mut BoxedString = self.data.as_mut_ptr().cast();
     .            .           .               .          .          .               .           .          .                   #[allow(unsafe_code)]
     .            .           .               .          .          .               .           .          .                   unsafe {
     3 ( 0.00%)   0           0               0          0          0               3 ( 0.00%)  0          0                       data.write(string)
     .            .           .               .          .          .               .           .          .                   };
     .            .           .               .          .          .               .           .          .               }
     .            .           .               .          .          .               .           .          .           
     .            .           .               .          .          .               .           .          .               /// Attempt to inline the string if it's currently heap allocated.
     .            .           .               .          .          .               .           .          .               ///
     .            .           .               .          .          .               .           .          .               /// Returns the resulting state: `true` if it's inlined, `false` if it's not.
     .            .           .               .          .          .               .           .          .               fn try_demote(&mut self) -> bool {
     .            .           .               .          .          .               .           .          .                   if Mode::DEALLOC {
-- line 351 ----------------------------------------
-- line 373 ----------------------------------------
     .            .           .               .          .          .               .           .          .                   } else {
     .            .           .               .          .          .               .           .          .                       true
     .            .           .               .          .          .               .           .          .                   }
     .            .           .               .          .          .               .           .          .               }
     .            .           .               .          .          .               .           .          .           
     .            .           .               .          .          .               .           .          .               /// Return the length in bytes of the string.
     .            .           .               .          .          .               .           .          .               ///
     .            .           .               .          .          .               .           .          .               /// Note that this may differ from the length in `char`s.
    37 ( 0.00%)  27 ( 0.02%)  1 ( 0.01%)      0          0          0               0           0          0               pub fn len(&self) -> usize {
    37 ( 0.00%)   0           0               0          0          0              37 ( 0.00%)  0          0                   match self.cast() {
     .            .           .               .          .          .               .           .          .                       StringCast::Boxed(string) => string.len(),
     .            .           .               .          .          .               .           .          .                       StringCast::Inline(string) => string.len(),
     .            .           .               .          .          .               .           .          .                   }
     .            .           .               .          .          .               .           .          .               }
     .            .           .               .          .          .               .           .          .           
     .            .           .               .          .          .               .           .          .               /// Test whether the string is empty.
     .            .           .               .          .          .               .           .          .               pub fn is_empty(&self) -> bool {
     .            .           .               .          .          .               .           .          .                   self.len() == 0
-- line 390 ----------------------------------------
-- line 391 ----------------------------------------
     .            .           .               .          .          .               .           .          .               }
     .            .           .               .          .          .               .           .          .           
     .            .           .               .          .          .               .           .          .               /// Test whether the string is currently inlined.
     .            .           .               .          .          .               .           .          .               pub fn is_inline(&self) -> bool {
     .            .           .               .          .          .               .           .          .                   self.discriminant() == Discriminant::Inline
     .            .           .               .          .          .               .           .          .               }
     .            .           .               .          .          .               .           .          .           
     .            .           .               .          .          .               .           .          .               /// Get a reference to the string as a string slice.
 6,336 ( 0.07%) 114 ( 0.08%)  1 ( 0.01%)      0          0          0           4,224 ( 0.13%)  0          0               pub fn as_str(&self) -> &str {
     .            .           .               .          .          .               .           .          .                   self.deref()
 2,112 ( 0.02%)   0           0               0          0          0               0           0          0               }
     .            .           .               .          .          .               .           .          .           
     .            .           .               .          .          .               .           .          .               /// Get a reference to the string as a mutable string slice.
     .            .           .               .          .          .               .           .          .               pub fn as_mut_str(&mut self) -> &mut str {
     .            .           .               .          .          .               .           .          .                   self.deref_mut()
     .            .           .               .          .          .               .           .          .               }
     .            .           .               .          .          .               .           .          .           
     .            .           .               .          .          .               .           .          .               /// Return the currently allocated capacity of the string.
     .            .           .               .          .          .               .           .          .               ///
-- line 409 ----------------------------------------
-- line 417 ----------------------------------------
     .            .           .               .          .          .               .           .          .                   if let StringCast::Boxed(string) = self.cast() {
     .            .           .               .          .          .               .           .          .                       string.capacity()
     .            .           .               .          .          .               .           .          .                   } else {
     .            .           .               .          .          .               .           .          .                       MAX_INLINE
     .            .           .               .          .          .               .           .          .                   }
     .            .           .               .          .          .               .           .          .               }
     .            .           .               .          .          .               .           .          .           
     .            .           .               .          .          .               .           .          .               /// Push a character to the end of the string.
 2,817 ( 0.03%)  24 ( 0.02%)  0               0          0          0               0           0          0               pub fn push(&mut self, ch: char) {
     .            .           .               .          .          .               .           .          .                   string_op_grow!(ops::Push, self, ch)
 5,634 ( 0.06%)   0           0           2,817 ( 0.12%) 0          0               0           0          0               }
     .            .           .               .          .          .               .           .          .           
     .            .           .               .          .          .               .           .          .               /// Copy a string slice onto the end of the string.
     .            .           .               .          .          .               .           .          .               pub fn push_str(&mut self, string: &str) {
     .            .           .               .          .          .               .           .          .                   string_op_grow!(ops::PushStr, self, string)
     .            .           .               .          .          .               .           .          .               }
     .            .           .               .          .          .               .           .          .           
     .            .           .               .          .          .               .           .          .               /// Shrink the capacity of the string to fit its contents exactly.
     .            .           .               .          .          .               .           .          .               ///
-- line 435 ----------------------------------------
-- line 543 ----------------------------------------
     .            .           .               .          .          .               .           .          .           
     .            .           .               .          .          .               .           .          .           impl<Mode: SmartStringMode> AsMut<str> for SmartString<Mode> {
     .            .           .               .          .          .               .           .          .               fn as_mut(&mut self) -> &mut str {
     .            .           .               .          .          .               .           .          .                   self.deref_mut()
     .            .           .               .          .          .               .           .          .               }
     .            .           .               .          .          .               .           .          .           }
     .            .           .               .          .          .               .           .          .           
     .            .           .               .          .          .               .           .          .           impl<Mode: SmartStringMode> AsRef<[u8]> for SmartString<Mode> {
    38 ( 0.00%)  13 ( 0.01%)  1 ( 0.01%)      0          0          0              19 ( 0.00%)  0          0               fn as_ref(&self) -> &[u8] {
     .            .           .               .          .          .               .           .          .                   self.deref().as_bytes()
    38 ( 0.00%)   0           0              19 ( 0.00%) 0          0               0           0          0               }
     .            .           .               .          .          .               .           .          .           }
     .            .           .               .          .          .               .           .          .           
     .            .           .               .          .          .               .           .          .           impl<Mode: SmartStringMode> Borrow<str> for SmartString<Mode> {
     .            .           .               .          .          .               .           .          .               fn borrow(&self) -> &str {
     .            .           .               .          .          .               .           .          .                   self.deref()
     .            .           .               .          .          .               .           .          .               }
     .            .           .               .          .          .               .           .          .           }
     .            .           .               .          .          .               .           .          .           
-- line 561 ----------------------------------------
-- line 639 ----------------------------------------
     .            .           .               .          .          .               .           .          .           
     .            .           .               .          .          .               .           .          .           impl<Mode: SmartStringMode> IndexMut<RangeToInclusive<usize>> for SmartString<Mode> {
     .            .           .               .          .          .               .           .          .               fn index_mut(&mut self, index: RangeToInclusive<usize>) -> &mut Self::Output {
     .            .           .               .          .          .               .           .          .                   &mut self.deref_mut()[index]
     .            .           .               .          .          .               .           .          .               }
     .            .           .               .          .          .               .           .          .           }
     .            .           .               .          .          .               .           .          .           
     .            .           .               .          .          .               .           .          .           impl<Mode: SmartStringMode> From<&'_ str> for SmartString<Mode> {
   976 ( 0.01%) 103 ( 0.07%)  0               0          0          0             488 ( 0.02%)  0          0               fn from(string: &'_ str) -> Self {
   488 ( 0.01%)   0           0               0          0          0             488 ( 0.02%)  0          0                   if string.len() > MAX_INLINE {
     4 ( 0.00%)   0           0               0          0          0               0           0          0                       Self::from_boxed(string.to_string().into())
     .            .           .               .          .          .               .           .          .                   } else {
   484 ( 0.01%)   0           0               0          0          0               0           0          0                       Self::from_inline(string.into())
     .            .           .               .          .          .               .           .          .                   }
   488 ( 0.01%)   0           0               0          0          0               0           0          0               }
     .            .           .               .          .          .               .           .          .           }
     .            .           .               .          .          .               .           .          .           
     .            .           .               .          .          .               .           .          .           impl<Mode: SmartStringMode> From<&'_ mut str> for SmartString<Mode> {
     .            .           .               .          .          .               .           .          .               fn from(string: &'_ mut str) -> Self {
     .            .           .               .          .          .               .           .          .                   if string.len() > MAX_INLINE {
     .            .           .               .          .          .               .           .          .                       Self::from_boxed(string.to_string().into())
     .            .           .               .          .          .               .           .          .                   } else {
     .            .           .               .          .          .               .           .          .                       Self::from_inline(string.deref().into())
-- line 661 ----------------------------------------
-- line 844 ----------------------------------------
     .            .           .               .          .          .               .           .          .               fn from_iter<I: IntoIterator<Item = &'a String>>(iter: I) -> Self {
     .            .           .               .          .          .               .           .          .                   let mut out = Self::new();
     .            .           .               .          .          .               .           .          .                   out.extend(iter.into_iter());
     .            .           .               .          .          .               .           .          .                   out
     .            .           .               .          .          .               .           .          .               }
     .            .           .               .          .          .               .           .          .           }
     .            .           .               .          .          .               .           .          .           
     .            .           .               .          .          .               .           .          .           impl<Mode: SmartStringMode> FromIterator<char> for SmartString<Mode> {
 2,376 ( 0.03%) 446 ( 0.31%)  2 ( 0.03%)      0          0          0           1,782 ( 0.06%)  0          0               fn from_iter<I: IntoIterator<Item = char>>(iter: I) -> Self {
 1,188 ( 0.01%) 356 ( 0.25%)  1 ( 0.01%)      0          0          0           1,188 ( 0.04%)  0          0                   let mut out = Self::new();
30,783 ( 0.32%) 261 ( 0.18%)  4 ( 0.06%)  6,375 ( 0.26%) 0          0          14,267 ( 0.45%)  0          0                   for ch in iter {
 4,229 ( 0.04%) 198 ( 0.14%)  2 ( 0.03%)      0          0          0             706 ( 0.02%)  0          0                       out.push(ch);
   594 ( 0.01%)   0           0               0          0          0               0           0          0                   }
 2,850 ( 0.03%)   1 ( 0.00%)  0           1,544 ( 0.06%) 0          0           1,306 ( 0.04%)  0          0                   out
   950 ( 0.01%)   0           0             356 ( 0.01%) 0          0               0           0          0               }
     .            .           .               .          .          .               .           .          .           }
     .            .           .               .          .          .               .           .          .           
     .            .           .               .          .          .               .           .          .           impl<Mode: SmartStringMode> FromStr for SmartString<Mode> {
     .            .           .               .          .          .               .           .          .               type Err = Infallible;
     .            .           .               .          .          .               .           .          .               fn from_str(s: &str) -> Result<Self, Self::Err> {
   372 ( 0.00%)   0           0               0          0          0               0           0          0                   Ok(Self::from(s))
   372 ( 0.00%)   0           0               0          0          0               0           0          0               }
     .            .           .               .          .          .               .           .          .           }
     .            .           .               .          .          .               .           .          .           
     .            .           .               .          .          .               .           .          .           impl<Mode: SmartStringMode> From<SmartString<Mode>> for String {
     .            .           .               .          .          .               .           .          .               /// Unwrap a boxed [`String`][String], or copy an inline string into a new [`String`][String].
     .            .           .               .          .          .               .           .          .               ///
     .            .           .               .          .          .               .           .          .               /// [String]: https://doc.rust-lang.org/std/string/struct.String.html
     .            .           .               .          .          .               .           .          .               fn from(s: SmartString<Mode>) -> Self {
     .            .           .               .          .          .               .           .          .                   match s.cast_into() {
-- line 873 ----------------------------------------
-- line 879 ----------------------------------------
     .            .           .               .          .          .               .           .          .           
     .            .           .               .          .          .               .           .          .           impl<Mode: SmartStringMode> PartialEq<str> for SmartString<Mode> {
     .            .           .               .          .          .               .           .          .               fn eq(&self, other: &str) -> bool {
     .            .           .               .          .          .               .           .          .                   self.as_str() == other
     .            .           .               .          .          .               .           .          .               }
     .            .           .               .          .          .               .           .          .           }
     .            .           .               .          .          .               .           .          .           
     .            .           .               .          .          .               .           .          .           impl<Mode: SmartStringMode> PartialEq<&'_ str> for SmartString<Mode> {
 1,068 ( 0.01%)  11 ( 0.01%)  0               0          0          0             712 ( 0.02%)  0          0               fn eq(&self, other: &&str) -> bool {
   712 ( 0.01%)   0           0             356 ( 0.01%) 0          0             356 ( 0.01%)  0          0                   self.as_str() == *other
 1,424 ( 0.02%)   0           0             356 ( 0.01%) 0          0               0           0          0               }
     .            .           .               .          .          .               .           .          .           }
     .            .           .               .          .          .               .           .          .           
     .            .           .               .          .          .               .           .          .           impl<Mode: SmartStringMode> PartialEq<SmartString<Mode>> for &'_ str {
     .            .           .               .          .          .               .           .          .               fn eq(&self, other: &SmartString<Mode>) -> bool {
     .            .           .               .          .          .               .           .          .                   other.eq(*self)
     .            .           .               .          .          .               .           .          .               }
     .            .           .               .          .          .               .           .          .           }
     .            .           .               .          .          .               .           .          .           
-- line 897 ----------------------------------------
-- line 909 ----------------------------------------
     .            .           .               .          .          .               .           .          .           
     .            .           .               .          .          .               .           .          .           impl<Mode: SmartStringMode> PartialEq<SmartString<Mode>> for String {
     .            .           .               .          .          .               .           .          .               fn eq(&self, other: &SmartString<Mode>) -> bool {
     .            .           .               .          .          .               .           .          .                   other.eq(self.as_str())
     .            .           .               .          .          .               .           .          .               }
     .            .           .               .          .          .               .           .          .           }
     .            .           .               .          .          .               .           .          .           
     .            .           .               .          .          .               .           .          .           impl<Mode: SmartStringMode> PartialEq for SmartString<Mode> {
 1,740 ( 0.02%)  58 ( 0.04%)  1 ( 0.01%)      0          0          0           1,305 ( 0.04%)  0          0               fn eq(&self, other: &Self) -> bool {
 1,305 ( 0.01%)   0           0             435 ( 0.02%) 0          0             870 ( 0.03%)  0          0                   self.as_str() == other.as_str()
 1,305 ( 0.01%)   0           0               0          0          0               0           0          0               }
     .            .           .               .          .          .               .           .          .           }
     .            .           .               .          .          .               .           .          .           
     .            .           .               .          .          .               .           .          .           impl<Mode: SmartStringMode> Eq for SmartString<Mode> {}
     .            .           .               .          .          .               .           .          .           
     .            .           .               .          .          .               .           .          .           impl<Mode: SmartStringMode> PartialOrd<str> for SmartString<Mode> {
     .            .           .               .          .          .               .           .          .               fn partial_cmp(&self, other: &str) -> Option<Ordering> {
     .            .           .               .          .          .               .           .          .                   self.as_str().partial_cmp(other)
     .            .           .               .          .          .               .           .          .               }
-- line 927 ----------------------------------------
-- line 935 ----------------------------------------
     .            .           .               .          .          .               .           .          .           
     .            .           .               .          .          .               .           .          .           impl<Mode: SmartStringMode> Ord for SmartString<Mode> {
     .            .           .               .          .          .               .           .          .               fn cmp(&self, other: &Self) -> Ordering {
     .            .           .               .          .          .               .           .          .                   self.as_str().cmp(other.as_str())
     .            .           .               .          .          .               .           .          .               }
     .            .           .               .          .          .               .           .          .           }
     .            .           .               .          .          .               .           .          .           
     .            .           .               .          .          .               .           .          .           impl<Mode: SmartStringMode> Hash for SmartString<Mode> {
   500 ( 0.01%)   4 ( 0.00%)  0               0          0          0               0           0          0               fn hash<H: Hasher>(&self, state: &mut H) {
   500 ( 0.01%)   0           0               0          0          0             500 ( 0.02%)  0          0                   self.as_str().hash(state)
   500 ( 0.01%)   0           0               0          0          0               0           0          0               }
     .            .           .               .          .          .               .           .          .           }
     .            .           .               .          .          .               .           .          .           
     .            .           .               .          .          .               .           .          .           impl<Mode: SmartStringMode> Debug for SmartString<Mode> {
     .            .           .               .          .          .               .           .          .               fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error> {
     .            .           .               .          .          .               .           .          .                   Debug::fmt(self.as_str(), f)
     .            .           .               .          .          .               .           .          .               }
     .            .           .               .          .          .               .           .          .           }
     .            .           .               .          .          .               .           .          .           
-- line 953 ----------------------------------------

34,707 ( 0.37%) 642 ( 0.45%) 12 ( 0.17%) 24,848 ( 1.02%) 0          0           5,063 ( 0.16%)  0          0           <counts for unidentified lines in /home/ashy5000/.cargo/registry/src/index.crates.io-6f17d22bba15001f/smartstring-1.0.1/src/lib.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/ashy5000/dev/cryptocurrency/contracts/target/debug/build/tikv-jemalloc-sys-7365f40ecb99e085/out/build/include/jemalloc/internal/arena_inlines_b.h
--------------------------------------------------------------------------------
Ir              I1mr         ILmr       Dr             D1mr       DLmr       Dw             D1mw        DLmw       

-- line 7 ----------------------------------------
     .            .          .              .          .          .              .           .          .           #include "jemalloc/internal/mutex.h"
     .            .          .              .          .          .              .           .          .           #include "jemalloc/internal/rtree.h"
     .            .          .              .          .          .              .           .          .           #include "jemalloc/internal/safety_check.h"
     .            .          .              .          .          .              .           .          .           #include "jemalloc/internal/sc.h"
     .            .          .              .          .          .              .           .          .           #include "jemalloc/internal/sz.h"
     .            .          .              .          .          .              .           .          .           #include "jemalloc/internal/ticker.h"
     .            .          .              .          .          .              .           .          .           
     .            .          .              .          .          .              .           .          .           static inline arena_t *
   476 ( 0.01%)   5 ( 0.00%) 0             68 ( 0.00%) 0          0            204 ( 0.01%)  0          0           arena_get_from_edata(edata_t *edata) {
   748 ( 0.01%)   3 ( 0.00%) 1 ( 0.01%)   136 ( 0.01%) 0          0            272 ( 0.01%)  0          0           	return (arena_t *)atomic_load_p(&arenas[edata_arena_ind_get(edata)],
     .            .          .              .          .          .              .           .          .           	    ATOMIC_RELAXED);
   340 ( 0.00%)   3 ( 0.00%) 1 ( 0.01%)   272 ( 0.01%) 0          0              0           0          0           }
     .            .          .              .          .          .              .           .          .           
     .            .          .              .          .          .              .           .          .           JEMALLOC_ALWAYS_INLINE arena_t *
     .            .          .              .          .          .              .           .          .           arena_choose_maybe_huge(tsd_t *tsd, arena_t *arena, size_t size) {
     2 ( 0.00%)   0          0              1 ( 0.00%) 0          0              0           0          0           	if (arena != NULL) {
     2 ( 0.00%)   0          0              1 ( 0.00%) 0          0              0           0          0           		return arena;
     .            .          .              .          .          .              .           .          .           	}
     .            .          .              .          .          .              .           .          .           
     .            .          .              .          .          .              .           .          .           	/*
     .            .          .              .          .          .              .           .          .           	 * For huge allocations, use the dedicated huge arena if both are true:
     .            .          .              .          .          .              .           .          .           	 * 1) is using auto arena selection (i.e. arena == NULL), and 2) the
     .            .          .              .          .          .              .           .          .           	 * thread is not assigned to a manual arena.
     .            .          .              .          .          .              .           .          .           	 */
     .            .          .              .          .          .              .           .          .           	if (unlikely(size >= oversize_threshold)) {
-- line 31 ----------------------------------------
-- line 70 ----------------------------------------
     .            .          .              .          .          .              .           .          .           		 */
     .            .          .              .          .          .              .           .          .           	}
     .            .          .              .          .          .              .           .          .           }
     .            .          .              .          .          .              .           .          .           
     .            .          .              .          .          .              .           .          .           JEMALLOC_ALWAYS_INLINE void
     .            .          .              .          .          .              .           .          .           arena_prof_tctx_reset(tsd_t *tsd, const void *ptr,
     .            .          .              .          .          .              .           .          .               emap_alloc_ctx_t *alloc_ctx) {
     .            .          .              .          .          .              .           .          .           	cassert(config_prof);
    39 ( 0.00%)   9 ( 0.01%) 0             12 ( 0.00%) 0          0              9 ( 0.00%)  0          0           	assert(ptr != NULL);
     .            .          .              .          .          .              .           .          .           
     .            .          .              .          .          .              .           .          .           	/* Static check. */
   117 ( 0.00%)   0          0             55 ( 0.00%) 0          0             62 ( 0.00%)  0          0           	if (alloc_ctx == NULL) {
    15 ( 0.00%)   0          0             10 ( 0.00%) 0          0              5 ( 0.00%)  0          0           		edata_t *edata = emap_edata_lookup(tsd_tsdn(tsd),
     .            .          .              .          .          .              .           .          .           		    &arena_emap_global, ptr);
    15 ( 0.00%)   5 ( 0.00%) 1 ( 0.01%)     5 ( 0.00%) 0          0             10 ( 0.00%)  0          0           		if (unlikely(!edata_slab_get(edata))) {
     5 ( 0.00%)   0          0              0          0          0              5 ( 0.00%)  0          0           			large_prof_tctx_reset(edata);
     .            .          .              .          .          .              .           .          .           		}
     .            .          .              .          .          .              .           .          .           	} else {
     5 ( 0.00%)   0          0              0          0          0              5 ( 0.00%)  0          0           		if (unlikely(!alloc_ctx->slab)) {
   585 ( 0.01%)   0          0            195 ( 0.01%) 0          0            390 ( 0.01%)  0          0           			edata_t *edata = emap_edata_lookup(tsd_tsdn(tsd),
     .            .          .              .          .          .              .           .          .           			    &arena_emap_global, ptr);
 2,287 ( 0.02%)   0          0          1,046 ( 0.04%) 0          0            195 ( 0.01%)  0          0           			large_prof_tctx_reset(edata);
     .            .          .              .          .          .              .           .          .           		}
     .            .          .              .          .          .              .           .          .           	}
 1,280 ( 0.01%)   0          0             15 ( 0.00%) 0          0          1,051 ( 0.03%)  0          0           }
     .            .          .              .          .          .              .           .          .           
     .            .          .              .          .          .              .           .          .           JEMALLOC_ALWAYS_INLINE void
     .            .          .              .          .          .              .           .          .           arena_prof_tctx_reset_sampled(tsd_t *tsd, const void *ptr) {
     .            .          .              .          .          .              .           .          .           	cassert(config_prof);
     .            .          .              .          .          .              .           .          .           	assert(ptr != NULL);
     .            .          .              .          .          .              .           .          .           
     .            .          .              .          .          .              .           .          .           	edata_t *edata = emap_edata_lookup(tsd_tsdn(tsd), &arena_emap_global,
     .            .          .              .          .          .              .           .          .           	    ptr);
-- line 102 ----------------------------------------
-- line 111 ----------------------------------------
     .            .          .              .          .          .              .           .          .           	cassert(config_prof);
     .            .          .              .          .          .              .           .          .           
     .            .          .              .          .          .              .           .          .           	assert(!edata_slab_get(edata));
     .            .          .              .          .          .              .           .          .           	large_prof_info_set(edata, tctx, size);
     .            .          .              .          .          .              .           .          .           }
     .            .          .              .          .          .              .           .          .           
     .            .          .              .          .          .              .           .          .           JEMALLOC_ALWAYS_INLINE void
     .            .          .              .          .          .              .           .          .           arena_decay_ticks(tsdn_t *tsdn, arena_t *arena, unsigned nticks) {
   445 ( 0.00%)   0          0             89 ( 0.00%) 0          0             89 ( 0.00%)  0          0           	if (unlikely(tsdn_null(tsdn))) {
     .            .          .              .          .          .              .           .          .           		return;
     .            .          .              .          .          .              .           .          .           	}
   445 ( 0.00%)  88 ( 0.06%) 2 ( 0.03%)   178 ( 0.01%) 0          0            267 ( 0.01%)  3 ( 0.06%) 3 ( 0.07%)  	tsd_t *tsd = tsdn_tsd(tsdn);
     .            .          .              .          .          .              .           .          .           	/*
     .            .          .              .          .          .              .           .          .           	 * We use the ticker_geom_t to avoid having per-arena state in the tsd.
     .            .          .              .          .          .              .           .          .           	 * Instead of having a countdown-until-decay timer running for every
     .            .          .              .          .          .              .           .          .           	 * arena in every thread, we flip a coin once per tick, whose
     .            .          .              .          .          .              .           .          .           	 * probability of coming up heads is 1/nticks; this is effectively the
     .            .          .              .          .          .              .           .          .           	 * operation of the ticker_geom_t.  Each arena has the same chance of a
     .            .          .              .          .          .              .           .          .           	 * coinflip coming up heads (1/ARENA_DECAY_NTICKS_PER_UPDATE), so we can
     .            .          .              .          .          .              .           .          .           	 * use a single ticker for all of them.
     .            .          .              .          .          .              .           .          .           	 */
   445 ( 0.00%)   0          0            178 ( 0.01%) 0          0            267 ( 0.01%)  0          0           	ticker_geom_t *decay_ticker = tsd_arena_decay_tickerp_get(tsd);
    89 ( 0.00%)   0          0              0          0          0             89 ( 0.00%)  1 ( 0.02%) 1 ( 0.02%)  	uint64_t *prng_state = tsd_prng_statep_get(tsd);
   801 ( 0.01%)  21 ( 0.01%) 2 ( 0.03%)   267 ( 0.01%) 0          0             89 ( 0.00%)  0          0           	if (unlikely(ticker_geom_ticks(decay_ticker, prng_state, nticks))) {
     .            .          .              .          .          .              .           .          .           		arena_decay(tsdn, arena, false, false);
     .            .          .              .          .          .              .           .          .           	}
     .            .          .              .          .          .              .           .          .           }
     .            .          .              .          .          .              .           .          .           
     .            .          .              .          .          .              .           .          .           JEMALLOC_ALWAYS_INLINE void
     .            .          .              .          .          .              .           .          .           arena_decay_tick(tsdn_t *tsdn, arena_t *arena) {
     .            .          .              .          .          .              .           .          .           	arena_decay_ticks(tsdn, arena, 1);
    89 ( 0.00%)   3 ( 0.00%) 1 ( 0.01%)     0          0          0              0           0          0           }
     .            .          .              .          .          .              .           .          .           
     .            .          .              .          .          .              .           .          .           JEMALLOC_ALWAYS_INLINE void *
     .            .          .              .          .          .              .           .          .           arena_malloc(tsdn_t *tsdn, arena_t *arena, size_t size, szind_t ind, bool zero,
     .            .          .              .          .          .              .           .          .               tcache_t *tcache, bool slow_path) {
   833 ( 0.01%)   0          0              0          0          0            643 ( 0.02%)  0          0           	assert(!tsdn_null(tsdn) || tcache == NULL);
     .            .          .              .          .          .              .           .          .           
 6,402 ( 0.07%) 149 ( 0.10%) 4 ( 0.06%) 1,877 ( 0.08%) 0          0          1,356 ( 0.04%)  0          0           	if (likely(tcache != NULL)) {
 5,926 ( 0.06%)  43 ( 0.03%) 2 ( 0.03%)   894 ( 0.04%) 0          0          3,285 ( 0.10%)  0          0           		if (likely(size <= SC_SMALL_MAXCLASS)) {
 4,651 ( 0.05%)   0          0          1,722 ( 0.07%) 1 ( 0.02%) 0          2,686 ( 0.09%)  4 ( 0.08%) 4 ( 0.10%)  			return tcache_alloc_small(tsdn_tsd(tsdn), arena,
     .            .          .              .          .          .              .           .          .           			    tcache, size, ind, zero, slow_path);
     .            .          .              .          .          .              .           .          .           		}
 1,137 ( 0.01%)   0          0            195 ( 0.01%) 0          0            935 ( 0.03%)  0          0           		if (likely(size <= tcache_maxclass)) {
10,155 ( 0.11%)  15 ( 0.01%) 0            943 ( 0.04%) 0          0          8,283 ( 0.26%)  0          0           			return tcache_alloc_large(tsdn_tsd(tsdn), arena,
     .            .          .              .          .          .              .           .          .           			    tcache, size, ind, zero, slow_path);
     .            .          .              .          .          .              .           .          .           		}
     .            .          .              .          .          .              .           .          .           		/* (size > tcache_maxclass) case falls through. */
 5,500 ( 0.06%)   2 ( 0.00%) 1 ( 0.01%) 2,751 ( 0.11%) 0          0              2 ( 0.00%)  0          0           		assert(size > tcache_maxclass);
     .            .          .              .          .          .              .           .          .           	}
     .            .          .              .          .          .              .           .          .           
 2,520 ( 0.03%)   3 ( 0.00%) 1 ( 0.01%)    71 ( 0.00%) 0          0          2,168 ( 0.07%)  0          0           	return arena_malloc_hard(tsdn, arena, size, ind, zero);
     .            .          .              .          .          .              .           .          .           }
     .            .          .              .          .          .              .           .          .           
     .            .          .              .          .          .              .           .          .           JEMALLOC_ALWAYS_INLINE arena_t *
     .            .          .              .          .          .              .           .          .           arena_aalloc(tsdn_t *tsdn, const void *ptr) {
   254 ( 0.00%)   0          0              8 ( 0.00%) 0          0            238 ( 0.01%)  0          0           	edata_t *edata = emap_edata_lookup(tsdn, &arena_emap_global, ptr);
 1,474 ( 0.02%)   0          0             16 ( 0.00%) 0          0          1,450 ( 0.05%)  0          0           	unsigned arena_ind = edata_arena_ind_get(edata);
   974 ( 0.01%)   0          0            254 ( 0.01%) 0          0            720 ( 0.02%)  0          0           	return (arena_t *)atomic_load_p(&arenas[arena_ind], ATOMIC_RELAXED);
     .            .          .              .          .          .              .           .          .           }
     .            .          .              .          .          .              .           .          .           
     .            .          .              .          .          .              .           .          .           JEMALLOC_ALWAYS_INLINE size_t
     .            .          .              .          .          .              .           .          .           arena_salloc(tsdn_t *tsdn, const void *ptr) {
 6,524 ( 0.07%) 202 ( 0.14%) 3 ( 0.04%)   310 ( 0.01%) 0          0          5,119 ( 0.16%)  0          0           	assert(ptr != NULL);
     .            .          .              .          .          .              .           .          .           	emap_alloc_ctx_t alloc_ctx;
     .            .          .              .          .          .              .           .          .           	emap_alloc_ctx_lookup(tsdn, &arena_emap_global, ptr, &alloc_ctx);
    76 ( 0.00%)   0          0              0          0          0             19 ( 0.00%)  0          0           	assert(alloc_ctx.szind != SC_NSIZES);
     .            .          .              .          .          .              .           .          .           
   784 ( 0.01%)   0          0            115 ( 0.00%) 0          0            264 ( 0.01%)  0          0           	return sz_index2size(alloc_ctx.szind);
     .            .          .              .          .          .              .           .          .           }
     .            .          .              .          .          .              .           .          .           
     .            .          .              .          .          .              .           .          .           JEMALLOC_ALWAYS_INLINE size_t
     .            .          .              .          .          .              .           .          .           arena_vsalloc(tsdn_t *tsdn, const void *ptr) {
     .            .          .              .          .          .              .           .          .           	/*
     .            .          .              .          .          .              .           .          .           	 * Return 0 if ptr is not within an extent managed by jemalloc.  This
     .            .          .              .          .          .              .           .          .           	 * function has two extra costs relative to isalloc():
     .            .          .              .          .          .              .           .          .           	 * - The rtree calls cannot claim to be dependent lookups, which induces
-- line 187 ----------------------------------------
-- line 373 ----------------------------------------
     .            .          .              .          .          .              .           .          .           	} else {
     .            .          .              .          .          .              .           .          .           		arena_dalloc_large_no_tcache(tsdn, ptr, alloc_ctx.szind);
     .            .          .              .          .          .              .           .          .           	}
     .            .          .              .          .          .              .           .          .           }
     .            .          .              .          .          .              .           .          .           
     .            .          .              .          .          .              .           .          .           JEMALLOC_ALWAYS_INLINE void
     .            .          .              .          .          .              .           .          .           arena_sdalloc(tsdn_t *tsdn, void *ptr, size_t size, tcache_t *tcache,
     .            .          .              .          .          .              .           .          .               emap_alloc_ctx_t *caller_alloc_ctx, bool slow_path) {
   140 ( 0.00%)   0          0              0          0          0              0           0          0           	assert(!tsdn_null(tsdn) || tcache == NULL);
   140 ( 0.00%)  31 ( 0.02%) 2 ( 0.03%)     0          0          0              0           0          0           	assert(ptr != NULL);
   140 ( 0.00%)  32 ( 0.02%) 2 ( 0.03%)     0          0          0              0           0          0           	assert(size <= SC_LARGE_MAXCLASS);
     .            .          .              .          .          .              .           .          .           
   175 ( 0.00%)  33 ( 0.02%) 2 ( 0.03%)    35 ( 0.00%) 0          0              0           0          0           	if (unlikely(tcache == NULL)) {
     .            .          .              .          .          .              .           .          .           		arena_sdalloc_no_tcache(tsdn, ptr, size);
     .            .          .              .          .          .              .           .          .           		return;
     .            .          .              .          .          .              .           .          .           	}
     .            .          .              .          .          .              .           .          .           
     .            .          .              .          .          .              .           .          .           	emap_alloc_ctx_t alloc_ctx;
   105 ( 0.00%)  33 ( 0.02%) 2 ( 0.03%)     0          0          0              0           0          0           	if (config_prof && opt_prof) {
    70 ( 0.00%)  64 ( 0.04%) 3 ( 0.04%)    35 ( 0.00%) 0          0             35 ( 0.00%) 26 ( 0.49%) 4 ( 0.10%)  		if (caller_alloc_ctx == NULL) {
     .            .          .              .          .          .              .           .          .           			/* Uncommon case and should be a static check. */
     .            .          .              .          .          .              .           .          .           			emap_alloc_ctx_lookup(tsdn, &arena_emap_global, ptr,
     .            .          .              .          .          .              .           .          .           			    &alloc_ctx);
     .            .          .              .          .          .              .           .          .           			assert(alloc_ctx.szind == sz_size2index(size));
     .            .          .              .          .          .              .           .          .           		} else {
     .            .          .              .          .          .              .           .          .           			alloc_ctx = *caller_alloc_ctx;
     .            .          .              .          .          .              .           .          .           		}
     .            .          .              .          .          .              .           .          .           	} else {
     .            .          .              .          .          .              .           .          .           		/*
     .            .          .              .          .          .              .           .          .           		 * There is no risk of being confused by a promoted sampled
     .            .          .              .          .          .              .           .          .           		 * object, so base szind and slab on the given size.
     .            .          .              .          .          .              .           .          .           		 */
    35 ( 0.00%)   0          0              0          0          0             35 ( 0.00%)  4 ( 0.08%) 3 ( 0.07%)  		alloc_ctx.szind = sz_size2index(size);
   175 ( 0.00%)  30 ( 0.02%) 1 ( 0.01%)    35 ( 0.00%) 0          0             35 ( 0.00%)  0          0           		alloc_ctx.slab = (alloc_ctx.szind < SC_NBINS);
     .            .          .              .          .          .              .           .          .           	}
     .            .          .              .          .          .              .           .          .           
   105 ( 0.00%)   0          0              0          0          0              0           0          0           	if (config_debug) {
     .            .          .              .          .          .              .           .          .           		edata_t *edata = emap_edata_lookup(tsdn, &arena_emap_global,
     .            .          .              .          .          .              .           .          .           		    ptr);
     .            .          .              .          .          .              .           .          .           		assert(alloc_ctx.szind == edata_szind_get(edata));
     .            .          .              .          .          .              .           .          .           		assert(alloc_ctx.slab == edata_slab_get(edata));
     .            .          .              .          .          .              .           .          .           	}
     .            .          .              .          .          .              .           .          .           
   140 ( 0.00%)  36 ( 0.02%) 3 ( 0.04%)    35 ( 0.00%) 0          0              0           0          0           	if (likely(alloc_ctx.slab)) {
     .            .          .              .          .          .              .           .          .           		/* Small allocation. */
   140 ( 0.00%)   0          0            105 ( 0.00%) 0          0             35 ( 0.00%)  8 ( 0.15%) 2 ( 0.05%)  		tcache_dalloc_small(tsdn_tsd(tsdn), tcache, ptr,
     .            .          .              .          .          .              .           .          .           		    alloc_ctx.szind, slow_path);
     .            .          .              .          .          .              .           .          .           	} else {
     .            .          .              .          .          .              .           .          .           		arena_dalloc_large(tsdn, ptr, tcache, alloc_ctx.szind,
     .            .          .              .          .          .              .           .          .           		    slow_path);
     .            .          .              .          .          .              .           .          .           	}
     .            .          .              .          .          .              .           .          .           }
     .            .          .              .          .          .              .           .          .           
     .            .          .              .          .          .              .           .          .           static inline void
     .            .          .              .          .          .              .           .          .           arena_cache_oblivious_randomize(tsdn_t *tsdn, arena_t *arena, edata_t *edata,
    11 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)     1 ( 0.00%) 0          0              7 ( 0.00%)  0          0               size_t alignment) {
     4 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)     0          0          0              0           0          0           	assert(edata_base_get(edata) == edata_addr_get(edata));
     .            .          .              .          .          .              .           .          .           
     2 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)     1 ( 0.00%) 0          0              0           0          0           	if (alignment < PAGE) {
     .            .          .              .          .          .              .           .          .           		unsigned lg_range = LG_PAGE -
     .            .          .              .          .          .              .           .          .           		    lg_floor(CACHELINE_CEILING(alignment));
     .            .          .              .          .          .              .           .          .           		size_t r;
     .            .          .              .          .          .              .           .          .           		if (!tsdn_null(tsdn)) {
     .            .          .              .          .          .              .           .          .           			tsd_t *tsd = tsdn_tsd(tsdn);
     .            .          .              .          .          .              .           .          .           			r = (size_t)prng_lg_range_u64(
     .            .          .              .          .          .              .           .          .           			    tsd_prng_statep_get(tsd), lg_range);
     .            .          .              .          .          .              .           .          .           		} else {
-- line 439 ----------------------------------------
-- line 442 ----------------------------------------
     .            .          .              .          .          .              .           .          .           		}
     .            .          .              .          .          .              .           .          .           		uintptr_t random_offset = ((uintptr_t)r) << (LG_PAGE -
     .            .          .              .          .          .              .           .          .           		    lg_range);
     .            .          .              .          .          .              .           .          .           		edata->e_addr = (void *)((uintptr_t)edata->e_addr +
     .            .          .              .          .          .              .           .          .           		    random_offset);
     .            .          .              .          .          .              .           .          .           		assert(ALIGNMENT_ADDR2BASE(edata->e_addr, alignment) ==
     .            .          .              .          .          .              .           .          .           		    edata->e_addr);
     .            .          .              .          .          .              .           .          .           	}
     7 ( 0.00%)   2 ( 0.00%) 2 ( 0.03%)     5 ( 0.00%) 0          0              0           0          0           }
     .            .          .              .          .          .              .           .          .           
     .            .          .              .          .          .              .           .          .           /*
     .            .          .              .          .          .              .           .          .            * The dalloc bin info contains just the information that the common paths need
     .            .          .              .          .          .              .           .          .            * during tcache flushes.  By force-inlining these paths, and using local copies
     .            .          .              .          .          .              .           .          .            * of data (so that the compiler knows it's constant), we avoid a whole bunch of
     .            .          .              .          .          .              .           .          .            * redundant loads and stores by leaving this information in registers.
     .            .          .              .          .          .              .           .          .            */
     .            .          .              .          .          .              .           .          .           typedef struct arena_dalloc_bin_locked_info_s arena_dalloc_bin_locked_info_t;
-- line 458 ----------------------------------------
-- line 537 ----------------------------------------
     .            .          .              .          .          .              .           .          .           	if (config_stats) {
     .            .          .              .          .          .              .           .          .           		bin->stats.ndalloc += info->ndalloc;
     .            .          .              .          .          .              .           .          .           		assert(bin->stats.curregs >= (size_t)info->ndalloc);
     .            .          .              .          .          .              .           .          .           		bin->stats.curregs -= (size_t)info->ndalloc;
     .            .          .              .          .          .              .           .          .           	}
     .            .          .              .          .          .              .           .          .           }
     .            .          .              .          .          .              .           .          .           
     .            .          .              .          .          .              .           .          .           static inline bin_t *
   100 ( 0.00%)  20 ( 0.01%) 0              0          0          0             80 ( 0.00%)  0          0           arena_get_bin(arena_t *arena, szind_t binind, unsigned binshard) {
   160 ( 0.00%)   0          0             60 ( 0.00%) 5 ( 0.09%) 0             20 ( 0.00%)  0          0           	bin_t *shard0 = (bin_t *)((uintptr_t)arena + arena_bin_offsets[binind]);
   160 ( 0.00%)  20 ( 0.01%) 1 ( 0.01%)    40 ( 0.00%) 0          0              0           0          0           	return shard0 + binshard;
    40 ( 0.00%)   0          0             40 ( 0.00%) 0          0              0           0          0           }
     .            .          .              .          .          .              .           .          .           
     .            .          .              .          .          .              .           .          .           #endif /* JEMALLOC_INTERNAL_ARENA_INLINES_B_H */

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/ashy5000/dev/cryptocurrency/contracts/src/main.rs
--------------------------------------------------------------------------------
Ir              I1mr         ILmr        Dr              D1mr       DLmr       Dw              D1mw       DLmw       

19,818 ( 0.21%) 148 ( 0.10%)  1 ( 0.01%)      0          0          0               0          0          0           // Copyright 2024, Asher Wrobel
     .            .           .               .          .          .               .          .          .           /*
     .            .           .               .          .          .               .          .          .           This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
     .            .           .               .          .          .               .          .          .           
     .            .           .               .          .          .               .          .          .           This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
     .            .           .               .          .          .               .          .          .           
     .            .           .               .          .          .               .          .          .           You should have received a copy of the GNU General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.
     .            .           .               .          .          .               .          .          .           */
     .            .           .               .          .          .               .          .          .           mod blockutil;
-- line 9 ----------------------------------------
-- line 18 ----------------------------------------
     .            .           .               .          .          .               .          .          .           use std::env;
     .            .           .               .          .          .               .          .          .           use std::process::ExitCode;
     .            .           .               .          .          .               .          .          .           use crate::{buffer::Buffer, vm::run_vm};
     .            .           .               .          .          .               .          .          .           use smartstring::alias::String;
     .            .           .               .          .          .               .          .          .           
     .            .           .               .          .          .               .          .          .           use rustc_hash::FxHashMap;
     .            .           .               .          .          .               .          .          .           
     .            .           .               .          .          .               .          .          .           #[global_allocator]
22,398 ( 0.24%) 711 ( 0.49%)  4 ( 0.06%)  5,135 ( 0.21%) 0          0          10,270 ( 0.33%) 1 ( 0.02%) 0           static GLOBAL: tikv_jemallocator::Jemalloc = tikv_jemallocator::Jemalloc;
     .            .           .               .          .          .               .          .          .           
     1 ( 0.00%)   1 ( 0.00%)  1 ( 0.01%)      0          0          0               0          0          0           fn main() -> ExitCode {
     1 ( 0.00%)   0           0               0          0          0               1 ( 0.00%) 0          0               let contract_contents = read_contract::read_contract();
     1 ( 0.00%)   1 ( 0.00%)  1 ( 0.01%)      0          0          0               1 ( 0.00%) 0          0               let mut tree = syntax_tree::build_syntax_tree();
     1 ( 0.00%)   0           0               0          0          0               1 ( 0.00%) 1 ( 0.02%) 0               tree.create(contract_contents);
     1 ( 0.00%)   0           0               0          0          0               1 ( 0.00%) 0          0               let mut buffers: FxHashMap<String, Buffer> = FxHashMap::default();
     1 ( 0.00%)   1 ( 0.00%)  1 ( 0.01%)      0          0          0               1 ( 0.00%) 0          0               buffers.insert(
     4 ( 0.00%)   1 ( 0.00%)  1 ( 0.01%)      0          0          0               1 ( 0.00%) 1 ( 0.02%) 0                   "00000000".into(),
     1 ( 0.00%)   1 ( 0.00%)  1 ( 0.01%)      1 ( 0.00%) 0          0               0          0          0                   Buffer {
     2 ( 0.00%)   0           0               0          0          0               1 ( 0.00%) 0          0                       contents: Vec::new(),
     .            .           .               .          .          .               .          .          .                   },
     1 ( 0.00%)   0           0               0          0          0               1 ( 0.00%) 0          0               );
     1 ( 0.00%)   0           0               0          0          0               1 ( 0.00%) 0          0               let blockutil_interface = blockutil::BlockUtilInterface::default();
     3 ( 0.00%)   0           0               0          0          0               2 ( 0.00%) 0          0               let args: Vec<std::string::String> = env::args().collect();
     4 ( 0.00%)   0           0               0          0          0               1 ( 0.00%) 0          0               let contract_hash = &args[2];
    20 ( 0.00%)   2 ( 0.00%)  2 ( 0.03%)      4 ( 0.00%) 0          0              15 ( 0.00%) 2 ( 0.04%) 0               let (exit_code, gas_used) = run_vm(tree, &mut buffers, blockutil_interface, contract_hash.parse().unwrap());
     1 ( 0.00%)   0           0               1 ( 0.00%) 0          0               0          0          0               println!("Gas used: {}", gas_used);
     4 ( 0.00%)   0           0               0          0          0               2 ( 0.00%) 0          0               ExitCode::from(exit_code as u8)
    10 ( 0.00%)   0           0               1 ( 0.00%) 0          0               5 ( 0.00%) 0          0           }

33,592 ( 0.35%) 676 ( 0.47%) 17 ( 0.24%) 33,493 ( 1.38%) 0          0               0          0          0           <counts for unidentified lines in /home/ashy5000/dev/cryptocurrency/contracts/src/main.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/ashy5000/dev/cryptocurrency/contracts/target/debug/build/tikv-jemalloc-sys-7365f40ecb99e085/out/build/src/edata.c
--------------------------------------------------------------------------------
Ir              I1mr         ILmr        Dr              D1mr        DLmr        Dw              D1mw        DLmw        

     .            .           .               .           .           .               .           .           .           #include "jemalloc/internal/jemalloc_preamble.h"
     .            .           .               .           .           .               .           .           .           #include "jemalloc/internal/jemalloc_internal_includes.h"
     .            .           .               .           .           .               .           .           .           
   405 ( 0.00%)  99 ( 0.07%)  3 ( 0.04%)    102 ( 0.00%)  0           0             168 ( 0.01%) 11 ( 0.21%)  9 ( 0.21%)  ph_gen(, edata_avail, edata_t, avail_link,
     .            .           .               .           .           .               .           .           .               edata_esnead_comp)
45,744 ( 0.48%) 389 ( 0.27%) 12 ( 0.17%) 13,820 ( 0.57%) 37 ( 0.64%) 27 ( 0.75%) 16,185 ( 0.51%) 96 ( 1.81%) 76 ( 1.81%)  ph_gen(, edata_heap, edata_t, heap_link, edata_snad_comp)

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/ashy5000/dev/cryptocurrency/contracts/target/debug/build/tikv-jemalloc-sys-7365f40ecb99e085/out/build/include/jemalloc/internal/fb.h
--------------------------------------------------------------------------------
Ir             I1mr        ILmr       Dr           D1mr       DLmr       Dw           D1mw       DLmw       

-- line 10 ----------------------------------------
    .           .          .            .          .          .            .          .          .            */
    .           .          .            .          .          .            .          .          .           
    .           .          .            .          .          .            .          .          .           typedef unsigned long fb_group_t;
    .           .          .            .          .          .            .          .          .           #define FB_GROUP_BITS (ZU(1) << (LG_SIZEOF_LONG + 3))
    .           .          .            .          .          .            .          .          .           #define FB_NGROUPS(nbits) ((nbits) / FB_GROUP_BITS \
    .           .          .            .          .          .            .          .          .               + ((nbits) % FB_GROUP_BITS == 0 ? 0 : 1))
    .           .          .            .          .          .            .          .          .           
    .           .          .            .          .          .            .          .          .           static inline void
   30 ( 0.00%)  2 ( 0.00%) 2 ( 0.03%)   0          0          0           18 ( 0.00%) 0          0           fb_init(fb_group_t *fb, size_t nbits) {
   66 ( 0.00%)  0          0           12 ( 0.00%) 0          0            6 ( 0.00%) 0          0           	size_t ngroups = FB_NGROUPS(nbits);
   36 ( 0.00%)  1 ( 0.00%) 1 ( 0.01%)  12 ( 0.00%) 0          0            6 ( 0.00%) 0          0           	memset(fb, 0, ngroups * sizeof(fb_group_t));
   18 ( 0.00%)  0          0           12 ( 0.00%) 0          0            0          0          0           }
    .           .          .            .          .          .            .          .          .           
    .           .          .            .          .          .            .          .          .           static inline bool
    .           .          .            .          .          .            .          .          .           fb_empty(fb_group_t *fb, size_t nbits) {
    .           .          .            .          .          .            .          .          .           	size_t ngroups = FB_NGROUPS(nbits);
    .           .          .            .          .          .            .          .          .           	for (size_t i = 0; i < ngroups; i++) {
    .           .          .            .          .          .            .          .          .           		if (fb[i] != 0) {
    .           .          .            .          .          .            .          .          .           			return false;
    .           .          .            .          .          .            .          .          .           		}
-- line 29 ----------------------------------------
-- line 51 ----------------------------------------
    .           .          .            .          .          .            .          .          .           fb_get(fb_group_t *fb, size_t nbits, size_t bit) {
    .           .          .            .          .          .            .          .          .           	assert(bit < nbits);
    .           .          .            .          .          .            .          .          .           	size_t group_ind = bit / FB_GROUP_BITS;
    .           .          .            .          .          .            .          .          .           	size_t bit_ind = bit % FB_GROUP_BITS;
    .           .          .            .          .          .            .          .          .           	return (bool)(fb[group_ind] & ((fb_group_t)1 << bit_ind));
    .           .          .            .          .          .            .          .          .           }
    .           .          .            .          .          .            .          .          .           
    .           .          .            .          .          .            .          .          .           static inline void
  192 ( 0.00%) 32 ( 0.02%) 0            0          0          0          128 ( 0.00%) 0          0           fb_set(fb_group_t *fb, size_t nbits, size_t bit) {
  128 ( 0.00%)  0          0            0          0          0            0          0          0           	assert(bit < nbits);
   96 ( 0.00%) 64 ( 0.04%) 2 ( 0.03%)  32 ( 0.00%) 0          0           32 ( 0.00%) 0          0           	size_t group_ind = bit / FB_GROUP_BITS;
   96 ( 0.00%)  0          0           32 ( 0.00%) 0          0           32 ( 0.00%) 0          0           	size_t bit_ind = bit % FB_GROUP_BITS;
  512 ( 0.01%)  1 ( 0.00%) 1 ( 0.01%) 192 ( 0.01%) 0          0           32 ( 0.00%) 0          0           	fb[group_ind] |= ((fb_group_t)1 << bit_ind);
   96 ( 0.00%)  0          0           64 ( 0.00%) 0          0            0          0          0           }
    .           .          .            .          .          .            .          .          .           
    .           .          .            .          .          .            .          .          .           static inline void
  186 ( 0.00%) 31 ( 0.02%) 0            0          0          0          124 ( 0.00%) 0          0           fb_unset(fb_group_t *fb, size_t nbits, size_t bit) {
  124 ( 0.00%)  0          0            0          0          0            0          0          0           	assert(bit < nbits);
   93 ( 0.00%) 62 ( 0.04%) 2 ( 0.03%)  31 ( 0.00%) 0          0           31 ( 0.00%) 0          0           	size_t group_ind = bit / FB_GROUP_BITS;
   93 ( 0.00%)  0          0           31 ( 0.00%) 0          0           31 ( 0.00%) 0          0           	size_t bit_ind = bit % FB_GROUP_BITS;
  589 ( 0.01%)  0          0          186 ( 0.01%) 0          0           31 ( 0.00%) 0          0           	fb[group_ind] &= ~((fb_group_t)1 << bit_ind);
   93 ( 0.00%)  0          0           62 ( 0.00%) 0          0            0          0          0           }
    .           .          .            .          .          .            .          .          .           
    .           .          .            .          .          .            .          .          .           
    .           .          .            .          .          .            .          .          .           /*
    .           .          .            .          .          .            .          .          .            * Some implementation details.  This visitation function lets us apply a group
    .           .          .            .          .          .            .          .          .            * visitor to each group in the bitmap (potentially modifying it).  The mask
    .           .          .            .          .          .            .          .          .            * indicates which bits are logically part of the visitation.
    .           .          .            .          .          .            .          .          .            */
    .           .          .            .          .          .            .          .          .           typedef void (*fb_group_visitor_t)(void *ctx, fb_group_t *fb, fb_group_t mask);
-- line 80 ----------------------------------------
-- line 169 ----------------------------------------
    .           .          .            .          .          .            .          .          .            * An implementation detail; find the first bit at position >= min_bit with the
    .           .          .            .          .          .            .          .          .            * value val.
    .           .          .            .          .          .            .          .          .            *
    .           .          .            .          .          .            .          .          .            * Returns the number of bits in the bitmap if no such bit exists.
    .           .          .            .          .          .            .          .          .            */
    .           .          .            .          .          .            .          .          .           JEMALLOC_ALWAYS_INLINE ssize_t
    .           .          .            .          .          .            .          .          .           fb_find_impl(fb_group_t *fb, size_t nbits, size_t start, bool val,
    .           .          .            .          .          .            .          .          .               bool forward) {
  380 ( 0.00%)  0          0            0          0          0            0          0          0           	assert(start < nbits);
1,045 ( 0.01%) 64 ( 0.04%) 2 ( 0.03%) 190 ( 0.01%) 0          0           95 ( 0.00%) 0          0           	size_t ngroups = FB_NGROUPS(nbits);
  285 ( 0.00%)  0          0           95 ( 0.00%) 0          0           95 ( 0.00%) 0          0           	ssize_t group_ind = start / FB_GROUP_BITS;
  285 ( 0.00%)  0          0           95 ( 0.00%) 0          0           95 ( 0.00%) 0          0           	size_t bit_ind = start % FB_GROUP_BITS;
    .           .          .            .          .          .            .          .          .           
  475 ( 0.01%)  0          0           95 ( 0.00%) 0          0           95 ( 0.00%) 0          0           	fb_group_t maybe_invert = (val ? 0 : (fb_group_t)-1);
    .           .          .            .          .          .            .          .          .           
  570 ( 0.01%) 32 ( 0.02%) 1 ( 0.01%) 285 ( 0.01%) 4 ( 0.07%) 0           95 ( 0.00%) 0          0           	fb_group_t group = fb[group_ind];
  190 ( 0.00%)  0          0          190 ( 0.01%) 0          0            0          0          0           	group ^= maybe_invert;
  190 ( 0.00%)  0          0           95 ( 0.00%) 0          0            0          0          0           	if (forward) {
    .           .          .            .          .          .            .          .          .           		/* Only keep ones in bits bit_ind and above. */
  760 ( 0.01%)  0          0          190 ( 0.01%) 0          0            0          0          0           		group &= ~((1LU << bit_ind) - 1);
    .           .          .            .          .          .            .          .          .           	} else {
    .           .          .            .          .          .            .          .          .           		/*
    .           .          .            .          .          .            .          .          .           		 * Only keep ones in bits bit_ind and below.  You might more
    .           .          .            .          .          .            .          .          .           		 * naturally express this as (1 << (bit_ind + 1)) - 1, but
    .           .          .            .          .          .            .          .          .           		 * that shifts by an invalid amount if bit_ind is one less than
    .           .          .            .          .          .            .          .          .           		 * FB_GROUP_BITS.
    .           .          .            .          .          .            .          .          .           		 */
    .           .          .            .          .          .            .          .          .           		group &= ((2LU << bit_ind) - 1);
    .           .          .            .          .          .            .          .          .           	}
  475 ( 0.01%) 32 ( 0.02%) 1 ( 0.01%) 190 ( 0.01%) 0          0           95 ( 0.00%) 0          0           	ssize_t group_ind_bound = forward ? (ssize_t)ngroups : -1;
  669 ( 0.01%) 32 ( 0.02%) 1 ( 0.01%) 287 ( 0.01%) 0          0            0          0          0           	while (group == 0) {
1,280 ( 0.01%)  0          0          512 ( 0.02%) 0          0            0          0          0           		group_ind += forward ? 1 : -1;
  768 ( 0.01%) 32 ( 0.02%) 1 ( 0.01%) 512 ( 0.02%) 0          0            0          0          0           		if (group_ind == group_ind_bound) {
  256 ( 0.00%)  0          0          128 ( 0.01%) 0          0            0          0          0           			return forward ? (ssize_t)nbits : (ssize_t)-1;
    .           .          .            .          .          .            .          .          .           		}
1,152 ( 0.01%)  0          0          576 ( 0.02%) 4 ( 0.07%) 0          192 ( 0.01%) 0          0           		group = fb[group_ind];
  384 ( 0.00%)  0          0          384 ( 0.02%) 0          0            0          0          0           		group ^= maybe_invert;
    .           .          .            .          .          .            .          .          .           	}
  124 ( 0.00%)  0          0            0          0          0            0          0          0           	assert(group != 0);
  248 ( 0.00%) 31 ( 0.02%) 1 ( 0.01%)  62 ( 0.00%) 0          0           62 ( 0.00%) 0          0           	size_t bit = forward ? ffs_lu(group) : fls_lu(group);
  186 ( 0.00%)  0          0           62 ( 0.00%) 0          0           31 ( 0.00%) 0          0           	size_t pos = group_ind * FB_GROUP_BITS + bit;
    .           .          .            .          .          .            .          .          .           	/*
    .           .          .            .          .          .            .          .          .           	 * The high bits of a partially filled last group are zeros, so if we're
    .           .          .            .          .          .            .          .          .           	 * looking for zeros we don't want to report an invalid result.
    .           .          .            .          .          .            .          .          .           	 */
  186 ( 0.00%)  0          0           62 ( 0.00%) 0          0            0          0          0           	if (forward && !val && pos > nbits) {
    .           .          .            .          .          .            .          .          .           		return nbits;
    .           .          .            .          .          .            .          .          .           	}
   31 ( 0.00%)  0          0           31 ( 0.00%) 0          0            0          0          0           	return pos;
    .           .          .            .          .          .            .          .          .           }
    .           .          .            .          .          .            .          .          .           
    .           .          .            .          .          .            .          .          .           /*
    .           .          .            .          .          .            .          .          .            * Find the first set bit in the bitmap with an index >= min_bit.  Returns the
    .           .          .            .          .          .            .          .          .            * number of bits in the bitmap if no such bit exists.
    .           .          .            .          .          .            .          .          .            */
    .           .          .            .          .          .            .          .          .           static inline size_t
    .           .          .            .          .          .            .          .          .           fb_ffu(fb_group_t *fb, size_t nbits, size_t min_bit) {
    .           .          .            .          .          .            .          .          .           	return (size_t)fb_find_impl(fb, nbits, min_bit, /* val */ false,
    .           .          .            .          .          .            .          .          .           	    /* forward */ true);
    .           .          .            .          .          .            .          .          .           }
    .           .          .            .          .          .            .          .          .           
    .           .          .            .          .          .            .          .          .           /* The same, but looks for an unset bit. */
    .           .          .            .          .          .            .          .          .           static inline size_t
1,330 ( 0.01%) 62 ( 0.04%) 2 ( 0.03%) 285 ( 0.01%) 0          0          855 ( 0.03%) 0          0           fb_ffs(fb_group_t *fb, size_t nbits, size_t min_bit) {
    .           .          .            .          .          .            .          .          .           	return (size_t)fb_find_impl(fb, nbits, min_bit, /* val */ true,
    .           .          .            .          .          .            .          .          .           	    /* forward */ true);
  190 ( 0.00%) 63 ( 0.04%) 1 ( 0.01%) 190 ( 0.01%) 0          0            0          0          0           }
    .           .          .            .          .          .            .          .          .           
    .           .          .            .          .          .            .          .          .           /*
    .           .          .            .          .          .            .          .          .            * Find the last set bit in the bitmap with an index <= max_bit.  Returns -1 if
    .           .          .            .          .          .            .          .          .            * no such bit exists.
    .           .          .            .          .          .            .          .          .            */
    .           .          .            .          .          .            .          .          .           static inline ssize_t
    .           .          .            .          .          .            .          .          .           fb_flu(fb_group_t *fb, size_t nbits, size_t max_bit) {
    .           .          .            .          .          .            .          .          .           	return fb_find_impl(fb, nbits, max_bit, /* val */ false,
-- line 243 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/ashy5000/dev/cryptocurrency/contracts/src/buffer.rs
--------------------------------------------------------------------------------
Ir             I1mr         ILmr       Dr             D1mr       DLmr       Dw             D1mw       DLmw       

    .            .          .              .          .          .              .          .          .           // Copyright 2024, Asher Wrobel
    .            .          .              .          .          .              .          .          .           /*
    .            .          .              .          .          .              .          .          .           This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
    .            .          .              .          .          .              .          .          .           
    .            .          .              .          .          .              .          .          .           This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
    .            .          .              .          .          .              .          .          .           
    .            .          .              .          .          .              .          .          .           You should have received a copy of the GNU General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.
    .            .          .              .          .          .              .          .          .           */
1,260 ( 0.01%)  12 ( 0.01%) 1 ( 0.01%)   420 ( 0.02%) 0          0            630 ( 0.02%) 0          0           #[derive(Debug, Clone)]
    .            .          .              .          .          .              .          .          .           pub struct Buffer {
  420 ( 0.00%)  10 ( 0.01%) 0            210 ( 0.01%) 0          0            105 ( 0.00%) 0          0               pub contents: Vec<u8>,
    .            .          .              .          .          .              .          .          .           }
    .            .          .              .          .          .              .          .          .           
    .            .          .              .          .          .              .          .          .           impl Buffer {
   73 ( 0.00%)  11 ( 0.01%) 1 ( 0.01%)     0          0          0              0          0          0               pub fn as_u64(&self) -> Result<u64, &'static str> {
  146 ( 0.00%)   0          0              0          0          0             73 ( 0.00%) 0          0                   if self.contents.len() != 8 {
    .            .          .              .          .          .              .          .          .                       println!("Invalid length. Actual length: {}", self.contents.len());
    .            .          .              .          .          .              .          .          .                       return Err("Invalid length");
    .            .          .              .          .          .              .          .          .                   }
   73 ( 0.00%)   0          0              0          0          0             73 ( 0.00%) 0          0                   let mut result: u64 = 0;
  146 ( 0.00%)   0          0              0          0          0             73 ( 0.00%) 0          0                   let mut shift_amount = 64 - 8;
8,614 ( 0.09%) 126 ( 0.09%) 3 ( 0.04%) 1,898 ( 0.08%) 0          0          2,117 ( 0.07%) 0          0                   for piece in &self.contents {
5,840 ( 0.06%)  42 ( 0.03%) 1 ( 0.01%) 1,168 ( 0.05%) 0          0          1,752 ( 0.06%) 0          0                       result += u64::from(*piece) << shift_amount;
1,168 ( 0.01%)   0          0            584 ( 0.02%) 0          0            584 ( 0.02%) 0          0                       shift_amount -= 8;
    .            .          .              .          .          .              .          .          .                   }
  219 ( 0.00%)   0          0             73 ( 0.00%) 0          0            146 ( 0.00%) 0          0                   Ok(result)
  219 ( 0.00%)   0          0             73 ( 0.00%) 0          0              0          0          0               }
    .            .          .              .          .          .              .          .          .               pub fn load_u64(&mut self, x: u64) {
   66 ( 0.00%)   0          0             33 ( 0.00%) 0          0             33 ( 0.00%) 0          0                   self.contents = Vec::new();
  198 ( 0.00%)   0          0              0          0          0             66 ( 0.00%) 0          0                   let mut shift_amount = 64 - 8;
  627 ( 0.01%)   0          0            297 ( 0.01%) 0          0              0          0          0                   while shift_amount >= 0 {
  264 ( 0.00%)  14 ( 0.01%) 1 ( 0.01%)     0          0          0            264 ( 0.01%) 0          0                       let mut piece_u64 = x;
  528 ( 0.01%)   0          0            528 ( 0.02%) 0          0              0          0          0                       piece_u64 >>= shift_amount;
  264 ( 0.00%)   0          0            264 ( 0.01%) 0          0              0          0          0                       piece_u64 %= 256;
  792 ( 0.01%)  33 ( 0.02%) 1 ( 0.01%)   264 ( 0.01%) 0          0            528 ( 0.02%) 0          0                       let piece = piece_u64 as u8;
1,848 ( 0.02%)   0          0            264 ( 0.01%) 0          0            528 ( 0.02%) 0          0                       shift_amount -= 8;
  792 ( 0.01%)  31 ( 0.02%) 0              0          0          0            264 ( 0.01%) 0          0                       self.contents.push(piece);
    .            .          .              .          .          .              .          .          .                   }
   33 ( 0.00%)   0          0              0          0          0              0          0          0               }
    .            .          .              .          .          .              .          .          .           }

3,324 ( 0.04%)  41 ( 0.03%) 1 ( 0.01%) 3,324 ( 0.14%) 0          0              0          0          0           <counts for unidentified lines in /home/ashy5000/dev/cryptocurrency/contracts/src/buffer.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/ashy5000/dev/cryptocurrency/contracts/target/debug/build/tikv-jemalloc-sys-7365f40ecb99e085/out/build/src/jemalloc.c
--------------------------------------------------------------------------------
Ir              I1mr         ILmr       Dr             D1mr         DLmr        Dw              D1mw        DLmw        

-- line 290 ----------------------------------------
     .            .          .              .            .           .               .           .           .           	if (unlikely(malloc_init_state == malloc_init_uninitialized)) {
     .            .          .              .            .           .               .           .           .           		return malloc_init_hard_a0();
     .            .          .              .            .           .               .           .           .           	}
     .            .          .              .            .           .               .           .           .           	return false;
     .            .          .              .            .           .               .           .           .           }
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           JEMALLOC_ALWAYS_INLINE bool
     .            .          .              .            .           .               .           .           .           malloc_init(void) {
     6 ( 0.00%)   1 ( 0.00%) 0              0            0           0               1 ( 0.00%)  0           0           	if (unlikely(!malloc_initialized()) && malloc_init_hard()) {
     5 ( 0.00%)   0          0              2 ( 0.00%)   0           0               2 ( 0.00%)  0           0           		return true;
     .            .          .              .            .           .               .           .           .           	}
     .            .          .              .            .           .               .           .           .           	return false;
     .            .          .              .            .           .               .           .           .           }
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           /*
     .            .          .              .            .           .               .           .           .            * The a0*() functions are used instead of i{d,}alloc() in situations that
     .            .          .              .            .           .               .           .           .            * cannot tolerate TLS variable access.
     .            .          .              .            .           .               .           .           .            */
-- line 307 ----------------------------------------
-- line 364 ----------------------------------------
     .            .          .              .            .           .               .           .           .           	if (unlikely(ptr == NULL)) {
     .            .          .              .            .           .               .           .           .           		return;
     .            .          .              .            .           .               .           .           .           	}
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           	a0idalloc(ptr, false);
     .            .          .              .            .           .               .           .           .           }
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           void
     9 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)     1 ( 0.00%)   0           0               4 ( 0.00%)  0           0           arena_set(unsigned ind, arena_t *arena) {
    10 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)     3 ( 0.00%)   0           0               4 ( 0.00%)  0           0           	atomic_store_p(&arenas[ind], arena, ATOMIC_RELEASE);
     6 ( 0.00%)   0          0              4 ( 0.00%)   0           0               0           0           0           }
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           static void
    15 ( 0.00%)   2 ( 0.00%) 1 ( 0.01%)     3 ( 0.00%)   0           0               7 ( 0.00%)  0           0           narenas_total_set(unsigned narenas) {
     .            .          .              .            .           .               .           .           .           	atomic_store_u(&narenas_total, narenas, ATOMIC_RELEASE);
     6 ( 0.00%)   1 ( 0.00%) 0              4 ( 0.00%)   0           0               0           0           0           }
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           static void
    20 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)     2 ( 0.00%)   0           0              10 ( 0.00%)  0           0           narenas_total_inc(void) {
     .            .          .              .            .           .               .           .           .           	atomic_fetch_add_u(&narenas_total, 1, ATOMIC_RELEASE);
     6 ( 0.00%)   0          0              4 ( 0.00%)   0           0               0           0           0           }
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           unsigned
    36 ( 0.00%)   4 ( 0.00%) 2 ( 0.03%)     6 ( 0.00%)   0           0              15 ( 0.00%)  0           0           narenas_total_get(void) {
     .            .          .              .            .           .               .           .           .           	return atomic_load_u(&narenas_total, ATOMIC_ACQUIRE);
    15 ( 0.00%)   0          0             12 ( 0.00%)   0           0               0           0           0           }
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           /* Create a new arena and insert it into the arenas array at index ind. */
     .            .          .              .            .           .               .           .           .           static arena_t *
     7 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)     0            0           0               4 ( 0.00%)  0           0           arena_init_locked(tsdn_t *tsdn, unsigned ind, const arena_config_t *config) {
     .            .          .              .            .           .               .           .           .           	arena_t *arena;
     .            .          .              .            .           .               .           .           .           
     4 ( 0.00%)   0          0              0            0           0               0           0           0           	assert(ind <= narenas_total_get());
     2 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)     1 ( 0.00%)   0           0               0           0           0           	if (ind >= MALLOCX_ARENA_LIMIT) {
     .            .          .              .            .           .               .           .           .           		return NULL;
     .            .          .              .            .           .               .           .           .           	}
     3 ( 0.00%)   0          0              1 ( 0.00%)   0           0               1 ( 0.00%)  0           0           	if (ind == narenas_total_get()) {
     1 ( 0.00%)   0          0              0            0           0               1 ( 0.00%)  0           0           		narenas_total_inc();
     .            .          .              .            .           .               .           .           .           	}
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           	/*
     .            .          .              .            .           .               .           .           .           	 * Another thread may have already initialized arenas[ind] if it's an
     .            .          .              .            .           .               .           .           .           	 * auto arena.
     .            .          .              .            .           .               .           .           .           	 */
     7 ( 0.00%)   0          0              2 ( 0.00%)   0           0               2 ( 0.00%)  0           0           	arena = arena_get(tsdn, ind, false);
     2 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)     1 ( 0.00%)   0           0               0           0           0           	if (arena != NULL) {
     .            .          .              .            .           .               .           .           .           		assert(arena_is_auto(arena));
     .            .          .              .            .           .               .           .           .           		return arena;
     .            .          .              .            .           .               .           .           .           	}
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           	/* Actually initialize the arena. */
     7 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)     3 ( 0.00%)   0           0               2 ( 0.00%)  1 ( 0.02%)  0           	arena = arena_new(tsdn, ind, config);
     .            .          .              .            .           .               .           .           .           
     1 ( 0.00%)   0          0              1 ( 0.00%)   0           0               0           0           0           	return arena;
     2 ( 0.00%)   0          0              2 ( 0.00%)   0           0               0           0           0           }
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           static void
     6 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)     0            0           0               3 ( 0.00%)  0           0           arena_new_create_background_thread(tsdn_t *tsdn, unsigned ind) {
     2 ( 0.00%)   0          0              1 ( 0.00%)   0           0               0           0           0           	if (ind == 0) {
     1 ( 0.00%)   0          0              0            0           0               0           0           0           		return;
     .            .          .              .            .           .               .           .           .           	}
     .            .          .              .            .           .               .           .           .           	/*
     .            .          .              .            .           .               .           .           .           	 * Avoid creating a new background thread just for the huge arena, which
     .            .          .              .            .           .               .           .           .           	 * purges eagerly by default.
     .            .          .              .            .           .               .           .           .           	 */
     .            .          .              .            .           .               .           .           .           	if (have_background_thread && !arena_is_huge(ind)) {
     .            .          .              .            .           .               .           .           .           		if (background_thread_create(tsdn_tsd(tsdn), ind)) {
     .            .          .              .            .           .               .           .           .           			malloc_printf("<jemalloc>: error in background thread "
     .            .          .              .            .           .               .           .           .           				      "creation for arena %u. Abort.\n", ind);
     .            .          .              .            .           .               .           .           .           			abort();
     .            .          .              .            .           .               .           .           .           		}
     .            .          .              .            .           .               .           .           .           	}
     2 ( 0.00%)   0          0              2 ( 0.00%)   0           0               0           0           0           }
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           arena_t *
     7 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)     0            0           0               4 ( 0.00%)  0           0           arena_init(tsdn_t *tsdn, unsigned ind, const arena_config_t *config) {
     .            .          .              .            .           .               .           .           .           	arena_t *arena;
     .            .          .              .            .           .               .           .           .           
     5 ( 0.00%)   0          0              1 ( 0.00%)   0           0               1 ( 0.00%)  0           0           	malloc_mutex_lock(tsdn, &arenas_lock);
     7 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)     3 ( 0.00%)   0           0               2 ( 0.00%)  1 ( 0.02%)  0           	arena = arena_init_locked(tsdn, ind, config);
     5 ( 0.00%)   0          0              1 ( 0.00%)   0           0               1 ( 0.00%)  0           0           	malloc_mutex_unlock(tsdn, &arenas_lock);
     .            .          .              .            .           .               .           .           .           
     5 ( 0.00%)   0          0              2 ( 0.00%)   0           0               1 ( 0.00%)  0           0           	arena_new_create_background_thread(tsdn, ind);
     .            .          .              .            .           .               .           .           .           
     1 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)     1 ( 0.00%)   0           0               0           0           0           	return arena;
     2 ( 0.00%)   0          0              2 ( 0.00%)   0           0               0           0           0           }
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           static void
    20 ( 0.00%)   1 ( 0.00%) 0              2 ( 0.00%)   0           0              10 ( 0.00%)  0           0           arena_bind(tsd_t *tsd, unsigned ind, bool internal) {
    12 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)     2 ( 0.00%)   0           0               4 ( 0.00%)  0           0           	arena_t *arena = arena_get(tsd_tsdn(tsd), ind, false);
    10 ( 0.00%)   0          0              4 ( 0.00%)   0           0               2 ( 0.00%)  0           0           	arena_nthreads_inc(arena, internal);
     .            .          .              .            .           .               .           .           .           
     8 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)     4 ( 0.00%)   0           0               2 ( 0.00%)  0           0           	if (internal) {
     .            .          .              .            .           .               .           .           .           		tsd_iarena_set(tsd, arena);
     .            .          .              .            .           .               .           .           .           	} else {
     .            .          .              .            .           .               .           .           .           		tsd_arena_set(tsd, arena);
    12 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)     4 ( 0.00%)   0           0               7 ( 0.00%)  0           0           		unsigned shard = atomic_fetch_add_u(&arena->binshard_next, 1,
     .            .          .              .            .           .               .           .           .           		    ATOMIC_RELAXED);
     1 ( 0.00%)   0          0              0            0           0               1 ( 0.00%)  0           0           		tsd_binshards_t *bins = tsd_binshardsp_get(tsd);
   112 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)    73 ( 0.00%)   0           0               1 ( 0.00%)  0           0           		for (unsigned i = 0; i < SC_NBINS; i++) {
   144 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)     0            0           0               0           0           0           			assert(bin_infos[i].n_shards > 0 &&
     .            .          .              .            .           .               .           .           .           			    bin_infos[i].n_shards <= BIN_SHARDS_MAX);
   612 ( 0.01%)   1 ( 0.00%) 1 ( 0.01%)   180 ( 0.01%)  23 ( 0.40%)  0              36 ( 0.00%)  0           0           			bins->binshard[i] = shard % bin_infos[i].n_shards;
     .            .          .              .            .           .               .           .           .           		}
     .            .          .              .            .           .               .           .           .           	}
     7 ( 0.00%)   0          0              4 ( 0.00%)   0           0               0           0           0           }
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           void
     .            .          .              .            .           .               .           .           .           arena_migrate(tsd_t *tsd, arena_t *oldarena, arena_t *newarena) {
     .            .          .              .            .           .               .           .           .           	assert(oldarena != NULL);
     .            .          .              .            .           .               .           .           .           	assert(newarena != NULL);
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           	arena_nthreads_dec(oldarena, false);
     .            .          .              .            .           .               .           .           .           	arena_nthreads_inc(newarena, false);
-- line 477 ----------------------------------------
-- line 495 ----------------------------------------
     .            .          .              .            .           .               .           .           .           		tsd_iarena_set(tsd, NULL);
     .            .          .              .            .           .               .           .           .           	} else {
     .            .          .              .            .           .               .           .           .           		tsd_arena_set(tsd, NULL);
     .            .          .              .            .           .               .           .           .           	}
     .            .          .              .            .           .               .           .           .           }
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           /* Slow path, called only by arena_choose(). */
     .            .          .              .            .           .               .           .           .           arena_t *
    12 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)     1 ( 0.00%)   0           0               6 ( 0.00%)  1 ( 0.02%)  1 ( 0.02%)  arena_choose_hard(tsd_t *tsd, bool internal) {
     1 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)     0            0           0               1 ( 0.00%)  1 ( 0.02%)  1 ( 0.02%)  	arena_t *ret JEMALLOC_CC_SILENCE_INIT(NULL);
     .            .          .              .            .           .               .           .           .           
     7 ( 0.00%)   0          0              1 ( 0.00%)   0           0               0           0           0           	if (have_percpu_arena && PERCPU_ARENA_ENABLED(opt_percpu_arena)) {
     .            .          .              .            .           .               .           .           .           		unsigned choose = percpu_arena_choose();
     .            .          .              .            .           .               .           .           .           		ret = arena_get(tsd_tsdn(tsd), choose, true);
     .            .          .              .            .           .               .           .           .           		assert(ret != NULL);
     .            .          .              .            .           .               .           .           .           		arena_bind(tsd, arena_ind_get(ret), false);
     .            .          .              .            .           .               .           .           .           		arena_bind(tsd, arena_ind_get(ret), true);
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           		return ret;
     .            .          .              .            .           .               .           .           .           	}
     .            .          .              .            .           .               .           .           .           
     3 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)     1 ( 0.00%)   0           0               0           0           0           	if (narenas_auto > 1) {
     .            .          .              .            .           .               .           .           .           		unsigned i, j, choose[2], first_null;
     .            .          .              .            .           .               .           .           .           		bool is_new_arena[2];
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           		/*
     .            .          .              .            .           .               .           .           .           		 * Determine binding for both non-internal and internal
     .            .          .              .            .           .               .           .           .           		 * allocation.
     .            .          .              .            .           .               .           .           .           		 *
     .            .          .              .            .           .               .           .           .           		 *   choose[0]: For application allocation.
     .            .          .              .            .           .               .           .           .           		 *   choose[1]: For internal metadata allocation.
     .            .          .              .            .           .               .           .           .           		 */
     .            .          .              .            .           .               .           .           .           
    10 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)     5 ( 0.00%)   0           0               1 ( 0.00%)  0           0           		for (j = 0; j < 2; j++) {
     4 ( 0.00%)   0          0              2 ( 0.00%)   0           0               2 ( 0.00%)  0           0           			choose[j] = 0;
     4 ( 0.00%)   0          0              2 ( 0.00%)   0           0               2 ( 0.00%)  0           0           			is_new_arena[j] = false;
     .            .          .              .            .           .               .           .           .           		}
     .            .          .              .            .           .               .           .           .           
     4 ( 0.00%)   0          0              2 ( 0.00%)   0           0               2 ( 0.00%)  0           0           		first_null = narenas_auto;
     4 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)     0            0           0               1 ( 0.00%)  0           0           		malloc_mutex_lock(tsd_tsdn(tsd), &arenas_lock);
     4 ( 0.00%)   0          0              0            0           0               0           0           0           		assert(arena_get(tsd_tsdn(tsd), 0, false) != NULL);
   287 ( 0.00%)   3 ( 0.00%) 3 ( 0.04%)   190 ( 0.01%)   0           0              48 ( 0.00%)  0           0           		for (i = 1; i < narenas_auto; i++) {
   329 ( 0.00%)   0          0             47 ( 0.00%)   0           0              47 ( 0.00%)  0           0           			if (arena_get(tsd_tsdn(tsd), i, false) != NULL) {
     .            .          .              .            .           .               .           .           .           				/*
     .            .          .              .            .           .               .           .           .           				 * Choose the first arena that has the lowest
     .            .          .              .            .           .               .           .           .           				 * number of threads assigned to it.
     .            .          .              .            .           .               .           .           .           				 */
     .            .          .              .            .           .               .           .           .           				for (j = 0; j < 2; j++) {
     .            .          .              .            .           .               .           .           .           					if (arena_nthreads_get(arena_get(
     .            .          .              .            .           .               .           .           .           					    tsd_tsdn(tsd), i, false), !!j) <
     .            .          .              .            .           .               .           .           .           					    arena_nthreads_get(arena_get(
     .            .          .              .            .           .               .           .           .           					    tsd_tsdn(tsd), choose[j], false),
     .            .          .              .            .           .               .           .           .           					    !!j)) {
     .            .          .              .            .           .               .           .           .           						choose[j] = i;
     .            .          .              .            .           .               .           .           .           					}
     .            .          .              .            .           .               .           .           .           				}
   141 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)    94 ( 0.00%)   0           0               0           0           0           			} else if (first_null == narenas_auto) {
     .            .          .              .            .           .               .           .           .           				/*
     .            .          .              .            .           .               .           .           .           				 * Record the index of the first uninitialized
     .            .          .              .            .           .               .           .           .           				 * arena, in case all extant arenas are in use.
     .            .          .              .            .           .               .           .           .           				 *
     .            .          .              .            .           .               .           .           .           				 * NB: It is possible for there to be
     .            .          .              .            .           .               .           .           .           				 * discontinuities in terms of initialized
     .            .          .              .            .           .               .           .           .           				 * versus uninitialized arenas, due to the
     .            .          .              .            .           .               .           .           .           				 * "thread.arena" mallctl.
     .            .          .              .            .           .               .           .           .           				 */
     2 ( 0.00%)   0          0              1 ( 0.00%)   0           0               1 ( 0.00%)  0           0           				first_null = i;
     .            .          .              .            .           .               .           .           .           			}
     .            .          .              .            .           .               .           .           .           		}
     .            .          .              .            .           .               .           .           .           
    12 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)     6 ( 0.00%)   0           0               2 ( 0.00%)  0           0           		for (j = 0; j < 2; j++) {
    32 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)     8 ( 0.00%)   0           0               6 ( 0.00%)  1 ( 0.02%)  1 ( 0.02%)  			if (arena_nthreads_get(arena_get(tsd_tsdn(tsd),
     .            .          .              .            .           .               .           .           .           			    choose[j], false), !!j) == 0 || first_null ==
     .            .          .              .            .           .               .           .           .           			    narenas_auto) {
     .            .          .              .            .           .               .           .           .           				/*
     .            .          .              .            .           .               .           .           .           				 * Use an unloaded arena, or the least loaded
     .            .          .              .            .           .               .           .           .           				 * arena if all arenas are already initialized.
     .            .          .              .            .           .               .           .           .           				 */
    13 ( 0.00%)   2 ( 0.00%) 2 ( 0.03%)     4 ( 0.00%)   0           0               0           0           0           				if (!!j == internal) {
     9 ( 0.00%)   0          0              3 ( 0.00%)   0           0               3 ( 0.00%)  0           0           					ret = arena_get(tsd_tsdn(tsd),
     .            .          .              .            .           .               .           .           .           					    choose[j], false);
     .            .          .              .            .           .               .           .           .           				}
     .            .          .              .            .           .               .           .           .           			} else {
     .            .          .              .            .           .               .           .           .           				arena_t *arena;
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           				/* Initialize a new arena. */
     .            .          .              .            .           .               .           .           .           				choose[j] = first_null;
     .            .          .              .            .           .               .           .           .           				arena = arena_init_locked(tsd_tsdn(tsd),
-- line 582 ----------------------------------------
-- line 586 ----------------------------------------
     .            .          .              .            .           .               .           .           .           					    &arenas_lock);
     .            .          .              .            .           .               .           .           .           					return NULL;
     .            .          .              .            .           .               .           .           .           				}
     .            .          .              .            .           .               .           .           .           				is_new_arena[j] = true;
     .            .          .              .            .           .               .           .           .           				if (!!j == internal) {
     .            .          .              .            .           .               .           .           .           					ret = arena;
     .            .          .              .            .           .               .           .           .           				}
     .            .          .              .            .           .               .           .           .           			}
    18 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)     8 ( 0.00%)   0           0               2 ( 0.00%)  0           0           			arena_bind(tsd, choose[j], !!j);
     .            .          .              .            .           .               .           .           .           		}
     4 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)     0            0           0               1 ( 0.00%)  0           0           		malloc_mutex_unlock(tsd_tsdn(tsd), &arenas_lock);
     .            .          .              .            .           .               .           .           .           
    11 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)     5 ( 0.00%)   0           0               1 ( 0.00%)  0           0           		for (j = 0; j < 2; j++) {
     8 ( 0.00%)   0          0              4 ( 0.00%)   0           0               0           0           0           			if (is_new_arena[j]) {
     .            .          .              .            .           .               .           .           .           				assert(choose[j] > 0);
     .            .          .              .            .           .               .           .           .           				arena_new_create_background_thread(
     .            .          .              .            .           .               .           .           .           				    tsd_tsdn(tsd), choose[j]);
     .            .          .              .            .           .               .           .           .           			}
     .            .          .              .            .           .               .           .           .           		}
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           	} else {
     .            .          .              .            .           .               .           .           .           		ret = arena_get(tsd_tsdn(tsd), 0, false);
     .            .          .              .            .           .               .           .           .           		arena_bind(tsd, 0, false);
     .            .          .              .            .           .               .           .           .           		arena_bind(tsd, 0, true);
     .            .          .              .            .           .               .           .           .           	}
     .            .          .              .            .           .               .           .           .           
     1 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)     1 ( 0.00%)   0           0               0           0           0           	return ret;
     8 ( 0.00%)   0          0              6 ( 0.00%)   0           0               0           0           0           }
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           void
     .            .          .              .            .           .               .           .           .           iarena_cleanup(tsd_t *tsd) {
     .            .          .              .            .           .               .           .           .           	arena_t *iarena;
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           	iarena = tsd_iarena_get(tsd);
     .            .          .              .            .           .               .           .           .           	if (iarena != NULL) {
     .            .          .              .            .           .               .           .           .           		arena_unbind(tsd, arena_ind_get(iarena), true);
-- line 621 ----------------------------------------
-- line 668 ----------------------------------------
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           /*
     .            .          .              .            .           .               .           .           .            * Ensure that we don't hold any locks upon entry to or exit from allocator
     .            .          .              .            .           .               .           .           .            * code (in a "broad" sense that doesn't count a reentrant allocation as an
     .            .          .              .            .           .               .           .           .            * entrance or exit).
     .            .          .              .            .           .               .           .           .            */
     .            .          .              .            .           .               .           .           .           JEMALLOC_ALWAYS_INLINE void
     .            .          .              .            .           .               .           .           .           check_entry_exit_locking(tsdn_t *tsdn) {
 1,024 ( 0.01%)  22 ( 0.02%) 3 ( 0.04%)     1 ( 0.00%)   1 ( 0.02%)  1 ( 0.03%)      0           0           0           	if (!config_debug) {
   716 ( 0.01%) 107 ( 0.07%) 9 ( 0.13%)   103 ( 0.00%)   0           0             103 ( 0.00%)  0           0           		return;
     .            .          .              .            .           .               .           .           .           	}
     .            .          .              .            .           .               .           .           .           	if (tsdn_null(tsdn)) {
     1 ( 0.00%)   0          0              0            0           0               1 ( 0.00%)  0           0           		return;
     .            .          .              .            .           .               .           .           .           	}
 1,932 ( 0.02%) 103 ( 0.07%) 1 ( 0.01%)   364 ( 0.01%)   0           0           1,129 ( 0.04%)  0           0           	tsd_t *tsd = tsdn_tsd(tsdn);
     .            .          .              .            .           .               .           .           .           	/*
     .            .          .              .            .           .               .           .           .           	 * It's possible we hold locks at entry/exit if we're in a nested
     .            .          .              .            .           .               .           .           .           	 * allocation.
     .            .          .              .            .           .               .           .           .           	 */
    25 ( 0.00%)   3 ( 0.00%) 2 ( 0.03%)    15 ( 0.00%)   0           0               2 ( 0.00%)  0           0           	int8_t reentrancy_level = tsd_reentrancy_level_get(tsd);
    17 ( 0.00%)   0          0             10 ( 0.00%)   2 ( 0.03%)  0               4 ( 0.00%)  0           0           	if (reentrancy_level != 0) {
   453 ( 0.00%) 121 ( 0.08%) 3 ( 0.04%)   277 ( 0.01%)   0           0             176 ( 0.01%) 14 ( 0.26%)  7 ( 0.17%)  		return;
     .            .          .              .            .           .               .           .           .           	}
   107 ( 0.00%)   0          0              0            0           0             107 ( 0.00%)  0           0           	witness_assert_lockless(tsdn_witness_tsdp_get(tsdn));
     .            .          .              .            .           .               .           .           .           }
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           /*
     .            .          .              .            .           .               .           .           .            * End miscellaneous support functions.
     .            .          .              .            .           .               .           .           .            */
     .            .          .              .            .           .               .           .           .           /******************************************************************************/
     .            .          .              .            .           .               .           .           .           /*
     .            .          .              .            .           .               .           .           .            * Begin initialization functions.
     .            .          .              .            .           .               .           .           .            */
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           static char *
     5 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)     0            0           0               2 ( 0.00%)  0           0           jemalloc_secure_getenv(const char *name) {
     .            .          .              .            .           .               .           .           .           #ifdef JEMALLOC_HAVE_SECURE_GETENV
     3 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)     1 ( 0.00%)   0           0               1 ( 0.00%)  0           0           	return secure_getenv(name);
     .            .          .              .            .           .               .           .           .           #else
     .            .          .              .            .           .               .           .           .           #  ifdef JEMALLOC_HAVE_ISSETUGID
     .            .          .              .            .           .               .           .           .           	if (issetugid() != 0) {
     .            .          .              .            .           .               .           .           .           		return NULL;
     .            .          .              .            .           .               .           .           .           	}
     .            .          .              .            .           .               .           .           .           #  endif
     .            .          .              .            .           .               .           .           .           	return getenv(name);
     .            .          .              .            .           .               .           .           .           #endif
     2 ( 0.00%)   0          0              2 ( 0.00%)   0           0               0           0           0           }
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           static unsigned
     7 ( 0.00%)   1 ( 0.00%) 0              1 ( 0.00%)   0           0               2 ( 0.00%)  0           0           malloc_ncpus(void) {
     .            .          .              .            .           .               .           .           .           	long result;
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           #ifdef _WIN32
     .            .          .              .            .           .               .           .           .           	SYSTEM_INFO si;
     .            .          .              .            .           .               .           .           .           	GetSystemInfo(&si);
     .            .          .              .            .           .               .           .           .           	result = si.dwNumberOfProcessors;
     .            .          .              .            .           .               .           .           .           #elif defined(CPU_COUNT)
     .            .          .              .            .           .               .           .           .           	/*
-- line 725 ----------------------------------------
-- line 734 ----------------------------------------
     .            .          .              .            .           .               .           .           .           	 */
     .            .          .              .            .           .               .           .           .           	{
     .            .          .              .            .           .               .           .           .           #  if defined(__FreeBSD__) || defined(__DragonFly__)
     .            .          .              .            .           .               .           .           .           		cpuset_t set;
     .            .          .              .            .           .               .           .           .           #  else
     .            .          .              .            .           .               .           .           .           		cpu_set_t set;
     .            .          .              .            .           .               .           .           .           #  endif
     .            .          .              .            .           .               .           .           .           #  if defined(JEMALLOC_HAVE_SCHED_SETAFFINITY)
     5 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)     0            0           0               1 ( 0.00%)  0           0           		sched_getaffinity(0, sizeof(set), &set);
     .            .          .              .            .           .               .           .           .           #  else
     .            .          .              .            .           .               .           .           .           		pthread_getaffinity_np(pthread_self(), sizeof(set), &set);
     .            .          .              .            .           .               .           .           .           #  endif
     6 ( 0.00%)   0          0              0            0           0               2 ( 0.00%)  0           0           		result = CPU_COUNT(&set);
     .            .          .              .            .           .               .           .           .           	}
     .            .          .              .            .           .               .           .           .           #else
     .            .          .              .            .           .               .           .           .           	result = sysconf(_SC_NPROCESSORS_ONLN);
     .            .          .              .            .           .               .           .           .           #endif
     4 ( 0.00%)   0          0              2 ( 0.00%)   0           0               0           0           0           	return ((result == -1) ? 1 : (unsigned)result);
     5 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)     4 ( 0.00%)   0           0               0           0           0           }
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           /*
     .            .          .              .            .           .               .           .           .            * Ensure that number of CPUs is determistinc, i.e. it is the same based on:
     .            .          .              .            .           .               .           .           .            * - sched_getaffinity()
     .            .          .              .            .           .               .           .           .            * - _SC_NPROCESSORS_ONLN
     .            .          .              .            .           .               .           .           .            * - _SC_NPROCESSORS_CONF
     .            .          .              .            .           .               .           .           .            * Since otherwise tricky things is possible with percpu arenas in use.
     .            .          .              .            .           .               .           .           .            */
-- line 760 ----------------------------------------
-- line 954 ----------------------------------------
     .            .          .              .            .           .               .           .           .           	if (strncmp(k, experimental, strlen(experimental)) == 0) {
     .            .          .              .            .           .               .           .           .           		/* However, tolerate experimental features. */
     .            .          .              .            .           .               .           .           .           		return;
     .            .          .              .            .           .               .           .           .           	}
     .            .          .              .            .           .               .           .           .           	had_conf_error = true;
     .            .          .              .            .           .               .           .           .           }
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           static void
     3 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)     0            0           0               1 ( 0.00%)  0           0           malloc_slow_flag_init(void) {
     .            .          .              .            .           .               .           .           .           	/*
     .            .          .              .            .           .               .           .           .           	 * Combine the runtime options into malloc_slow for fast path.  Called
     .            .          .              .            .           .               .           .           .           	 * after processing all the options.
     .            .          .              .            .           .               .           .           .           	 */
     5 ( 0.00%)   0          0              2 ( 0.00%)   0           0               1 ( 0.00%)  0           0           	malloc_slow_flags |= (opt_junk_alloc ? flag_opt_junk_alloc : 0)
     5 ( 0.00%)   0          0              1 ( 0.00%)   0           0               0           0           0           	    | (opt_junk_free ? flag_opt_junk_free : 0)
     5 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)     1 ( 0.00%)   0           0               0           0           0           	    | (opt_zero ? flag_opt_zero : 0)
     5 ( 0.00%)   0          0              1 ( 0.00%)   0           0               0           0           0           	    | (opt_utrace ? flag_opt_utrace : 0)
     5 ( 0.00%)   1 ( 0.00%) 0              1 ( 0.00%)   0           0               0           0           0           	    | (opt_xmalloc ? flag_opt_xmalloc : 0);
     .            .          .              .            .           .               .           .           .           
     4 ( 0.00%)   0          0              1 ( 0.00%)   0           0               1 ( 0.00%)  0           0           	malloc_slow = (malloc_slow_flags != 0);
     3 ( 0.00%)   0          0              2 ( 0.00%)   0           0               0           0           0           }
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           /* Number of sources for initializing malloc_conf */
     .            .          .              .            .           .               .           .           .           #define MALLOC_CONF_NSOURCES 5
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           static const char *
    30 ( 0.00%)   2 ( 0.00%) 2 ( 0.03%)     0            0           0              15 ( 0.00%)  1 ( 0.02%)  1 ( 0.02%)  obtain_malloc_conf(unsigned which_source, char buf[PATH_MAX + 1]) {
    15 ( 0.00%)   0          0              0            0           0               0           0           0           	if (config_debug) {
     .            .          .              .            .           .               .           .           .           		static unsigned read_source = 0;
     .            .          .              .            .           .               .           .           .           		/*
     .            .          .              .            .           .               .           .           .           		 * Each source should only be read once, to minimize # of
     .            .          .              .            .           .               .           .           .           		 * syscalls on init.
     .            .          .              .            .           .               .           .           .           		 */
     .            .          .              .            .           .               .           .           .           		assert(read_source++ == which_source);
     .            .          .              .            .           .               .           .           .           	}
    20 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)     0            0           0               0           0           0           	assert(which_source < MALLOC_CONF_NSOURCES);
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           	const char *ret;
    50 ( 0.00%)   2 ( 0.00%) 2 ( 0.03%)    15 ( 0.00%)   1 ( 0.02%)  1 ( 0.03%)      0           0           0           	switch (which_source) {
     .            .          .              .            .           .               .           .           .           	case 0:
     2 ( 0.00%)   0          0              0            0           0               1 ( 0.00%)  0           0           		ret = config_malloc_conf;
     1 ( 0.00%)   0          0              0            0           0               0           0           0           		break;
     .            .          .              .            .           .               .           .           .           	case 1:
     4 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)     1 ( 0.00%)   0           0               0           0           0           		if (je_malloc_conf != NULL) {
     .            .          .              .            .           .               .           .           .           			/* Use options that were compiled into the program. */
     .            .          .              .            .           .               .           .           .           			ret = je_malloc_conf;
     .            .          .              .            .           .               .           .           .           		} else {
     .            .          .              .            .           .               .           .           .           			/* No configuration specified. */
     1 ( 0.00%)   0          0              0            0           0               1 ( 0.00%)  0           0           			ret = NULL;
     .            .          .              .            .           .               .           .           .           		}
     1 ( 0.00%)   0          0              0            0           0               0           0           0           		break;
     .            .          .              .            .           .               .           .           .           	case 2: {
     1 ( 0.00%)   0          0              0            0           0               1 ( 0.00%)  0           0           		ssize_t linklen = 0;
     .            .          .              .            .           .               .           .           .           #ifndef _WIN32
     3 ( 0.00%)   0          0              1 ( 0.00%)   0           0               2 ( 0.00%)  0           0           		int saved_errno = errno;
     2 ( 0.00%)   0          0              0            0           0               1 ( 0.00%)  0           0           		const char *linkname =
     .            .          .              .            .           .               .           .           .           #  ifdef JEMALLOC_PREFIX
     .            .          .              .            .           .               .           .           .           		    "/etc/"JEMALLOC_PREFIX"malloc.conf"
     .            .          .              .            .           .               .           .           .           #  else
     .            .          .              .            .           .               .           .           .           		    "/etc/malloc.conf"
     .            .          .              .            .           .               .           .           .           #  endif
     .            .          .              .            .           .               .           .           .           		    ;
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           		/*
     .            .          .              .            .           .               .           .           .           		 * Try to use the contents of the "/etc/malloc.conf" symbolic
     .            .          .              .            .           .               .           .           .           		 * link's name.
     .            .          .              .            .           .               .           .           .           		 */
     .            .          .              .            .           .               .           .           .           #ifndef JEMALLOC_READLINKAT
     7 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)     2 ( 0.00%)   0           0               2 ( 0.00%)  0           0           		linklen = readlink(linkname, buf, PATH_MAX);
     .            .          .              .            .           .               .           .           .           #else
     .            .          .              .            .           .               .           .           .           		linklen = readlinkat(AT_FDCWD, linkname, buf, PATH_MAX);
     .            .          .              .            .           .               .           .           .           #endif
     2 ( 0.00%)   0          0              1 ( 0.00%)   0           0               0           0           0           		if (linklen == -1) {
     .            .          .              .            .           .               .           .           .           			/* No configuration specified. */
     1 ( 0.00%)   0          0              0            0           0               1 ( 0.00%)  0           0           			linklen = 0;
     .            .          .              .            .           .               .           .           .           			/* Restore errno. */
     3 ( 0.00%)   0          0              1 ( 0.00%)   0           0               1 ( 0.00%)  0           0           			set_errno(saved_errno);
     .            .          .              .            .           .               .           .           .           		}
     .            .          .              .            .           .               .           .           .           #endif
     4 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)     2 ( 0.00%)   0           0               1 ( 0.00%)  0           0           		buf[linklen] = '\0';
     2 ( 0.00%)   0          0              1 ( 0.00%)   0           0               1 ( 0.00%)  0           0           		ret = buf;
     1 ( 0.00%)   0          0              0            0           0               0           0           0           		break;
     .            .          .              .            .           .               .           .           .           	} case 3: {
     2 ( 0.00%)   0          0              0            0           0               1 ( 0.00%)  0           0           		const char *envname =
     .            .          .              .            .           .               .           .           .           #ifdef JEMALLOC_PREFIX
     .            .          .              .            .           .               .           .           .           		    JEMALLOC_CPREFIX"MALLOC_CONF"
     .            .          .              .            .           .               .           .           .           #else
     .            .          .              .            .           .               .           .           .           		    "MALLOC_CONF"
     .            .          .              .            .           .               .           .           .           #endif
     .            .          .              .            .           .               .           .           .           		    ;
     .            .          .              .            .           .               .           .           .           
     6 ( 0.00%)   0          0              2 ( 0.00%)   0           0               2 ( 0.00%)  0           0           		if ((ret = jemalloc_secure_getenv(envname)) != NULL) {
     .            .          .              .            .           .               .           .           .           			/*
     .            .          .              .            .           .               .           .           .           			 * Do nothing; opts is already initialized to the value
     .            .          .              .            .           .               .           .           .           			 * of the MALLOC_CONF environment variable.
     .            .          .              .            .           .               .           .           .           			 */
     .            .          .              .            .           .               .           .           .           		} else {
     .            .          .              .            .           .               .           .           .           			/* No configuration specified. */
     1 ( 0.00%)   0          0              0            0           0               1 ( 0.00%)  0           0           			ret = NULL;
     .            .          .              .            .           .               .           .           .           		}
     2 ( 0.00%)   0          0              0            0           0               0           0           0           		break;
     .            .          .              .            .           .               .           .           .           	} case 4: {
     2 ( 0.00%)   0          0              1 ( 0.00%)   0           0               1 ( 0.00%)  0           0           		ret = je_malloc_conf_2_conf_harder;
     1 ( 0.00%)   0          0              0            0           0               0           0           0           		break;
     .            .          .              .            .           .               .           .           .           	} default:
     .            .          .              .            .           .               .           .           .           		not_reached();
     .            .          .              .            .           .               .           .           .           		ret = NULL;
     .            .          .              .            .           .               .           .           .           	}
     5 ( 0.00%)   0          0              5 ( 0.00%)   0           0               0           0           0           	return ret;
    10 ( 0.00%)   0          0             10 ( 0.00%)   0           0               0           0           0           }
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           static void
     .            .          .              .            .           .               .           .           .           malloc_conf_init_helper(sc_data_t *sc_data, unsigned bin_shard_sizes[SC_NBINS],
     .            .          .              .            .           .               .           .           .               bool initial_call, const char *opts_cache[MALLOC_CONF_NSOURCES],
    28 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)     2 ( 0.00%)   0           0              16 ( 0.00%)  3 ( 0.06%)  3 ( 0.07%)      char buf[PATH_MAX + 1]) {
     .            .          .              .            .           .               .           .           .           	static const char *opts_explain[MALLOC_CONF_NSOURCES] = {
     .            .          .              .            .           .               .           .           .           		"string specified via --with-malloc-conf",
     .            .          .              .            .           .               .           .           .           		"string pointed to by the global variable malloc_conf",
     .            .          .              .            .           .               .           .           .           		"\"name\" of the file referenced by the symbolic link named "
     .            .          .              .            .           .               .           .           .           		    "/etc/malloc.conf",
     .            .          .              .            .           .               .           .           .           		"value of the environment variable MALLOC_CONF",
     .            .          .              .            .           .               .           .           .           		"string pointed to by the global variable "
     .            .          .              .            .           .               .           .           .           		    "malloc_conf_2_conf_harder",
     .            .          .              .            .           .               .           .           .           	};
     .            .          .              .            .           .               .           .           .           	unsigned i;
     .            .          .              .            .           .               .           .           .           	const char *opts, *k, *v;
     .            .          .              .            .           .               .           .           .           	size_t klen, vlen;
     .            .          .              .            .           .               .           .           .           
    50 ( 0.00%)   3 ( 0.00%) 3 ( 0.04%)    24 ( 0.00%)   0           0              10 ( 0.00%)  1 ( 0.02%)  1 ( 0.02%)  	for (i = 0; i < MALLOC_CONF_NSOURCES; i++) {
     .            .          .              .            .           .               .           .           .           		/* Get runtime configuration. */
    20 ( 0.00%)   0          0             10 ( 0.00%)   0           0               0           0           0           		if (initial_call) {
    50 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)    20 ( 0.00%)   0           0              10 ( 0.00%)  0           0           			opts_cache[i] = obtain_malloc_conf(i, buf);
     .            .          .              .            .           .               .           .           .           		}
    60 ( 0.00%)   0          0             30 ( 0.00%)   0           0              10 ( 0.00%)  0           0           		opts = opts_cache[i];
    55 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)    15 ( 0.00%)   0           0               0           0           0           		if (!initial_call && opt_confirm_conf) {
     .            .          .              .            .           .               .           .           .           			malloc_printf(
     .            .          .              .            .           .               .           .           .           			    "<jemalloc>: malloc_conf #%u (%s): \"%s\"\n",
     .            .          .              .            .           .               .           .           .           			    i + 1, opts_explain[i], opts != NULL ? opts : "");
     .            .          .              .            .           .               .           .           .           		}
    30 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)    10 ( 0.00%)   0           0               0           0           0           		if (opts == NULL) {
     6 ( 0.00%)   0          0              0            0           0               0           0           0           			continue;
     .            .          .              .            .           .               .           .           .           		}
     .            .          .              .            .           .               .           .           .           
    20 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)     8 ( 0.00%)   1 ( 0.02%)  1 ( 0.03%)      0           0           0           		while (*opts != '\0' && !malloc_conf_next(&opts, &k, &klen, &v,
     .            .          .              .            .           .               .           .           .           		    &vlen)) {
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           #define CONF_ERROR(msg, k, klen, v, vlen)				\
     .            .          .              .            .           .               .           .           .           			if (!initial_call) {				\
     .            .          .              .            .           .               .           .           .           				malloc_conf_error(			\
     .            .          .              .            .           .               .           .           .           				    msg, k, klen, v, vlen);		\
     .            .          .              .            .           .               .           .           .           				cur_opt_valid = false;			\
     .            .          .              .            .           .               .           .           .           			}
-- line 1105 ----------------------------------------
-- line 1717 ----------------------------------------
     .            .          .              .            .           .               .           .           .           #undef CONF_HANDLE_T_SIGNED
     .            .          .              .            .           .               .           .           .           #undef CONF_HANDLE_UNSIGNED
     .            .          .              .            .           .               .           .           .           #undef CONF_HANDLE_SIZE_T
     .            .          .              .            .           .               .           .           .           #undef CONF_HANDLE_SSIZE_T
     .            .          .              .            .           .               .           .           .           #undef CONF_HANDLE_CHAR_P
     .            .          .              .            .           .               .           .           .               /* Re-enable diagnostic "-Wtype-limits" */
     .            .          .              .            .           .               .           .           .               JEMALLOC_DIAGNOSTIC_POP
     .            .          .              .            .           .               .           .           .           		}
    12 ( 0.00%)   0          0              4 ( 0.00%)   1 ( 0.02%)  1 ( 0.03%)      0           0           0           		if (opt_abort_conf && had_conf_error) {
     .            .          .              .            .           .               .           .           .           			malloc_abort_invalid_conf();
     .            .          .              .            .           .               .           .           .           		}
     .            .          .              .            .           .               .           .           .           	}
     .            .          .              .            .           .               .           .           .           	atomic_store_b(&log_init_done, true, ATOMIC_RELEASE);
    14 ( 0.00%)   0          0             10 ( 0.00%)   0           0               0           0           0           }
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           static bool
     3 ( 0.00%)   0          0              0            0           0               1 ( 0.00%)  0           0           malloc_conf_init_check_deps(void) {
     4 ( 0.00%)   0          0              1 ( 0.00%)   1 ( 0.02%)  1 ( 0.03%)      0           0           0           	if (opt_prof_leak_error && !opt_prof_final) {
     .            .          .              .            .           .               .           .           .           		malloc_printf("<jemalloc>: prof_leak_error is set w/o "
     .            .          .              .            .           .               .           .           .           		    "prof_final.\n");
     .            .          .              .            .           .               .           .           .           		return true;
     .            .          .              .            .           .               .           .           .           	}
     .            .          .              .            .           .               .           .           .           
     1 ( 0.00%)   0          0              0            0           0               0           0           0           	return false;
     2 ( 0.00%)   0          0              2 ( 0.00%)   0           0               0           0           0           }
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           static void
    11 ( 0.00%)   2 ( 0.00%) 2 ( 0.03%)     2 ( 0.00%)   1 ( 0.02%)  1 ( 0.03%)      4 ( 0.00%)  1 ( 0.02%)  1 ( 0.02%)  malloc_conf_init(sc_data_t *sc_data, unsigned bin_shard_sizes[SC_NBINS]) {
     5 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)     0            0           0               5 ( 0.00%)  0           0           	const char *opts_cache[MALLOC_CONF_NSOURCES] = {NULL, NULL, NULL, NULL,
     .            .          .              .            .           .               .           .           .           		NULL};
     .            .          .              .            .           .               .           .           .           	char buf[PATH_MAX + 1];
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           	/* The first call only set the confirm_conf option and opts_cache */
     8 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)     0            0           0               1 ( 0.00%)  0           0           	malloc_conf_init_helper(NULL, NULL, true, opts_cache, buf);
     8 ( 0.00%)   0          0              2 ( 0.00%)   0           0               1 ( 0.00%)  0           0           	malloc_conf_init_helper(sc_data, bin_shard_sizes, false, opts_cache,
     .            .          .              .            .           .               .           .           .           	    NULL);
     3 ( 0.00%)   0          0              0            0           0               1 ( 0.00%)  0           0           	if (malloc_conf_init_check_deps()) {
     .            .          .              .            .           .               .           .           .           		/* check_deps does warning msg only; abort below if needed. */
     .            .          .              .            .           .               .           .           .           		if (opt_abort_conf) {
     .            .          .              .            .           .               .           .           .           			malloc_abort_invalid_conf();
     .            .          .              .            .           .               .           .           .           		}
     .            .          .              .            .           .               .           .           .           	}
     6 ( 0.00%)   0          0              4 ( 0.00%)   0           0               0           0           0           }
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           #undef MALLOC_CONF_NSOURCES
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           static bool
     7 ( 0.00%)   2 ( 0.00%) 2 ( 0.03%)     1 ( 0.00%)   0           0               2 ( 0.00%)  0           0           malloc_init_hard_needed(void) {
     7 ( 0.00%)   0          0              1 ( 0.00%)   1 ( 0.02%)  1 ( 0.03%)      1 ( 0.00%)  0           0           	if (malloc_initialized() || (IS_INITIALIZER && malloc_init_state ==
     .            .          .              .            .           .               .           .           .           	    malloc_init_recursible)) {
     .            .          .              .            .           .               .           .           .           		/*
     .            .          .              .            .           .               .           .           .           		 * Another thread initialized the allocator before this one
     .            .          .              .            .           .               .           .           .           		 * acquired init_lock, or this thread is the initializing
     .            .          .              .            .           .               .           .           .           		 * thread, and it is recursively allocating.
     .            .          .              .            .           .               .           .           .           		 */
     .            .          .              .            .           .               .           .           .           		return false;
     .            .          .              .            .           .               .           .           .           	}
     .            .          .              .            .           .               .           .           .           #ifdef JEMALLOC_THREADED_INIT
     3 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)     1 ( 0.00%)   0           0               0           0           0           	if (malloc_initializer != NO_INITIALIZER && !IS_INITIALIZER) {
     .            .          .              .            .           .               .           .           .           		/* Busy-wait until the initializing thread completes. */
     .            .          .              .            .           .               .           .           .           		spin_t spinner = SPIN_INITIALIZER;
     .            .          .              .            .           .               .           .           .           		do {
     .            .          .              .            .           .               .           .           .           			malloc_mutex_unlock(TSDN_NULL, &init_lock);
     .            .          .              .            .           .               .           .           .           			spin_adaptive(&spinner);
     .            .          .              .            .           .               .           .           .           			malloc_mutex_lock(TSDN_NULL, &init_lock);
     .            .          .              .            .           .               .           .           .           		} while (!malloc_initialized());
     .            .          .              .            .           .               .           .           .           		return false;
     .            .          .              .            .           .               .           .           .           	}
     .            .          .              .            .           .               .           .           .           #endif
     1 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)     0            0           0               0           0           0           	return true;
     5 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)     4 ( 0.00%)   0           0               0           0           0           }
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           static bool
    10 ( 0.00%)   0          0              2 ( 0.00%)   1 ( 0.02%)  0               3 ( 0.00%)  0           0           malloc_init_hard_a0_locked() {
     2 ( 0.00%)   0          0              0            0           0               2 ( 0.00%)  1 ( 0.02%)  0           	malloc_initializer = INITIALIZER;
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           	JEMALLOC_DIAGNOSTIC_PUSH
     .            .          .              .            .           .               .           .           .           	JEMALLOC_DIAGNOSTIC_IGNORE_MISSING_STRUCT_FIELD_INITIALIZERS
   827 ( 0.01%)   1 ( 0.00%) 1 ( 0.01%)     0            0           0             822 ( 0.03%) 69 ( 1.30%)  3 ( 0.07%)  	sc_data_t sc_data = {0};
     .            .          .              .            .           .               .           .           .           	JEMALLOC_DIAGNOSTIC_POP
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           	/*
     .            .          .              .            .           .               .           .           .           	 * Ordering here is somewhat tricky; we need sc_boot() first, since that
     .            .          .              .            .           .               .           .           .           	 * determines what the size classes will be, and then
     .            .          .              .            .           .               .           .           .           	 * malloc_conf_init(), since any slab size tweaking will need to be done
     .            .          .              .            .           .               .           .           .           	 * before sz_boot and bin_info_boot, which assume that the values they
     .            .          .              .            .           .               .           .           .           	 * read out of sc_data_global are final.
     .            .          .              .            .           .               .           .           .           	 */
     3 ( 0.00%)   0          0              0            0           0               1 ( 0.00%)  0           0           	sc_boot(&sc_data);
     .            .          .              .            .           .               .           .           .           	unsigned bin_shard_sizes[SC_NBINS];
     3 ( 0.00%)   0          0              0            0           0               1 ( 0.00%)  0           0           	bin_shard_sizes_boot(bin_shard_sizes);
     .            .          .              .            .           .               .           .           .           	/*
     .            .          .              .            .           .               .           .           .           	 * prof_boot0 only initializes opt_prof_prefix.  We need to do it before
     .            .          .              .            .           .               .           .           .           	 * we parse malloc_conf options, in case malloc_conf parsing overwrites
     .            .          .              .            .           .               .           .           .           	 * it.
     .            .          .              .            .           .               .           .           .           	 */
     3 ( 0.00%)   0          0              0            0           0               0           0           0           	if (config_prof) {
     .            .          .              .            .           .               .           .           .           		prof_boot0();
     .            .          .              .            .           .               .           .           .           	}
     5 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)     0            0           0               1 ( 0.00%)  0           0           	malloc_conf_init(&sc_data, bin_shard_sizes);
     4 ( 0.00%)   0          0              1 ( 0.00%)   1 ( 0.02%)  0               1 ( 0.00%)  0           0           	san_init(opt_lg_san_uaf_align);
     6 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)     1 ( 0.00%)   1 ( 0.02%)  0               1 ( 0.00%)  0           0           	sz_boot(&sc_data, opt_cache_oblivious);
     5 ( 0.00%)   0          0              0            0           0               1 ( 0.00%)  0           0           	bin_info_boot(&sc_data, bin_shard_sizes);
     .            .          .              .            .           .               .           .           .           
     4 ( 0.00%)   0          0              1 ( 0.00%)   1 ( 0.02%)  1 ( 0.03%)      0           0           0           	if (opt_stats_print) {
     .            .          .              .            .           .               .           .           .           		/* Print statistics at exit. */
     .            .          .              .            .           .               .           .           .           		if (atexit(stats_print_atexit) != 0) {
     .            .          .              .            .           .               .           .           .           			malloc_write("<jemalloc>: Error in atexit()\n");
     .            .          .              .            .           .               .           .           .           			if (opt_abort) {
     .            .          .              .            .           .               .           .           .           				abort();
     .            .          .              .            .           .               .           .           .           			}
     .            .          .              .            .           .               .           .           .           		}
     .            .          .              .            .           .               .           .           .           	}
     .            .          .              .            .           .               .           .           .           
     3 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)     0            0           0               1 ( 0.00%)  0           0           	if (stats_boot()) {
     .            .          .              .            .           .               .           .           .           		return true;
     .            .          .              .            .           .               .           .           .           	}
     3 ( 0.00%)   0          0              0            0           0               1 ( 0.00%)  0           0           	if (pages_boot()) {
     .            .          .              .            .           .               .           .           .           		return true;
     .            .          .              .            .           .               .           .           .           	}
     4 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)     0            0           0               1 ( 0.00%)  0           0           	if (base_boot(TSDN_NULL)) {
     .            .          .              .            .           .               .           .           .           		return true;
     .            .          .              .            .           .               .           .           .           	}
     .            .          .              .            .           .               .           .           .           	/* emap_global is static, hence zeroed. */
     8 ( 0.00%)   0          0              0            0           0               2 ( 0.00%)  0           0           	if (emap_init(&arena_emap_global, b0get(), /* zeroed */ true)) {
     .            .          .              .            .           .               .           .           .           		return true;
     .            .          .              .            .           .               .           .           .           	}
     3 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)     0            0           0               1 ( 0.00%)  0           0           	if (extent_boot()) {
     .            .          .              .            .           .               .           .           .           		return true;
     .            .          .              .            .           .               .           .           .           	}
     3 ( 0.00%)   0          0              0            0           0               1 ( 0.00%)  0           0           	if (ctl_boot()) {
     .            .          .              .            .           .               .           .           .           		return true;
     .            .          .              .            .           .               .           .           .           	}
     3 ( 0.00%)   0          0              0            0           0               0           0           0           	if (config_prof) {
     .            .          .              .            .           .               .           .           .           		prof_boot1();
     .            .          .              .            .           .               .           .           .           	}
     3 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)     1 ( 0.00%)   1 ( 0.02%)  1 ( 0.03%)      0           0           0           	if (opt_hpa && !hpa_supported()) {
     .            .          .              .            .           .               .           .           .           		malloc_printf("<jemalloc>: HPA not supported in the current "
     .            .          .              .            .           .               .           .           .           		    "configuration; %s.",
     .            .          .              .            .           .               .           .           .           		    opt_abort_conf ? "aborting" : "disabling");
     .            .          .              .            .           .               .           .           .           		if (opt_abort_conf) {
     .            .          .              .            .           .               .           .           .           			malloc_abort_invalid_conf();
     .            .          .              .            .           .               .           .           .           		} else {
     .            .          .              .            .           .               .           .           .           			opt_hpa = false;
     .            .          .              .            .           .               .           .           .           		}
     .            .          .              .            .           .               .           .           .           	}
    11 ( 0.00%)   2 ( 0.00%) 2 ( 0.03%)     1 ( 0.00%)   0           0               2 ( 0.00%)  0           0           	if (arena_boot(&sc_data, b0get(), opt_hpa)) {
     .            .          .              .            .           .               .           .           .           		return true;
     .            .          .              .            .           .               .           .           .           	}
     6 ( 0.00%)   0          0              0            0           0               2 ( 0.00%)  0           0           	if (tcache_boot(TSDN_NULL, b0get())) {
     .            .          .              .            .           .               .           .           .           		return true;
     .            .          .              .            .           .               .           .           .           	}
     9 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)     0            0           0               1 ( 0.00%)  0           0           	if (malloc_mutex_init(&arenas_lock, "arenas", WITNESS_RANK_ARENAS,
     .            .          .              .            .           .               .           .           .           	    malloc_mutex_rank_exclusive)) {
     .            .          .              .            .           .               .           .           .           		return true;
     .            .          .              .            .           .               .           .           .           	}
     2 ( 0.00%)   0          0              0            0           0               1 ( 0.00%)  0           0           	hook_boot();
     .            .          .              .            .           .               .           .           .           	/*
     .            .          .              .            .           .               .           .           .           	 * Create enough scaffolding to allow recursive allocation in
     .            .          .              .            .           .               .           .           .           	 * malloc_ncpus().
     .            .          .              .            .           .               .           .           .           	 */
     1 ( 0.00%)   0          0              0            0           0               1 ( 0.00%)  0           0           	narenas_auto = 1;
     3 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)     1 ( 0.00%)   0           0               1 ( 0.00%)  0           0           	manual_arena_base = narenas_auto + 1;
     8 ( 0.00%)   0          0              1 ( 0.00%)   0           0               1 ( 0.00%)  0           0           	memset(arenas, 0, sizeof(arena_t *) * narenas_auto);
     .            .          .              .            .           .               .           .           .           	/*
     .            .          .              .            .           .               .           .           .           	 * Initialize one arena here.  The rest are lazily created in
     .            .          .              .            .           .               .           .           .           	 * arena_choose_hard().
     .            .          .              .            .           .               .           .           .           	 */
     7 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)     0            0           0               1 ( 0.00%)  0           0           	if (arena_init(TSDN_NULL, 0, &arena_config_default) == NULL) {
     .            .          .              .            .           .               .           .           .           		return true;
     .            .          .              .            .           .               .           .           .           	}
     5 ( 0.00%)   0          0              0            0           0               2 ( 0.00%)  1 ( 0.02%)  0           	a0 = arena_get(TSDN_NULL, 0, false);
     .            .          .              .            .           .               .           .           .           
     3 ( 0.00%)   0          0              1 ( 0.00%)   0           0               0           0           0           	if (opt_hpa && !hpa_supported()) {
     .            .          .              .            .           .               .           .           .           		malloc_printf("<jemalloc>: HPA not supported in the current "
     .            .          .              .            .           .               .           .           .           		    "configuration; %s.",
     .            .          .              .            .           .               .           .           .           		    opt_abort_conf ? "aborting" : "disabling");
     .            .          .              .            .           .               .           .           .           		if (opt_abort_conf) {
     .            .          .              .            .           .               .           .           .           			malloc_abort_invalid_conf();
     .            .          .              .            .           .               .           .           .           		} else {
     .            .          .              .            .           .               .           .           .           			opt_hpa = false;
     .            .          .              .            .           .               .           .           .           		}
     3 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)     1 ( 0.00%)   0           0               0           0           0           	} else if (opt_hpa) {
     .            .          .              .            .           .               .           .           .           		hpa_shard_opts_t hpa_shard_opts = opt_hpa_opts;
     .            .          .              .            .           .               .           .           .           		hpa_shard_opts.deferral_allowed = background_thread_enabled();
     .            .          .              .            .           .               .           .           .           		if (pa_shard_enable_hpa(TSDN_NULL, &a0->pa_shard,
     .            .          .              .            .           .               .           .           .           		    &hpa_shard_opts, &opt_hpa_sec_opts)) {
     .            .          .              .            .           .               .           .           .           			return true;
     .            .          .              .            .           .               .           .           .           		}
     .            .          .              .            .           .               .           .           .           	}
     .            .          .              .            .           .               .           .           .           
     1 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)     0            0           0               1 ( 0.00%)  1 ( 0.02%)  0           	malloc_init_state = malloc_init_a0_initialized;
     .            .          .              .            .           .               .           .           .           
     1 ( 0.00%)   0          0              0            0           0               0           0           0           	return false;
     6 ( 0.00%)   0          0              5 ( 0.00%)   1 ( 0.02%)  0               0           0           0           }
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           static bool
     .            .          .              .            .           .               .           .           .           malloc_init_hard_a0(void) {
     .            .          .              .            .           .               .           .           .           	bool ret;
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           	malloc_mutex_lock(TSDN_NULL, &init_lock);
     .            .          .              .            .           .               .           .           .           	ret = malloc_init_hard_a0_locked();
     .            .          .              .            .           .               .           .           .           	malloc_mutex_unlock(TSDN_NULL, &init_lock);
     .            .          .              .            .           .               .           .           .           	return ret;
     .            .          .              .            .           .               .           .           .           }
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           /* Initialize data structures which may trigger recursive allocation. */
     .            .          .              .            .           .               .           .           .           static bool
     4 ( 0.00%)   2 ( 0.00%) 1 ( 0.01%)     0            0           0               1 ( 0.00%)  0           0           malloc_init_hard_recursible(void) {
     1 ( 0.00%)   0          0              0            0           0               1 ( 0.00%)  0           0           	malloc_init_state = malloc_init_recursible;
     .            .          .              .            .           .               .           .           .           
     2 ( 0.00%)   0          0              0            0           0               2 ( 0.00%)  1 ( 0.02%)  0           	ncpus = malloc_ncpus();
     4 ( 0.00%)   0          0              1 ( 0.00%)   1 ( 0.02%)  0               0           0           0           	if (opt_percpu_arena != percpu_arena_disabled) {
     .            .          .              .            .           .               .           .           .           		bool cpu_count_is_deterministic =
     .            .          .              .            .           .               .           .           .           		    malloc_cpu_count_is_deterministic();
     .            .          .              .            .           .               .           .           .           		if (!cpu_count_is_deterministic) {
     .            .          .              .            .           .               .           .           .           			/*
     .            .          .              .            .           .               .           .           .           			 * If # of CPU is not deterministic, and narenas not
     .            .          .              .            .           .               .           .           .           			 * specified, disables per cpu arena since it may not
     .            .          .              .            .           .               .           .           .           			 * detect CPU IDs properly.
     .            .          .              .            .           .               .           .           .           			 */
-- line 1937 ----------------------------------------
-- line 1949 ----------------------------------------
     .            .          .              .            .           .               .           .           .           			}
     .            .          .              .            .           .               .           .           .           		}
     .            .          .              .            .           .               .           .           .           	}
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           #if (defined(JEMALLOC_HAVE_PTHREAD_ATFORK) && !defined(JEMALLOC_MUTEX_INIT_CB) \
     .            .          .              .            .           .               .           .           .               && !defined(JEMALLOC_ZONE) && !defined(_WIN32) && \
     .            .          .              .            .           .               .           .           .               !defined(__native_client__))
     .            .          .              .            .           .               .           .           .           	/* LinuxThreads' pthread_atfork() allocates. */
     9 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)     0            0           0               1 ( 0.00%)  0           0           	if (pthread_atfork(jemalloc_prefork, jemalloc_postfork_parent,
     .            .          .              .            .           .               .           .           .           	    jemalloc_postfork_child) != 0) {
     .            .          .              .            .           .               .           .           .           		malloc_write("<jemalloc>: Error in pthread_atfork()\n");
     .            .          .              .            .           .               .           .           .           		if (opt_abort) {
     .            .          .              .            .           .               .           .           .           			abort();
     .            .          .              .            .           .               .           .           .           		}
     .            .          .              .            .           .               .           .           .           		return true;
     .            .          .              .            .           .               .           .           .           	}
     .            .          .              .            .           .               .           .           .           #endif
     .            .          .              .            .           .               .           .           .           
     3 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)     0            0           0               1 ( 0.00%)  0           0           	if (background_thread_boot0()) {
     .            .          .              .            .           .               .           .           .           		return true;
     .            .          .              .            .           .               .           .           .           	}
     .            .          .              .            .           .               .           .           .           
     1 ( 0.00%)   0          0              0            0           0               0           0           0           	return false;
     2 ( 0.00%)   0          0              2 ( 0.00%)   0           0               0           0           0           }
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           static unsigned
     4 ( 0.00%)   0          0              0            0           0               1 ( 0.00%)  0           0           malloc_narenas_default(void) {
     4 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)     0            0           0               0           0           0           	assert(ncpus > 0);
     .            .          .              .            .           .               .           .           .           	/*
     .            .          .              .            .           .               .           .           .           	 * For SMP systems, create more than one arena per CPU by
     .            .          .              .            .           .               .           .           .           	 * default.
     .            .          .              .            .           .               .           .           .           	 */
     3 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)     1 ( 0.00%)   0           0               0           0           0           	if (ncpus > 1) {
     3 ( 0.00%)   0          0              1 ( 0.00%)   0           0               1 ( 0.00%)  0           0           		fxp_t fxp_ncpus = FXP_INIT_INT(ncpus);
     6 ( 0.00%)   0          0              2 ( 0.00%)   1 ( 0.02%)  0               2 ( 0.00%)  0           0           		fxp_t goal = fxp_mul(fxp_ncpus, opt_narenas_ratio);
     4 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)     1 ( 0.00%)   0           0               2 ( 0.00%)  0           0           		uint32_t int_goal = fxp_round_nearest(goal);
     2 ( 0.00%)   0          0              1 ( 0.00%)   0           0               0           0           0           		if (int_goal == 0) {
     .            .          .              .            .           .               .           .           .           			return 1;
     .            .          .              .            .           .               .           .           .           		}
     2 ( 0.00%)   0          0              1 ( 0.00%)   0           0               0           0           0           		return int_goal;
     .            .          .              .            .           .               .           .           .           	} else {
     .            .          .              .            .           .               .           .           .           		return 1;
     .            .          .              .            .           .               .           .           .           	}
     2 ( 0.00%)   0          0              2 ( 0.00%)   0           0               0           0           0           }
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           static percpu_arena_mode_t
     5 ( 0.00%)   0          0              0            0           0               2 ( 0.00%)  0           0           percpu_arena_as_initialized(percpu_arena_mode_t mode) {
     4 ( 0.00%)   0          0              0            0           0               0           0           0           	assert(!malloc_initialized());
     4 ( 0.00%)   2 ( 0.00%) 2 ( 0.03%)     0            0           0               0           0           0           	assert(mode <= percpu_arena_disabled);
     .            .          .              .            .           .               .           .           .           
     2 ( 0.00%)   0          0              1 ( 0.00%)   0           0               0           0           0           	if (mode != percpu_arena_disabled) {
     .            .          .              .            .           .               .           .           .           		mode += percpu_arena_mode_enabled_base;
     .            .          .              .            .           .               .           .           .           	}
     .            .          .              .            .           .               .           .           .           
     1 ( 0.00%)   0          0              1 ( 0.00%)   0           0               0           0           0           	return mode;
     2 ( 0.00%)   0          0              2 ( 0.00%)   0           0               0           0           0           }
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           static bool
     4 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)     0            0           0               1 ( 0.00%)  0           0           malloc_init_narenas(void) {
     4 ( 0.00%)   0          0              0            0           0               0           0           0           	assert(ncpus > 0);
     .            .          .              .            .           .               .           .           .           
     4 ( 0.00%)   2 ( 0.00%) 2 ( 0.03%)     1 ( 0.00%)   0           0               0           0           0           	if (opt_percpu_arena != percpu_arena_disabled) {
     .            .          .              .            .           .               .           .           .           		if (!have_percpu_arena || malloc_getcpu() < 0) {
     .            .          .              .            .           .               .           .           .           			opt_percpu_arena = percpu_arena_disabled;
     .            .          .              .            .           .               .           .           .           			malloc_printf("<jemalloc>: perCPU arena getcpu() not "
     .            .          .              .            .           .               .           .           .           			    "available. Setting narenas to %u.\n", opt_narenas ?
     .            .          .              .            .           .               .           .           .           			    opt_narenas : malloc_narenas_default());
     .            .          .              .            .           .               .           .           .           			if (opt_abort) {
     .            .          .              .            .           .               .           .           .           				abort();
     .            .          .              .            .           .               .           .           .           			}
-- line 2018 ----------------------------------------
-- line 2051 ----------------------------------------
     .            .          .              .            .           .               .           .           .           				 * of affinity setting from numactl), reserving
     .            .          .              .            .           .               .           .           .           				 * narenas this way provides a workaround for
     .            .          .              .            .           .               .           .           .           				 * percpu_arena.
     .            .          .              .            .           .               .           .           .           				 */
     .            .          .              .            .           .               .           .           .           				opt_narenas = n;
     .            .          .              .            .           .               .           .           .           			}
     .            .          .              .            .           .               .           .           .           		}
     .            .          .              .            .           .               .           .           .           	}
     3 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)     1 ( 0.00%)   0           0               0           0           0           	if (opt_narenas == 0) {
     2 ( 0.00%)   0          0              0            0           0               2 ( 0.00%)  0           0           		opt_narenas = malloc_narenas_default();
     .            .          .              .            .           .               .           .           .           	}
     4 ( 0.00%)   0          0              0            0           0               0           0           0           	assert(opt_narenas > 0);
     .            .          .              .            .           .               .           .           .           
     2 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)     1 ( 0.00%)   0           0               1 ( 0.00%)  0           0           	narenas_auto = opt_narenas;
     .            .          .              .            .           .               .           .           .           	/*
     .            .          .              .            .           .               .           .           .           	 * Limit the number of arenas to the indexing range of MALLOCX_ARENA().
     .            .          .              .            .           .               .           .           .           	 */
     3 ( 0.00%)   0          0              1 ( 0.00%)   0           0               0           0           0           	if (narenas_auto >= MALLOCX_ARENA_LIMIT) {
     .            .          .              .            .           .               .           .           .           		narenas_auto = MALLOCX_ARENA_LIMIT - 1;
     .            .          .              .            .           .               .           .           .           		malloc_printf("<jemalloc>: Reducing narenas to limit (%d)\n",
     .            .          .              .            .           .               .           .           .           		    narenas_auto);
     .            .          .              .            .           .               .           .           .           	}
     3 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)     1 ( 0.00%)   0           0               1 ( 0.00%)  0           0           	narenas_total_set(narenas_auto);
     3 ( 0.00%)   0          0              0            0           0               1 ( 0.00%)  0           0           	if (arena_init_huge()) {
     1 ( 0.00%)   0          0              0            0           0               1 ( 0.00%)  0           0           		narenas_total_inc();
     .            .          .              .            .           .               .           .           .           	}
     2 ( 0.00%)   0          0              0            0           0               2 ( 0.00%)  0           0           	manual_arena_base = narenas_total_get();
     .            .          .              .            .           .               .           .           .           
     1 ( 0.00%)   0          0              0            0           0               0           0           0           	return false;
     2 ( 0.00%)   0          0              2 ( 0.00%)   0           0               0           0           0           }
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           static void
     3 ( 0.00%)   0          0              0            0           0               1 ( 0.00%)  0           0           malloc_init_percpu(void) {
     6 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)     1 ( 0.00%)   0           0               2 ( 0.00%)  0           0           	opt_percpu_arena = percpu_arena_as_initialized(opt_percpu_arena);
     3 ( 0.00%)   0          0              2 ( 0.00%)   0           0               0           0           0           }
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           static bool
     3 ( 0.00%)   0          0              0            0           0               1 ( 0.00%)  0           0           malloc_init_hard_finish(void) {
     3 ( 0.00%)   0          0              0            0           0               1 ( 0.00%)  0           0           	if (malloc_mutex_boot()) {
     .            .          .              .            .           .               .           .           .           		return true;
     .            .          .              .            .           .               .           .           .           	}
     .            .          .              .            .           .               .           .           .           
     1 ( 0.00%)   0          0              0            0           0               1 ( 0.00%)  0           0           	malloc_init_state = malloc_init_initialized;
     1 ( 0.00%)   0          0              0            0           0               1 ( 0.00%)  0           0           	malloc_slow_flag_init();
     .            .          .              .            .           .               .           .           .           
     1 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)     0            0           0               0           0           0           	return false;
     2 ( 0.00%)   0          0              2 ( 0.00%)   0           0               0           0           0           }
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           static void
     .            .          .              .            .           .               .           .           .           malloc_init_hard_cleanup(tsdn_t *tsdn, bool reentrancy_set) {
     .            .          .              .            .           .               .           .           .           	malloc_mutex_assert_owner(tsdn, &init_lock);
     .            .          .              .            .           .               .           .           .           	malloc_mutex_unlock(tsdn, &init_lock);
     .            .          .              .            .           .               .           .           .           	if (reentrancy_set) {
     .            .          .              .            .           .               .           .           .           		assert(!tsdn_null(tsdn));
     .            .          .              .            .           .               .           .           .           		tsd_t *tsd = tsdn_tsd(tsdn);
     .            .          .              .            .           .               .           .           .           		assert(tsd_reentrancy_level_get(tsd) > 0);
     .            .          .              .            .           .               .           .           .           		post_reentrancy(tsd);
     .            .          .              .            .           .               .           .           .           	}
     .            .          .              .            .           .               .           .           .           }
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           static bool
     4 ( 0.00%)   2 ( 0.00%) 2 ( 0.03%)     0            0           0               1 ( 0.00%)  0           0           malloc_init_hard(void) {
     .            .          .              .            .           .               .           .           .           	tsd_t *tsd;
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           #if defined(_WIN32) && _WIN32_WINNT < 0x0600
     .            .          .              .            .           .               .           .           .           	_init_init_lock();
     .            .          .              .            .           .               .           .           .           #endif
     4 ( 0.00%)   0          0              0            0           0               1 ( 0.00%)  0           0           	malloc_mutex_lock(TSDN_NULL, &init_lock);
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           #define UNLOCK_RETURN(tsdn, ret, reentrancy)		\
     .            .          .              .            .           .               .           .           .           	malloc_init_hard_cleanup(tsdn, reentrancy);	\
     .            .          .              .            .           .               .           .           .           	return ret;
     .            .          .              .            .           .               .           .           .           
     4 ( 0.00%)   0          0              0            0           0               1 ( 0.00%)  0           0           	if (!malloc_init_hard_needed()) {
     .            .          .              .            .           .               .           .           .           		UNLOCK_RETURN(TSDN_NULL, false, false)
     .            .          .              .            .           .               .           .           .           	}
     .            .          .              .            .           .               .           .           .           
     5 ( 0.00%)   2 ( 0.00%) 1 ( 0.01%)     1 ( 0.00%)   0           0               0           0           0           	if (malloc_init_state != malloc_init_a0_initialized &&
     2 ( 0.00%)   0          0              0            0           0               1 ( 0.00%)  0           0           	    malloc_init_hard_a0_locked()) {
     .            .          .              .            .           .               .           .           .           		UNLOCK_RETURN(TSDN_NULL, true, false)
     .            .          .              .            .           .               .           .           .           	}
     .            .          .              .            .           .               .           .           .           
     4 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)     0            0           0               1 ( 0.00%)  0           0           	malloc_mutex_unlock(TSDN_NULL, &init_lock);
     .            .          .              .            .           .               .           .           .           	/* Recursive allocation relies on functional tsd. */
     2 ( 0.00%)   1 ( 0.00%) 0              0            0           0               2 ( 0.00%)  1 ( 0.02%)  0           	tsd = malloc_tsd_boot0();
     2 ( 0.00%)   0          0              1 ( 0.00%)   0           0               0           0           0           	if (tsd == NULL) {
     .            .          .              .            .           .               .           .           .           		return true;
     .            .          .              .            .           .               .           .           .           	}
     3 ( 0.00%)   0          0              0            0           0               1 ( 0.00%)  0           0           	if (malloc_init_hard_recursible()) {
     2 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)     1 ( 0.00%)   0           0               1 ( 0.00%)  0           0           		return true;
     .            .          .              .            .           .               .           .           .           	}
     .            .          .              .            .           .               .           .           .           
     4 ( 0.00%)   0          0              0            0           0               1 ( 0.00%)  0           0           	malloc_mutex_lock(tsd_tsdn(tsd), &init_lock);
     .            .          .              .            .           .               .           .           .           	/* Set reentrancy level to 1 during init. */
     4 ( 0.00%)   0          0              1 ( 0.00%)   0           0               1 ( 0.00%)  0           0           	pre_reentrancy(tsd, NULL);
     .            .          .              .            .           .               .           .           .           	/* Initialize narenas before prof_boot2 (for allocation). */
     3 ( 0.00%)   0          0              0            0           0               1 ( 0.00%)  0           0           	if (malloc_init_narenas()
     9 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)     1 ( 0.00%)   0           0               3 ( 0.00%)  0           0           	    || background_thread_boot1(tsd_tsdn(tsd), b0get())) {
     .            .          .              .            .           .               .           .           .           		UNLOCK_RETURN(tsd_tsdn(tsd), true, true)
     .            .          .              .            .           .               .           .           .           	}
     3 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)     0            0           0               0           0           0           	if (config_prof && prof_boot2(tsd, b0get())) {
     .            .          .              .            .           .               .           .           .           		UNLOCK_RETURN(tsd_tsdn(tsd), true, true)
     .            .          .              .            .           .               .           .           .           	}
     .            .          .              .            .           .               .           .           .           
     1 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)     0            0           0               1 ( 0.00%)  0           0           	malloc_init_percpu();
     .            .          .              .            .           .               .           .           .           
     3 ( 0.00%)   0          0              0            0           0               1 ( 0.00%)  0           0           	if (malloc_init_hard_finish()) {
     .            .          .              .            .           .               .           .           .           		UNLOCK_RETURN(tsd_tsdn(tsd), true, true)
     .            .          .              .            .           .               .           .           .           	}
     5 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)     2 ( 0.00%)   0           0               2 ( 0.00%)  1 ( 0.02%)  0           	post_reentrancy(tsd);
     6 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)     1 ( 0.00%)   0           0               2 ( 0.00%)  1 ( 0.02%)  0           	malloc_mutex_unlock(tsd_tsdn(tsd), &init_lock);
     .            .          .              .            .           .               .           .           .           
     2 ( 0.00%)   0          0              0            0           0               1 ( 0.00%)  0           0           	witness_assert_lockless(witness_tsd_tsdn(
     .            .          .              .            .           .               .           .           .           	    tsd_witness_tsdp_get_unsafe(tsd)));
     3 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)     0            0           0               3 ( 0.00%)  0           0           	malloc_tsd_boot1();
     .            .          .              .            .           .               .           .           .           	/* Update TSD after tsd_boot1. */
     1 ( 0.00%)   0          0              0            0           0               1 ( 0.00%)  0           0           	tsd = tsd_fetch();
     4 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)     1 ( 0.00%)   0           0               0           0           0           	if (opt_background_thread) {
     .            .          .              .            .           .               .           .           .           		assert(have_background_thread);
     .            .          .              .            .           .               .           .           .           		/*
     .            .          .              .            .           .               .           .           .           		 * Need to finish init & unlock first before creating background
     .            .          .              .            .           .               .           .           .           		 * threads (pthread_create depends on malloc).  ctl_init (which
     .            .          .              .            .           .               .           .           .           		 * sets isthreaded) needs to be called without holding any lock.
     .            .          .              .            .           .               .           .           .           		 */
     .            .          .              .            .           .               .           .           .           		background_thread_ctl_init(tsd_tsdn(tsd));
     .            .          .              .            .           .               .           .           .           		if (background_thread_create(tsd, 0)) {
     .            .          .              .            .           .               .           .           .           			return true;
     .            .          .              .            .           .               .           .           .           		}
     .            .          .              .            .           .               .           .           .           	}
     .            .          .              .            .           .               .           .           .           #undef UNLOCK_RETURN
     1 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)     0            0           0               0           0           0           	return false;
     2 ( 0.00%)   0          0              2 ( 0.00%)   0           0               0           0           0           }
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           /*
     .            .          .              .            .           .               .           .           .            * End initialization functions.
     .            .          .              .            .           .               .           .           .            */
     .            .          .              .            .           .               .           .           .           /******************************************************************************/
     .            .          .              .            .           .               .           .           .           /*
     .            .          .              .            .           .               .           .           .            * Begin allocation-path internal functions and data structures.
     .            .          .              .            .           .               .           .           .            */
-- line 2190 ----------------------------------------
-- line 2237 ----------------------------------------
     .            .          .              .            .           .               .           .           .           	/*
     .            .          .              .            .           .               .           .           .           	 * Return size.
     .            .          .              .            .           .               .           .           .           	 */
     .            .          .              .            .           .               .           .           .           	bool usize;
     .            .          .              .            .           .               .           .           .           };
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           JEMALLOC_ALWAYS_INLINE void
     .            .          .              .            .           .               .           .           .           static_opts_init(static_opts_t *static_opts) {
    34 ( 0.00%)   0          0             17 ( 0.00%)   0           0              17 ( 0.00%)  5 ( 0.09%)  0           	static_opts->may_overflow = false;
    34 ( 0.00%)   0          0             17 ( 0.00%)   0           0              17 ( 0.00%)  0           0           	static_opts->bump_empty_aligned_alloc = false;
    34 ( 0.00%)   0          0             17 ( 0.00%)   0           0              17 ( 0.00%)  0           0           	static_opts->assert_nonempty_alloc = false;
    34 ( 0.00%)  16 ( 0.01%) 1 ( 0.01%)    17 ( 0.00%)   0           0              17 ( 0.00%)  0           0           	static_opts->null_out_result_on_error = false;
    34 ( 0.00%)   0          0             17 ( 0.00%)   0           0              17 ( 0.00%)  0           0           	static_opts->set_errno_on_error = false;
    34 ( 0.00%)   0          0             17 ( 0.00%)   0           0              17 ( 0.00%)  0           0           	static_opts->min_alignment = 0;
    51 ( 0.00%)   0          0             17 ( 0.00%)   0           0              17 ( 0.00%)  2 ( 0.04%)  0           	static_opts->oom_string = "";
    51 ( 0.00%)  16 ( 0.01%) 1 ( 0.01%)    17 ( 0.00%)   0           0              17 ( 0.00%)  0           0           	static_opts->invalid_alignment_string = "";
    34 ( 0.00%)   0          0             17 ( 0.00%)   0           0              17 ( 0.00%)  0           0           	static_opts->slow = false;
    34 ( 0.00%)   0          0             17 ( 0.00%)   0           0              17 ( 0.00%)  0           0           	static_opts->usize = false;
    51 ( 0.00%)   0          0              0            0           0              17 ( 0.00%)  1 ( 0.02%)  0           }
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           /*
     .            .          .              .            .           .               .           .           .            * These correspond to the macros in jemalloc/jemalloc_macros.h.  Broadly, we
     .            .          .              .            .           .               .           .           .            * should have one constant here per magic value there.  Note however that the
     .            .          .              .            .           .               .           .           .            * representations need not be related.
     .            .          .              .            .           .               .           .           .            */
     .            .          .              .            .           .               .           .           .           #define TCACHE_IND_NONE ((unsigned)-1)
     .            .          .              .            .           .               .           .           .           #define TCACHE_IND_AUTOMATIC ((unsigned)-2)
-- line 2263 ----------------------------------------
-- line 2272 ----------------------------------------
     .            .          .              .            .           .               .           .           .           	size_t alignment;
     .            .          .              .            .           .               .           .           .           	bool zero;
     .            .          .              .            .           .               .           .           .           	unsigned tcache_ind;
     .            .          .              .            .           .               .           .           .           	unsigned arena_ind;
     .            .          .              .            .           .               .           .           .           };
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           JEMALLOC_ALWAYS_INLINE void
     .            .          .              .            .           .               .           .           .           dynamic_opts_init(dynamic_opts_t *dynamic_opts) {
    34 ( 0.00%)   0          0             17 ( 0.00%)   0           0              17 ( 0.00%)  5 ( 0.09%)  0           	dynamic_opts->result = NULL;
    34 ( 0.00%)  16 ( 0.01%) 1 ( 0.01%)    17 ( 0.00%)   0           0              17 ( 0.00%)  0           0           	dynamic_opts->usize = 0;
    34 ( 0.00%)   0          0             17 ( 0.00%)   0           0              17 ( 0.00%)  1 ( 0.02%)  0           	dynamic_opts->num_items = 0;
    34 ( 0.00%)   0          0             17 ( 0.00%)   0           0              17 ( 0.00%)  0           0           	dynamic_opts->item_size = 0;
    34 ( 0.00%)   0          0             17 ( 0.00%)   0           0              17 ( 0.00%)  1 ( 0.02%)  0           	dynamic_opts->alignment = 0;
    34 ( 0.00%)   0          0             17 ( 0.00%)   0           0              17 ( 0.00%)  0           0           	dynamic_opts->zero = false;
    34 ( 0.00%)  16 ( 0.01%) 1 ( 0.01%)    17 ( 0.00%)   0           0              17 ( 0.00%)  0           0           	dynamic_opts->tcache_ind = TCACHE_IND_AUTOMATIC;
    34 ( 0.00%)   0          0             17 ( 0.00%)   0           0              17 ( 0.00%)  3 ( 0.06%)  0           	dynamic_opts->arena_ind = ARENA_IND_AUTOMATIC;
    17 ( 0.00%)   0          0              0            0           0               0           0           0           }
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           /*
     .            .          .              .            .           .               .           .           .            * ind parameter is optional and is only checked and filled if alignment == 0;
     .            .          .              .            .           .               .           .           .            * return true if result is out of range.
     .            .          .              .            .           .               .           .           .            */
     .            .          .              .            .           .               .           .           .           JEMALLOC_ALWAYS_INLINE bool
     .            .          .              .            .           .               .           .           .           aligned_usize_get(size_t size, size_t alignment, size_t *usize, szind_t *ind,
     .            .          .              .            .           .               .           .           .               bool bump_empty_aligned_alloc) {
13,044 ( 0.14%)  34 ( 0.02%) 0          4,188 ( 0.17%)   0           0           5,584 ( 0.18%)  0           0           	assert(usize != NULL);
   454 ( 0.00%)  48 ( 0.03%) 3 ( 0.04%)   120 ( 0.00%)   0           0             214 ( 0.01%)  0           0           	if (alignment == 0) {
   916 ( 0.01%)  16 ( 0.01%) 1 ( 0.01%)   137 ( 0.01%)   0           0             445 ( 0.01%)  0           0           		if (ind != NULL) {
    53 ( 0.00%)  16 ( 0.01%) 1 ( 0.01%)    17 ( 0.00%)   0           0              36 ( 0.00%)  0           0           			*ind = sz_size2index(size);
   138 ( 0.00%)  19 ( 0.01%) 1 ( 0.01%)    34 ( 0.00%)   0           0              19 ( 0.00%)  0           0           			if (unlikely(*ind >= SC_NSIZES)) {
     .            .          .              .            .           .               .           .           .           				return true;
     .            .          .              .            .           .               .           .           .           			}
    85 ( 0.00%)   0          0             51 ( 0.00%)   0           0              34 ( 0.00%)  3 ( 0.06%)  0           			*usize = sz_index2size(*ind);
    78 ( 0.00%)   3 ( 0.00%) 1 ( 0.01%)     5 ( 0.00%)   0           0               5 ( 0.00%)  1 ( 0.02%)  0           			assert(*usize > 0 && *usize <= SC_LARGE_MAXCLASS);
   230 ( 0.00%)  61 ( 0.04%) 3 ( 0.04%)    98 ( 0.00%)   0           0              98 ( 0.00%)  2 ( 0.04%)  2 ( 0.05%)  			return false;
     .            .          .              .            .           .               .           .           .           		}
   309 ( 0.00%)  61 ( 0.04%) 2 ( 0.03%)   103 ( 0.00%)   0           0             103 ( 0.00%)  0           0           		*usize = sz_s2u(size);
     .            .          .              .            .           .               .           .           .           	} else {
     .            .          .              .            .           .               .           .           .           		if (bump_empty_aligned_alloc && unlikely(size == 0)) {
     .            .          .              .            .           .               .           .           .           			size = 1;
     .            .          .              .            .           .               .           .           .           		}
     1 ( 0.00%)   0          0              0            0           0               0           0           0           		*usize = sz_sa2u(size, alignment);
     .            .          .              .            .           .               .           .           .           	}
 1,542 ( 0.02%)  40 ( 0.03%) 4 ( 0.06%)   413 ( 0.02%)   0           0               1 ( 0.00%)  0           0           	if (unlikely(*usize == 0 || *usize > SC_LARGE_MAXCLASS)) {
    24 ( 0.00%)   1 ( 0.00%) 0              6 ( 0.00%)   0           0               6 ( 0.00%)  2 ( 0.04%)  1 ( 0.02%)  		return true;
     .            .          .              .            .           .               .           .           .           	}
   100 ( 0.00%)   0          0              0            0           0               2 ( 0.00%)  0           0           	return false;
     .            .          .              .            .           .               .           .           .           }
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           JEMALLOC_ALWAYS_INLINE bool
     .            .          .              .            .           .               .           .           .           zero_get(bool guarantee, bool slow) {
 1,037 ( 0.01%)  33 ( 0.02%) 1 ( 0.01%)   243 ( 0.01%)   0           0              10 ( 0.00%)  0           0           	if (config_fill && slow && unlikely(opt_zero)) {
   109 ( 0.00%)   0          0              0            0           0             109 ( 0.00%)  0           0           		return true;
     .            .          .              .            .           .               .           .           .           	} else {
   442 ( 0.00%)   0          0            442 ( 0.02%)   0           0               0           0           0           		return guarantee;
     .            .          .              .            .           .               .           .           .           	}
     .            .          .              .            .           .               .           .           .           }
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           JEMALLOC_ALWAYS_INLINE tcache_t *
     .            .          .              .            .           .               .           .           .           tcache_get_from_ind(tsd_t *tsd, unsigned tcache_ind, bool slow, bool is_alloc) {
     .            .          .              .            .           .               .           .           .           	tcache_t *tcache;
 2,839 ( 0.03%) 105 ( 0.07%) 2 ( 0.03%) 1,092 ( 0.04%)   0           0             584 ( 0.02%)  0           0           	if (tcache_ind == TCACHE_IND_AUTOMATIC) {
 9,368 ( 0.10%) 188 ( 0.13%) 3 ( 0.04%) 2,960 ( 0.12%)   0           0           2,113 ( 0.07%)  3 ( 0.06%)  2 ( 0.05%)  		if (likely(!slow)) {
     .            .          .              .            .           .               .           .           .           			/* Getting tcache ptr unconditionally. */
 1,462 ( 0.02%)   0          0             48 ( 0.00%)   0           0           1,390 ( 0.04%)  3 ( 0.06%)  2 ( 0.05%)  			tcache = tsd_tcachep_get(tsd);
 4,283 ( 0.05%)  73 ( 0.05%) 2 ( 0.03%)   266 ( 0.01%)   0           0             233 ( 0.01%)  0           0           			assert(tcache == tcache_get(tsd));
 1,240 ( 0.01%)  92 ( 0.06%) 4 ( 0.06%)   588 ( 0.02%)   0           0             520 ( 0.02%)  8 ( 0.15%)  6 ( 0.14%)  		} else if (is_alloc ||
    44 ( 0.00%)  11 ( 0.01%) 2 ( 0.03%)     6 ( 0.00%)   0           0              33 ( 0.00%)  0           0           		    likely(tsd_reentrancy_level_get(tsd) == 0)) {
   582 ( 0.01%)   0          0             90 ( 0.00%)   0           0             272 ( 0.01%)  6 ( 0.11%)  2 ( 0.05%)  			tcache = tcache_get(tsd);
     .            .          .              .            .           .               .           .           .           		} else {
   238 ( 0.00%)  36 ( 0.02%) 1 ( 0.01%)    20 ( 0.00%)   0           0             216 ( 0.01%)  0           0           			tcache = NULL;
     .            .          .              .            .           .               .           .           .           		}
     .            .          .              .            .           .               .           .           .           	} else {
     .            .          .              .            .           .               .           .           .           		/*
     .            .          .              .            .           .               .           .           .           		 * Should not specify tcache on deallocation path when being
     .            .          .              .            .           .               .           .           .           		 * reentrant.
     .            .          .              .            .           .               .           .           .           		 */
25,664 ( 0.27%)  12 ( 0.01%) 2 ( 0.03%)    84 ( 0.00%)   0           0           8,720 ( 0.28%)  0           0           		assert(is_alloc || tsd_reentrancy_level_get(tsd) == 0 ||
     .            .          .              .            .           .               .           .           .           		    tsd_state_nocleanup(tsd));
   130 ( 0.00%)   0          0             40 ( 0.00%)   0           0              87 ( 0.00%)  0           0           		if (tcache_ind == TCACHE_IND_NONE) {
    49 ( 0.00%)  27 ( 0.02%) 2 ( 0.03%)     3 ( 0.00%)   0           0              40 ( 0.00%)  0           0           			tcache = NULL;
     .            .          .              .            .           .               .           .           .           		} else {
    78 ( 0.00%)  18 ( 0.01%) 1 ( 0.01%)    40 ( 0.00%)   0           0              38 ( 0.00%)  0           0           			tcache = tcaches_get(tsd, tcache_ind);
     .            .          .              .            .           .               .           .           .           		}
     .            .          .              .            .           .               .           .           .           	}
 1,118 ( 0.01%) 241 ( 0.17%) 4 ( 0.06%) 1,044 ( 0.04%)   0           0              74 ( 0.00%)  0           0           	return tcache;
     .            .          .              .            .           .               .           .           .           }
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           /* Return true if a manual arena is specified and arena_get() OOMs. */
     .            .          .              .            .           .               .           .           .           JEMALLOC_ALWAYS_INLINE bool
     .            .          .              .            .           .               .           .           .           arena_get_from_ind(tsd_t *tsd, unsigned arena_ind, arena_t **arena_p) {
   427 ( 0.00%)   0          0            115 ( 0.00%)   0           0             197 ( 0.01%)  0           0           	if (arena_ind == ARENA_IND_AUTOMATIC) {
     .            .          .              .            .           .               .           .           .           		/*
     .            .          .              .            .           .               .           .           .           		 * In case of automatic arena management, we defer arena
     .            .          .              .            .           .               .           .           .           		 * computation until as late as we can, hoping to fill the
     .            .          .              .            .           .               .           .           .           		 * allocation out of the tcache.
     .            .          .              .            .           .               .           .           .           		 */
   510 ( 0.01%)  16 ( 0.01%) 1 ( 0.01%)   115 ( 0.00%)   0           0             280 ( 0.01%)  8 ( 0.15%)  0           		*arena_p = NULL;
     .            .          .              .            .           .               .           .           .           	} else {
   495 ( 0.01%)  19 ( 0.01%) 1 ( 0.01%)   138 ( 0.01%)   1 ( 0.02%)  0             165 ( 0.01%)  0           0           		*arena_p = arena_get(tsd_tsdn(tsd), arena_ind, true);
16,887 ( 0.18%)   5 ( 0.00%) 1 ( 0.01%) 3,404 ( 0.14%)   0           0           6,680 ( 0.21%)  0           0           		if (unlikely(*arena_p == NULL) && arena_ind >= narenas_auto) {
10,069 ( 0.11%)   0          0              0            0           0           3,399 ( 0.11%)  0           0           			return true;
     .            .          .              .            .           .               .           .           .           		}
     .            .          .              .            .           .               .           .           .           	}
   192 ( 0.00%) 114 ( 0.08%) 2 ( 0.03%)     0            0           0              64 ( 0.00%)  0           0           	return false;
     .            .          .              .            .           .               .           .           .           }
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           /* ind is ignored if dopts->alignment > 0. */
     .            .          .              .            .           .               .           .           .           JEMALLOC_ALWAYS_INLINE void *
     .            .          .              .            .           .               .           .           .           imalloc_no_sample(static_opts_t *sopts, dynamic_opts_t *dopts, tsd_t *tsd,
     .            .          .              .            .           .               .           .           .               size_t size, size_t usize, szind_t ind) {
     .            .          .              .            .           .               .           .           .           	/* Fill in the tcache. */
 1,257 ( 0.01%)  23 ( 0.02%) 1 ( 0.01%)   305 ( 0.01%)   0           0             536 ( 0.02%) 20 ( 0.38%) 15 ( 0.36%)  	tcache_t *tcache = tcache_get_from_ind(tsd, dopts->tcache_ind,
 1,731 ( 0.02%)  30 ( 0.02%) 2 ( 0.03%)   448 ( 0.02%)   0           0           1,003 ( 0.03%)  0           0           	    sopts->slow, /* is_alloc */ true);
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           	/* Fill in the arena. */
     .            .          .              .            .           .               .           .           .           	arena_t *arena;
   318 ( 0.00%)   0          0            115 ( 0.00%)   0           0              51 ( 0.00%)  2 ( 0.04%)  2 ( 0.05%)  	if (arena_get_from_ind(tsd, dopts->arena_ind, &arena)) {
   154 ( 0.00%)  20 ( 0.01%) 2 ( 0.03%)     0            0           0              90 ( 0.00%)  0           0           		return NULL;
     .            .          .              .            .           .               .           .           .           	}
     .            .          .              .            .           .               .           .           .           
   119 ( 0.00%)  16 ( 0.01%) 1 ( 0.01%)    34 ( 0.00%)   0           0               0           0           0           	if (unlikely(dopts->alignment != 0)) {
22,438 ( 0.24%)   1 ( 0.00%) 1 ( 0.01%) 3,452 ( 0.14%)   0           0          15,485 ( 0.49%)  0           0           		return ipalloct(tsd_tsdn(tsd), usize, dopts->alignment,
 6,446 ( 0.07%)   0          0          3,335 ( 0.14%)   0           0           2,983 ( 0.09%)  0           0           		    dopts->zero, tcache, arena);
     .            .          .              .            .           .               .           .           .           	}
     .            .          .              .            .           .               .           .           .           
 2,558 ( 0.03%)  16 ( 0.01%) 1 ( 0.01%)    68 ( 0.00%)   0           0           1,582 ( 0.05%)  7 ( 0.13%)  6 ( 0.14%)  	return iallocztm(tsd_tsdn(tsd), size, ind, dopts->zero, tcache, false,
 1,599 ( 0.02%)  16 ( 0.01%) 1 ( 0.01%)    34 ( 0.00%)   0           0           1,565 ( 0.05%)  0           0           	    arena, sopts->slow);
     .            .          .              .            .           .               .           .           .           }
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           JEMALLOC_ALWAYS_INLINE void *
     .            .          .              .            .           .               .           .           .           imalloc_sample(static_opts_t *sopts, dynamic_opts_t *dopts, tsd_t *tsd,
     .            .          .              .            .           .               .           .           .               size_t usize, szind_t ind) {
     .            .          .              .            .           .               .           .           .           	void *ret;
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           	/*
     .            .          .              .            .           .               .           .           .           	 * For small allocations, sampling bumps the usize.  If so, we allocate
     .            .          .              .            .           .               .           .           .           	 * from the ind_large bucket.
     .            .          .              .            .           .               .           .           .           	 */
     .            .          .              .            .           .               .           .           .           	szind_t ind_large;
     .            .          .              .            .           .               .           .           .           	size_t bumped_usize = usize;
     .            .          .              .            .           .               .           .           .           
   898 ( 0.01%)   0          0            449 ( 0.02%)   0           0               0           0           0           	dopts->alignment = prof_sample_align(dopts->alignment);
   449 ( 0.00%)   0          0            449 ( 0.02%)   0           0               0           0           0           	if (usize <= SC_SMALL_MAXCLASS) {
     4 ( 0.00%)   2 ( 0.00%) 1 ( 0.01%)     2 ( 0.00%)   0           0               0           0           0           		assert(((dopts->alignment == 0) ?
     .            .          .              .            .           .               .           .           .           		    sz_s2u(SC_LARGE_MINCLASS) :
     .            .          .              .            .           .               .           .           .           		    sz_sa2u(SC_LARGE_MINCLASS, dopts->alignment))
     .            .          .              .            .           .               .           .           .           			== SC_LARGE_MINCLASS);
     .            .          .              .            .           .               .           .           .           		ind_large = sz_size2index(SC_LARGE_MINCLASS);
     .            .          .              .            .           .               .           .           .           		bumped_usize = sz_s2u(SC_LARGE_MINCLASS);
   238 ( 0.00%)   0          0            119 ( 0.00%)   0           0             119 ( 0.00%)  0           0           		ret = imalloc_no_sample(sopts, dopts, tsd, bumped_usize,
     .            .          .              .            .           .               .           .           .           		    bumped_usize, ind_large);
   119 ( 0.00%)   0          0            119 ( 0.00%)   0           0               0           0           0           		if (unlikely(ret == NULL)) {
   238 ( 0.00%)   0          0              0            0           0             238 ( 0.01%)  0           0           			return NULL;
     .            .          .              .            .           .               .           .           .           		}
   714 ( 0.01%)  10 ( 0.01%) 1 ( 0.01%)     0            0           0             357 ( 0.01%)  0           0           		arena_prof_promote(tsd_tsdn(tsd), ret, usize);
     .            .          .              .            .           .               .           .           .           	} else {
    20 ( 0.00%)   0          0              0            0           0              10 ( 0.00%)  0           0           		ret = imalloc_no_sample(sopts, dopts, tsd, usize, usize, ind);
     .            .          .              .            .           .               .           .           .           	}
    45 ( 0.00%)   0          0             10 ( 0.00%)   0           0              30 ( 0.00%)  0           0           	assert(prof_sample_aligned(ret));
     .            .          .              .            .           .               .           .           .           
    10 ( 0.00%)   0          0              0            0           0               5 ( 0.00%)  0           0           	return ret;
     .            .          .              .            .           .               .           .           .           }
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           /*
     .            .          .              .            .           .               .           .           .            * Returns true if the allocation will overflow, and false otherwise.  Sets
     .            .          .              .            .           .               .           .           .            * *size to the product either way.
     .            .          .              .            .           .               .           .           .            */
     .            .          .              .            .           .               .           .           .           JEMALLOC_ALWAYS_INLINE bool
     .            .          .              .            .           .               .           .           .           compute_size_with_overflow(bool may_overflow, dynamic_opts_t *dopts,
     .            .          .              .            .           .               .           .           .               size_t *size) {
     .            .          .              .            .           .               .           .           .           	/*
     .            .          .              .            .           .               .           .           .           	 * This function is just num_items * item_size, except that we may have
     .            .          .              .            .           .               .           .           .           	 * to check for overflow.
     .            .          .              .            .           .               .           .           .           	 */
     .            .          .              .            .           .               .           .           .           
    68 ( 0.00%)  16 ( 0.01%) 1 ( 0.01%)    17 ( 0.00%)   0           0               0           0           0           	if (!may_overflow) {
    68 ( 0.00%)   0          0              0            0           0               0           0           0           		assert(dopts->num_items == 1);
    68 ( 0.00%)  16 ( 0.01%) 1 ( 0.01%)    51 ( 0.00%)   0           0              17 ( 0.00%)  0           0           		*size = dopts->item_size;
    34 ( 0.00%)   0          0              0            0           0               0           0           0           		return false;
     .            .          .              .            .           .               .           .           .           	}
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           	/* A size_t with its high-half bits all set to 1. */
     .            .          .              .            .           .               .           .           .           	static const size_t high_bits = SIZE_T_MAX << (sizeof(size_t) * 8 / 2);
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           	*size = dopts->item_size * dopts->num_items;
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           	if (unlikely(*size == 0)) {
-- line 2459 ----------------------------------------
-- line 2461 ----------------------------------------
     .            .          .              .            .           .               .           .           .           	}
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           	/*
     .            .          .              .            .           .               .           .           .           	 * We got a non-zero size, but we don't know if we overflowed to get
     .            .          .              .            .           .               .           .           .           	 * there.  To avoid having to do a divide, we'll be clever and note that
     .            .          .              .            .           .               .           .           .           	 * if both A and B can be represented in N/2 bits, then their product
     .            .          .              .            .           .               .           .           .           	 * can be represented in N bits (without the possibility of overflow).
     .            .          .              .            .           .               .           .           .           	 */
 1,466 ( 0.02%)   0          0            733 ( 0.03%)   0           0               0           0           0           	if (likely((high_bits & (dopts->num_items | dopts->item_size)) == 0)) {
 2,123 ( 0.02%)   0          0              0            0           0               0           0           0           		return false;
     .            .          .              .            .           .               .           .           .           	}
 3,551 ( 0.04%)   0          0              0            0           0           1,390 ( 0.04%)  0           0           	if (likely(*size / dopts->item_size == dopts->num_items)) {
 3,475 ( 0.04%)   5 ( 0.00%) 0              0            0           0           2,085 ( 0.07%)  0           0           		return false;
     .            .          .              .            .           .               .           .           .           	}
   695 ( 0.01%)   0          0              0            0           0             695 ( 0.02%)  0           0           	return true;
     .            .          .              .            .           .               .           .           .           }
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           JEMALLOC_ALWAYS_INLINE int
     .            .          .              .            .           .               .           .           .           imalloc_body(static_opts_t *sopts, dynamic_opts_t *dopts, tsd_t *tsd) {
     .            .          .              .            .           .               .           .           .           	/* Where the actual allocated memory will live. */
    17 ( 0.00%)   0          0              0            0           0              17 ( 0.00%)  1 ( 0.02%)  1 ( 0.02%)  	void *allocation = NULL;
     .            .          .              .            .           .               .           .           .           	/* Filled in by compute_size_with_overflow below. */
    17 ( 0.00%)   0          0              0            0           0              17 ( 0.00%)  6 ( 0.11%)  0           	size_t size = 0;
     .            .          .              .            .           .               .           .           .           	/*
     .            .          .              .            .           .               .           .           .           	 * The zero initialization for ind is actually dead store, in that its
     .            .          .              .            .           .               .           .           .           	 * value is reset before any branch on its value is taken.  Sometimes
     .            .          .              .            .           .               .           .           .           	 * though, it's convenient to pass it as arguments before this point.
     .            .          .              .            .           .               .           .           .           	 * To avoid undefined behavior then, we initialize it with dummy stores.
     .            .          .              .            .           .               .           .           .           	 */
    17 ( 0.00%)   0          0              0            0           0              17 ( 0.00%)  4 ( 0.08%)  0           	szind_t ind = 0;
     .            .          .              .            .           .               .           .           .           	/* usize will always be properly initialized. */
     .            .          .              .            .           .               .           .           .           	size_t usize;
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           	/* Reentrancy is only checked on slow path. */
     .            .          .              .            .           .               .           .           .           	int8_t reentrancy_level;
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           	/* Compute the amount of memory the user wants. */
   937 ( 0.01%)  32 ( 0.02%) 2 ( 0.03%)   106 ( 0.00%)   0           0             746 ( 0.02%)  2 ( 0.04%)  2 ( 0.05%)  	if (unlikely(compute_size_with_overflow(sopts->may_overflow, dopts,
     .            .          .              .            .           .               .           .           .           	    &size))) {
   107 ( 0.00%)   0          0            103 ( 0.00%)   0           0               4 ( 0.00%)  0           0           		goto label_oom;
     .            .          .              .            .           .               .           .           .           	}
     .            .          .              .            .           .               .           .           .           
   416 ( 0.00%)  32 ( 0.02%) 2 ( 0.03%)   136 ( 0.01%)   0           0              76 ( 0.00%)  0           0           	if (unlikely(dopts->alignment < sopts->min_alignment
     .            .          .              .            .           .               .           .           .           	    || (dopts->alignment & (dopts->alignment - 1)) != 0)) {
     .            .          .              .            .           .               .           .           .           		goto label_invalid_alignment;
     .            .          .              .            .           .               .           .           .           	}
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           	/* This is the beginning of the "core" algorithm. */
 3,948 ( 0.04%)  32 ( 0.02%) 2 ( 0.03%)   852 ( 0.04%)   0           0              51 ( 0.00%)  0           0           	dopts->zero = zero_get(dopts->zero, sopts->slow);
17,183 ( 0.18%) 176 ( 0.12%) 3 ( 0.04%)    68 ( 0.00%)   0           0          17,030 ( 0.54%)  2 ( 0.04%)  1 ( 0.02%)  	if (aligned_usize_get(size, dopts->alignment, &usize, &ind,
 6,812 ( 0.07%)   0          0             34 ( 0.00%)   0           0           6,778 ( 0.21%)  0           0           	    sopts->bump_empty_aligned_alloc)) {
   103 ( 0.00%)   0          0            103 ( 0.00%)   0           0               0           0           0           		goto label_oom;
     .            .          .              .            .           .               .           .           .           	}
    52 ( 0.00%)   0          0             34 ( 0.00%)   0           0              17 ( 0.00%)  0           0           	dopts->usize = usize;
     .            .          .              .            .           .               .           .           .           	/* Validate the user input. */
    69 ( 0.00%)  16 ( 0.01%) 1 ( 0.01%)    34 ( 0.00%)   0           0               0           0           0           	if (sopts->assert_nonempty_alloc) {
    39 ( 0.00%)  17 ( 0.01%) 2 ( 0.03%)    17 ( 0.00%)   0           0              18 ( 0.00%)  6 ( 0.11%)  5 ( 0.12%)  		assert (size != 0);
     .            .          .              .            .           .               .           .           .           	}
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           	check_entry_exit_locking(tsd_tsdn(tsd));
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           	/*
     .            .          .              .            .           .               .           .           .           	 * If we need to handle reentrancy, we can do it out of a
     .            .          .              .            .           .               .           .           .           	 * known-initialized arena (i.e. arena 0).
     .            .          .              .            .           .               .           .           .           	 */
    17 ( 0.00%)   0          0              0            0           0              17 ( 0.00%)  0           0           	reentrancy_level = tsd_reentrancy_level_get(tsd);
    71 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)    34 ( 0.00%)   0           0               1 ( 0.00%)  0           0           	if (sopts->slow && unlikely(reentrancy_level > 0)) {
     .            .          .              .            .           .               .           .           .           		/*
     .            .          .              .            .           .               .           .           .           		 * We should never specify particular arenas or tcaches from
     .            .          .              .            .           .               .           .           .           		 * within our internal allocations.
     .            .          .              .            .           .               .           .           .           		 */
     7 ( 0.00%)   1 ( 0.00%) 0              3 ( 0.00%)   2 ( 0.03%)  1 ( 0.03%)      1 ( 0.00%)  0           0           		assert(dopts->tcache_ind == TCACHE_IND_AUTOMATIC ||
     .            .          .              .            .           .               .           .           .           		    dopts->tcache_ind == TCACHE_IND_NONE);
 8,330 ( 0.09%)  26 ( 0.02%) 2 ( 0.03%)     0            0           0           8,330 ( 0.26%)  0           0           		assert(dopts->arena_ind == ARENA_IND_AUTOMATIC);
 1,470 ( 0.02%)  10 ( 0.01%) 1 ( 0.01%)     0            0           0             490 ( 0.02%)  0           0           		dopts->tcache_ind = TCACHE_IND_NONE;
     .            .          .              .            .           .               .           .           .           		/* We know that arena 0 has already been initialized. */
   980 ( 0.01%)   0          0              0            0           0             980 ( 0.03%)  0           0           		dopts->arena_ind = 0;
     .            .          .              .            .           .               .           .           .           	}
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           	/*
     .            .          .              .            .           .               .           .           .           	 * If dopts->alignment > 0, then ind is still 0, but usize was computed
     .            .          .              .            .           .               .           .           .           	 * in the previous if statement.  Down the positive alignment path,
     .            .          .              .            .           .               .           .           .           	 * imalloc_no_sample and imalloc_sample will ignore ind.
     .            .          .              .            .           .               .           .           .           	 */
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           	/* If profiling is on, get our profiling context. */
 2,876 ( 0.03%)  32 ( 0.02%) 2 ( 0.03%)   409 ( 0.02%)   0           0           2,221 ( 0.07%)  0           0           	if (config_prof && opt_prof) {
     .            .          .              .            .           .               .           .           .           		bool prof_active = prof_active_get_unlocked();
 2,817 ( 0.03%)   0          0              0            0           0               0           0           0           		bool sample_event = te_prof_sample_event_lookahead(tsd, usize);
    48 ( 0.00%)   0          0              0            0           0               0           0           0           		prof_tctx_t *tctx = prof_alloc_prep(tsd, prof_active,
     .            .          .              .            .           .               .           .           .           		    sample_event);
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           		emap_alloc_ctx_t alloc_ctx;
     .            .          .              .            .           .               .           .           .           		if (likely((uintptr_t)tctx == (uintptr_t)1U)) {
    24 ( 0.00%)   0          0             24 ( 0.00%)   0           0               0           0           0           			alloc_ctx.slab = (usize <= SC_SMALL_MAXCLASS);
    96 ( 0.00%)   0          0              0            0           0              96 ( 0.00%)  0           0           			allocation = imalloc_no_sample(
     .            .          .              .            .           .               .           .           .           			    sopts, dopts, tsd, usize, usize, ind);
     .            .          .              .            .           .               .           .           .           		} else if ((uintptr_t)tctx > (uintptr_t)1U) {
    20 ( 0.00%)   0          0              0            0           0               5 ( 0.00%)  0           0           			allocation = imalloc_sample(
     .            .          .              .            .           .               .           .           .           			    sopts, dopts, tsd, usize, ind);
     5 ( 0.00%)   0          0              0            0           0               5 ( 0.00%)  0           0           			alloc_ctx.slab = false;
     .            .          .              .            .           .               .           .           .           		} else {
    15 ( 0.00%)   5 ( 0.00%) 1 ( 0.01%)     0            0           0               0           0           0           			allocation = NULL;
     .            .          .              .            .           .               .           .           .           		}
     .            .          .              .            .           .               .           .           .           
    10 ( 0.00%)   0          0              0            0           0               0           0           0           		if (unlikely(allocation == NULL)) {
    15 ( 0.00%)   0          0              5 ( 0.00%)   0           0               0           0           0           			prof_alloc_rollback(tsd, tctx);
     .            .          .              .            .           .               .           .           .           			goto label_oom;
     .            .          .              .            .           .               .           .           .           		}
    55 ( 0.00%)  10 ( 0.01%) 2 ( 0.03%)    30 ( 0.00%)   0           0              25 ( 0.00%)  0           0           		prof_malloc(tsd, allocation, size, usize, &alloc_ctx, tctx);
     .            .          .              .            .           .               .           .           .           	} else {
   477 ( 0.01%)  16 ( 0.01%) 1 ( 0.01%)   214 ( 0.01%)   0           0             195 ( 0.01%)  0           0           		assert(!opt_prof);
   593 ( 0.01%)  32 ( 0.02%) 2 ( 0.03%)   226 ( 0.01%)   0           0             367 ( 0.01%) 19 ( 0.36%) 16 ( 0.38%)  		allocation = imalloc_no_sample(sopts, dopts, tsd, size, usize,
     .            .          .              .            .           .               .           .           .           		    ind);
    85 ( 0.00%)   0          0             17 ( 0.00%)   0           0               0           0           0           		if (unlikely(allocation == NULL)) {
   208 ( 0.00%)   0          0            105 ( 0.00%)   0           0             103 ( 0.00%)  0           0           			goto label_oom;
     .            .          .              .            .           .               .           .           .           		}
     .            .          .              .            .           .               .           .           .           	}
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           	/*
     .            .          .              .            .           .               .           .           .           	 * Allocation has been done at this point.  We still have some
     .            .          .              .            .           .               .           .           .           	 * post-allocation work to do though.
     .            .          .              .            .           .               .           .           .           	 */
     .            .          .              .            .           .               .           .           .           
   187 ( 0.00%)  15 ( 0.01%) 1 ( 0.01%)    85 ( 0.00%)   0           0             102 ( 0.00%) 12 ( 0.23%) 10 ( 0.24%)  	thread_alloc_event(tsd, usize);
     .            .          .              .            .           .               .           .           .           
   770 ( 0.01%)   0          0            351 ( 0.01%)   0           0             248 ( 0.01%)  0           0           	assert(dopts->alignment == 0
     .            .          .              .            .           .               .           .           .           	    || ((uintptr_t)allocation & (dopts->alignment - 1)) == ZU(0));
     .            .          .              .            .           .               .           .           .           
   115 ( 0.00%)  30 ( 0.02%) 2 ( 0.03%)    14 ( 0.00%)   0           0              33 ( 0.00%)  0           0           	assert(usize == isalloc(tsd_tsdn(tsd), allocation));
     .            .          .              .            .           .               .           .           .           
   133 ( 0.00%)  15 ( 0.01%) 1 ( 0.01%)    48 ( 0.00%)   0           0               0           0           0           	if (config_fill && sopts->slow && !dopts->zero
     .            .          .              .            .           .               .           .           .           	    && unlikely(opt_junk_alloc)) {
    34 ( 0.00%)  30 ( 0.02%) 2 ( 0.03%)    17 ( 0.00%)   0           0              17 ( 0.00%) 10 ( 0.19%)  6 ( 0.14%)  		junk_alloc_callback(allocation, usize);
     .            .          .              .            .           .               .           .           .           	}
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           	if (sopts->slow) {
     .            .          .              .            .           .               .           .           .           		UTRACE(0, size, allocation);
     .            .          .              .            .           .               .           .           .           	}
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           	/* Success! */
     .            .          .              .            .           .               .           .           .           	check_entry_exit_locking(tsd_tsdn(tsd));
   171 ( 0.00%)  15 ( 0.01%) 1 ( 0.01%)    51 ( 0.00%)   0           0             120 ( 0.00%)  2 ( 0.04%)  1 ( 0.02%)  	*dopts->result = allocation;
    19 ( 0.00%)   0          0              0            0           0               2 ( 0.00%)  0           0           	return 0;
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           label_oom:
     2 ( 0.00%)   0          0              2 ( 0.00%)   0           0               0           0           0           	if (unlikely(sopts->slow) && config_xmalloc && unlikely(opt_xmalloc)) {
     6 ( 0.00%)   0          0              2 ( 0.00%)   0           0               0           0           0           		malloc_write(sopts->oom_string);
     4 ( 0.00%)   0          0              2 ( 0.00%)   0           0               2 ( 0.00%)  0           0           		abort();
     .            .          .              .            .           .               .           .           .           	}
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           	if (sopts->slow) {
     .            .          .              .            .           .               .           .           .           		UTRACE(NULL, size, NULL);
     .            .          .              .            .           .               .           .           .           	}
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           	check_entry_exit_locking(tsd_tsdn(tsd));
     .            .          .              .            .           .               .           .           .           
-- line 2617 ----------------------------------------
-- line 2618 ----------------------------------------
     .            .          .              .            .           .               .           .           .           	if (sopts->set_errno_on_error) {
     .            .          .              .            .           .               .           .           .           		set_errno(ENOMEM);
     .            .          .              .            .           .               .           .           .           	}
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           	if (sopts->null_out_result_on_error) {
     .            .          .              .            .           .               .           .           .           		*dopts->result = NULL;
     .            .          .              .            .           .               .           .           .           	}
     .            .          .              .            .           .               .           .           .           
    19 ( 0.00%)   0          0              0            0           0              19 ( 0.00%)  0           0           	return ENOMEM;
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           	/*
     .            .          .              .            .           .               .           .           .           	 * This label is only jumped to by one goto; we move it out of line
     .            .          .              .            .           .               .           .           .           	 * anyways to avoid obscuring the non-error paths, and for symmetry with
     .            .          .              .            .           .               .           .           .           	 * the oom case.
     .            .          .              .            .           .               .           .           .           	 */
     .            .          .              .            .           .               .           .           .           label_invalid_alignment:
     .            .          .              .            .           .               .           .           .           	if (config_xmalloc && unlikely(opt_xmalloc)) {
-- line 2634 ----------------------------------------
-- line 2641 ----------------------------------------
     .            .          .              .            .           .               .           .           .           	}
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           	if (sopts->slow) {
     .            .          .              .            .           .               .           .           .           		UTRACE(NULL, size, NULL);
     .            .          .              .            .           .               .           .           .           	}
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           	check_entry_exit_locking(tsd_tsdn(tsd));
     .            .          .              .            .           .               .           .           .           
     2 ( 0.00%)   0          0              0            0           0               2 ( 0.00%)  0           0           	if (sopts->null_out_result_on_error) {
     6 ( 0.00%)   1 ( 0.00%) 0              4 ( 0.00%)   0           0               2 ( 0.00%)  0           0           		*dopts->result = NULL;
     .            .          .              .            .           .               .           .           .           	}
     .            .          .              .            .           .               .           .           .           
     2 ( 0.00%)   0          0              0            0           0               2 ( 0.00%)  0           0           	return EINVAL;
     .            .          .              .            .           .               .           .           .           }
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           JEMALLOC_ALWAYS_INLINE bool
     .            .          .              .            .           .               .           .           .           imalloc_init_check(static_opts_t *sopts, dynamic_opts_t *dopts) {
     .            .          .              .            .           .               .           .           .           	if (unlikely(!malloc_initialized()) && unlikely(malloc_init())) {
     .            .          .              .            .           .               .           .           .           		if (config_xmalloc && unlikely(opt_xmalloc)) {
     .            .          .              .            .           .               .           .           .           			malloc_write(sopts->oom_string);
    19 ( 0.00%)   0          0             19 ( 0.00%)   0           0               0           0           0           			abort();
     .            .          .              .            .           .               .           .           .           		}
     .            .          .              .            .           .               .           .           .           		UTRACE(NULL, dopts->num_items * dopts->item_size, NULL);
     .            .          .              .            .           .               .           .           .           		set_errno(ENOMEM);
    38 ( 0.00%)   0          0             19 ( 0.00%)   0           0              19 ( 0.00%)  0           0           		*dopts->result = NULL;
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           		return false;
     .            .          .              .            .           .               .           .           .           	}
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           	return true;
     .            .          .              .            .           .               .           .           .           }
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           /* Returns the errno-style error code of the allocation. */
     .            .          .              .            .           .               .           .           .           JEMALLOC_ALWAYS_INLINE int
     .            .          .              .            .           .               .           .           .           imalloc(static_opts_t *sopts, dynamic_opts_t *dopts) {
    68 ( 0.00%)  32 ( 0.02%) 2 ( 0.03%)     0            0           0              34 ( 0.00%)  1 ( 0.02%)  0           	if (tsd_get_allocates() && !imalloc_init_check(sopts, dopts)) {
     .            .          .              .            .           .               .           .           .           		return ENOMEM;
     .            .          .              .            .           .               .           .           .           	}
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           	/* We always need the tsd.  Let's grab it right away. */
    17 ( 0.00%)   0          0              0            0           0              17 ( 0.00%)  7 ( 0.13%)  4 ( 0.10%)  	tsd_t *tsd = tsd_fetch();
   136 ( 0.00%)  32 ( 0.02%) 2 ( 0.03%)    34 ( 0.00%)   0           0              34 ( 0.00%)  2 ( 0.04%)  2 ( 0.05%)  	assert(tsd);
    85 ( 0.00%)   0          0             17 ( 0.00%)   0           0              17 ( 0.00%)  4 ( 0.08%)  3 ( 0.07%)  	if (likely(tsd_fast(tsd))) {
     .            .          .              .            .           .               .           .           .           		/* Fast and common path. */
     .            .          .              .            .           .               .           .           .           		tsd_assert_fast(tsd);
   136 ( 0.00%)  16 ( 0.01%) 1 ( 0.01%)    68 ( 0.00%)   0           0              68 ( 0.00%)  6 ( 0.11%)  5 ( 0.12%)  		sopts->slow = false;
    17 ( 0.00%)  15 ( 0.01%) 1 ( 0.01%)     0            0           0               0           0           0           		return imalloc_body(sopts, dopts, tsd);
     .            .          .              .            .           .               .           .           .           	} else {
     .            .          .              .            .           .               .           .           .           		if (!tsd_get_allocates() && !imalloc_init_check(sopts, dopts)) {
     .            .          .              .            .           .               .           .           .           			return ENOMEM;
     .            .          .              .            .           .               .           .           .           		}
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           		sopts->slow = true;
     .            .          .              .            .           .               .           .           .           		return imalloc_body(sopts, dopts, tsd);
     .            .          .              .            .           .               .           .           .           	}
     .            .          .              .            .           .               .           .           .           }
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           JEMALLOC_NOINLINE
     .            .          .              .            .           .               .           .           .           void *
   612 ( 0.01%)  32 ( 0.02%) 1 ( 0.01%)   119 ( 0.00%)  71 ( 1.23%) 36 ( 1.00%)     85 ( 0.00%)  9 ( 0.17%)  2 ( 0.05%)  malloc_default(size_t size) {
     .            .          .              .            .           .               .           .           .           	void *ret;
     .            .          .              .            .           .               .           .           .           	static_opts_t sopts;
     .            .          .              .            .           .               .           .           .           	dynamic_opts_t dopts;
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           	/*
     .            .          .              .            .           .               .           .           .           	 * This variant has logging hook on exit but not on entry.  It's callled
     .            .          .              .            .           .               .           .           .           	 * only by je_malloc, below, which emits the entry one for us (and, if
     .            .          .              .            .           .               .           .           .           	 * it calls us, does so only via tail call).
     .            .          .              .            .           .               .           .           .           	 */
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           	static_opts_init(&sopts);
     .            .          .              .            .           .               .           .           .           	dynamic_opts_init(&dopts);
     .            .          .              .            .           .               .           .           .           
    17 ( 0.00%)   0          0              0            0           0              17 ( 0.00%)  0           0           	sopts.null_out_result_on_error = true;
    17 ( 0.00%)   0          0              0            0           0              17 ( 0.00%)  0           0           	sopts.set_errno_on_error = true;
    34 ( 0.00%)   0          0              0            0           0              17 ( 0.00%)  0           0           	sopts.oom_string = "<jemalloc>: Error in malloc(): out of memory\n";
     .            .          .              .            .           .               .           .           .           
    34 ( 0.00%)  16 ( 0.01%) 1 ( 0.01%)     0            0           0              17 ( 0.00%)  0           0           	dopts.result = &ret;
    17 ( 0.00%)   0          0              0            0           0              17 ( 0.00%)  0           0           	dopts.num_items = 1;
   102 ( 0.00%)   0          0             17 ( 0.00%)   0           0              51 ( 0.00%)  8 ( 0.15%)  5 ( 0.12%)  	dopts.item_size = size;
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           	imalloc(&sopts, &dopts);
     .            .          .              .            .           .               .           .           .           	/*
     .            .          .              .            .           .               .           .           .           	 * Note that this branch gets optimized away -- it immediately follows
     .            .          .              .            .           .               .           .           .           	 * the check on tsd_fast that sets sopts.slow.
     .            .          .              .            .           .               .           .           .           	 */
    51 ( 0.00%)  15 ( 0.01%) 1 ( 0.01%)    17 ( 0.00%)   0           0               0           0           0           	if (sopts.slow) {
     .            .          .              .            .           .               .           .           .           		uintptr_t args[3] = {size};
     .            .          .              .            .           .               .           .           .           		hook_invoke_alloc(hook_alloc_malloc, ret, (uintptr_t)ret, args);
     .            .          .              .            .           .               .           .           .           	}
     .            .          .              .            .           .               .           .           .           
    51 ( 0.00%)  15 ( 0.01%) 1 ( 0.01%)     0            0           0               0           0           0           	LOG("core.malloc.exit", "result: %p", ret);
     .            .          .              .            .           .               .           .           .           
    17 ( 0.00%)  15 ( 0.01%) 0             17 ( 0.00%)   0           0               0           0           0           	return ret;
   102 ( 0.00%)   0          0             85 ( 0.00%)   0           0               0           0           0           }
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           /******************************************************************************/
     .            .          .              .            .           .               .           .           .           /*
     .            .          .              .            .           .               .           .           .            * Begin malloc(3)-compatible functions.
     .            .          .              .            .           .               .           .           .            */
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           JEMALLOC_EXPORT JEMALLOC_ALLOCATOR JEMALLOC_RESTRICT_RETURN
     .            .          .              .            .           .               .           .           .           void JEMALLOC_NOTHROW *
     .            .          .              .            .           .               .           .           .           JEMALLOC_ATTR(malloc) JEMALLOC_ALLOC_SIZE(1)
11,148 ( 0.12%)  72 ( 0.05%) 2 ( 0.03%) 1,858 ( 0.08%)   0           0           4,645 ( 0.15%) 15 ( 0.28%)  0           je_malloc(size_t size) {
     .            .          .              .            .           .               .           .           .           	return imalloc_fastpath(size, &malloc_default);
 4,645 ( 0.05%)  49 ( 0.03%) 0          3,716 ( 0.15%)   0           0               0           0           0           }
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           JEMALLOC_EXPORT int JEMALLOC_NOTHROW
     .            .          .              .            .           .               .           .           .           JEMALLOC_ATTR(nonnull(1))
     .            .          .              .            .           .               .           .           .           je_posix_memalign(void **memptr, size_t alignment, size_t size) {
     .            .          .              .            .           .               .           .           .           	int ret;
     .            .          .              .            .           .               .           .           .           	static_opts_t sopts;
     .            .          .              .            .           .               .           .           .           	dynamic_opts_t dopts;
     .            .          .              .            .           .               .           .           .           
-- line 2755 ----------------------------------------
-- line 2889 ----------------------------------------
     .            .          .              .            .           .               .           .           .           	} else {
     .            .          .              .            .           .               .           .           .           		if (config_fill && slow_path && opt_junk_free) {
     .            .          .              .            .           .               .           .           .           			junk_free_callback(ptr, usize);
     .            .          .              .            .           .               .           .           .           		}
     .            .          .              .            .           .               .           .           .           		idalloctm(tsd_tsdn(tsd), ptr, tcache, &alloc_ctx, false,
     .            .          .              .            .           .               .           .           .           		    true);
     .            .          .              .            .           .               .           .           .           	}
     .            .          .              .            .           .               .           .           .           	thread_dalloc_event(tsd, usize);
     1 ( 0.00%)   0          0              1 ( 0.00%)   1 ( 0.02%)  0               0           0           0           }
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           JEMALLOC_ALWAYS_INLINE bool
     .            .          .              .            .           .               .           .           .           maybe_check_alloc_ctx(tsd_t *tsd, void *ptr, emap_alloc_ctx_t *alloc_ctx) {
 2,787 ( 0.03%)   0          0              0            0           0               0           0           0           	if (config_opt_size_checks) {
     .            .          .              .            .           .               .           .           .           		emap_alloc_ctx_t dbg_ctx;
     .            .          .              .            .           .               .           .           .           		emap_alloc_ctx_lookup(tsd_tsdn(tsd), &arena_emap_global, ptr,
     .            .          .              .            .           .               .           .           .           		    &dbg_ctx);
     .            .          .              .            .           .               .           .           .           		if (alloc_ctx->szind != dbg_ctx.szind) {
     .            .          .              .            .           .               .           .           .           			safety_check_fail_sized_dealloc(
     .            .          .              .            .           .               .           .           .           			    /* current_dealloc */ true, ptr,
     .            .          .              .            .           .               .           .           .           			    /* true_size */ sz_size2index(dbg_ctx.szind),
     .            .          .              .            .           .               .           .           .           			    /* input_size */ sz_size2index(alloc_ctx->szind));
-- line 2909 ----------------------------------------
-- line 2911 ----------------------------------------
     .            .          .              .            .           .               .           .           .           		}
     .            .          .              .            .           .               .           .           .           		if (alloc_ctx->slab != dbg_ctx.slab) {
     .            .          .              .            .           .               .           .           .           			safety_check_fail(
     .            .          .              .            .           .               .           .           .           			    "Internal heap corruption detected: "
     .            .          .              .            .           .               .           .           .           			    "mismatch in slab bit");
     .            .          .              .            .           .               .           .           .           			return true;
     .            .          .              .            .           .               .           .           .           		}
     .            .          .              .            .           .               .           .           .           	}
   929 ( 0.01%) 163 ( 0.11%) 2 ( 0.03%)     0            0           0               0           0           0           	return false;
     .            .          .              .            .           .               .           .           .           }
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           JEMALLOC_ALWAYS_INLINE void
     .            .          .              .            .           .               .           .           .           isfree(tsd_t *tsd, void *ptr, size_t usize, tcache_t *tcache, bool slow_path) {
    30 ( 0.00%)   0          0             10 ( 0.00%)   0           0               5 ( 0.00%)  0           0           	if (!slow_path) {
     .            .          .              .            .           .               .           .           .           		tsd_assert_fast(tsd);
     .            .          .              .            .           .               .           .           .           	}
     .            .          .              .            .           .               .           .           .           	check_entry_exit_locking(tsd_tsdn(tsd));
    10 ( 0.00%)   0          0              0            0           0               0           0           0           	if (tsd_reentrancy_level_get(tsd) != 0) {
     .            .          .              .            .           .               .           .           .           		assert(slow_path);
     .            .          .              .            .           .               .           .           .           	}
     .            .          .              .            .           .               .           .           .           
    20 ( 0.00%)   7 ( 0.00%) 2 ( 0.03%)     0            0           0               0           0           0           	assert(ptr != NULL);
    20 ( 0.00%)   3 ( 0.00%) 1 ( 0.01%)     0            0           0               0           0           0           	assert(malloc_initialized() || IS_INITIALIZER);
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           	emap_alloc_ctx_t alloc_ctx;
    30 ( 0.00%)   4 ( 0.00%) 1 ( 0.01%)     5 ( 0.00%)   0           0               5 ( 0.00%)  1 ( 0.02%)  0           	if (!config_prof) {
     5 ( 0.00%)   0          0              0            0           0               5 ( 0.00%)  0           0           		alloc_ctx.szind = sz_size2index(usize);
    25 ( 0.00%)   0          0              5 ( 0.00%)   0           0               5 ( 0.00%)  0           0           		alloc_ctx.slab = (alloc_ctx.szind < SC_NBINS);
     .            .          .              .            .           .               .           .           .           	} else {
     .            .          .              .            .           .               .           .           .           		if (likely(!prof_sample_aligned(ptr))) {
     .            .          .              .            .           .               .           .           .           			/*
     .            .          .              .            .           .               .           .           .           			 * When the ptr is not page aligned, it was not sampled.
     .            .          .              .            .           .               .           .           .           			 * usize can be trusted to determine szind and slab.
     .            .          .              .            .           .               .           .           .           			 */
     .            .          .              .            .           .               .           .           .           			alloc_ctx.szind = sz_size2index(usize);
     .            .          .              .            .           .               .           .           .           			alloc_ctx.slab = (alloc_ctx.szind < SC_NBINS);
-- line 2946 ----------------------------------------
-- line 2956 ----------------------------------------
     .            .          .              .            .           .               .           .           .           					    /* current_dealloc */ true, ptr,
     .            .          .              .            .           .               .           .           .           					    /* true_size */ sz_index2size(
     .            .          .              .            .           .               .           .           .           					    alloc_ctx.szind),
     .            .          .              .            .           .               .           .           .           					    /* input_size */ usize);
     .            .          .              .            .           .               .           .           .           				}
     .            .          .              .            .           .               .           .           .           			}
     .            .          .              .            .           .               .           .           .           		} else {
     .            .          .              .            .           .               .           .           .           			alloc_ctx.szind = sz_size2index(usize);
    30 ( 0.00%)   6 ( 0.00%) 2 ( 0.03%)    10 ( 0.00%)   0           0              15 ( 0.00%)  5 ( 0.09%)  2 ( 0.05%)  			alloc_ctx.slab = (alloc_ctx.szind < SC_NBINS);
     .            .          .              .            .           .               .           .           .           		}
     .            .          .              .            .           .               .           .           .           	}
     5 ( 0.00%)   0          0              0            0           0               5 ( 0.00%)  2 ( 0.04%)  1 ( 0.02%)  	bool fail = maybe_check_alloc_ctx(tsd, ptr, &alloc_ctx);
    10 ( 0.00%)   0          0              5 ( 0.00%)   0           0               0           0           0           	if (fail) {
     .            .          .              .            .           .               .           .           .           		/*
     .            .          .              .            .           .               .           .           .           		 * This is a heap corruption bug.  In real life we'll crash; for
     .            .          .              .            .           .               .           .           .           		 * the unit test we just want to avoid breaking anything too
     .            .          .              .            .           .               .           .           .           		 * badly to get a test result out.  Let's leak instead of trying
     .            .          .              .            .           .               .           .           .           		 * to free.
     .            .          .              .            .           .               .           .           .           		 */
    10 ( 0.00%)   6 ( 0.00%) 2 ( 0.03%)     5 ( 0.00%)   0           0               5 ( 0.00%)  1 ( 0.02%)  0           		return;
     .            .          .              .            .           .               .           .           .           	}
     .            .          .              .            .           .               .           .           .           
    15 ( 0.00%)   3 ( 0.00%) 1 ( 0.01%)     0            0           0               0           0           0           	if (config_prof && opt_prof) {
     .            .          .              .            .           .               .           .           .           		prof_free(tsd, ptr, usize, &alloc_ctx);
     .            .          .              .            .           .               .           .           .           	}
    35 ( 0.00%)   4 ( 0.00%) 1 ( 0.01%)    10 ( 0.00%)   0           0               5 ( 0.00%)  3 ( 0.06%)  0           	if (likely(!slow_path)) {
     .            .          .              .            .           .               .           .           .           		isdalloct(tsd_tsdn(tsd), ptr, usize, tcache, &alloc_ctx,
     .            .          .              .            .           .               .           .           .           		    false);
     .            .          .              .            .           .               .           .           .           	} else {
     .            .          .              .            .           .               .           .           .           		if (config_fill && slow_path && opt_junk_free) {
     .            .          .              .            .           .               .           .           .           			junk_free_callback(ptr, usize);
     .            .          .              .            .           .               .           .           .           		}
     .            .          .              .            .           .               .           .           .           		isdalloct(tsd_tsdn(tsd), ptr, usize, tcache, &alloc_ctx,
     .            .          .              .            .           .               .           .           .           		    true);
-- line 2989 ----------------------------------------
-- line 3031 ----------------------------------------
     .            .          .              .            .           .               .           .           .           	 * free_fastpath do not handle two uncommon cases: 1) sampled profiled
     .            .          .              .            .           .               .           .           .           	 * objects and 2) sampled junk & stash for use-after-free detection.
     .            .          .              .            .           .               .           .           .           	 * Both have special alignments which are used to escape the fastpath.
     .            .          .              .            .           .               .           .           .           	 *
     .            .          .              .            .           .               .           .           .           	 * prof_sample is page-aligned, which covers the UAF check when both
     .            .          .              .            .           .               .           .           .           	 * are enabled (the assertion below).  Avoiding redundant checks since
     .            .          .              .            .           .               .           .           .           	 * this is on the fastpath -- at most one runtime branch from this.
     .            .          .              .            .           .               .           .           .           	 */
 2,775 ( 0.03%)   0          0              0            0           0               0           0           0           	if (config_debug && cache_bin_nonfast_aligned(ptr)) {
     .            .          .              .            .           .               .           .           .           		assert(prof_sample_aligned(ptr));
     .            .          .              .            .           .               .           .           .           	}
     .            .          .              .            .           .               .           .           .           
 2,775 ( 0.03%)  55 ( 0.04%) 1 ( 0.01%)     0            0           0               0           0           0           	if (config_prof && check_prof) {
     .            .          .              .            .           .               .           .           .           		/* When prof is enabled, the prof_sample alignment is enough. */
     .            .          .              .            .           .               .           .           .           		if (prof_sample_aligned(ptr)) {
     .            .          .              .            .           .               .           .           .           			return true;
     .            .          .              .            .           .               .           .           .           		} else {
     .            .          .              .            .           .               .           .           .           			return false;
     .            .          .              .            .           .               .           .           .           		}
     .            .          .              .            .           .               .           .           .           	}
     .            .          .              .            .           .               .           .           .           
 2,775 ( 0.03%)  55 ( 0.04%) 1 ( 0.01%)     0            0           0               0           0           0           	if (config_uaf_detection) {
     .            .          .              .            .           .               .           .           .           		if (cache_bin_nonfast_aligned(ptr)) {
     .            .          .              .            .           .               .           .           .           			return true;
     .            .          .              .            .           .               .           .           .           		} else {
     .            .          .              .            .           .               .           .           .           			return false;
     .            .          .              .            .           .               .           .           .           		}
     .            .          .              .            .           .               .           .           .           	}
     .            .          .              .            .           .               .           .           .           
   925 ( 0.01%) 138 ( 0.10%) 1 ( 0.01%)     0            0           0               0           0           0           	return false;
     .            .          .              .            .           .               .           .           .           }
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           /* Returns whether or not the free attempt was successful. */
     .            .          .              .            .           .               .           .           .           JEMALLOC_ALWAYS_INLINE
     .            .          .              .            .           .               .           .           .           bool free_fastpath(void *ptr, size_t size, bool size_hint) {
   929 ( 0.01%)   0          0              0            0           0             929 ( 0.03%)  0           0           	tsd_t *tsd = tsd_get(false);
     .            .          .              .            .           .               .           .           .           	/* The branch gets optimized away unless tsd_get_allocates(). */
 4,645 ( 0.05%) 193 ( 0.13%) 1 ( 0.01%)   929 ( 0.04%)   0           0               0           0           0           	if (unlikely(tsd == NULL)) {
     .            .          .              .            .           .               .           .           .           		return false;
     .            .          .              .            .           .               .           .           .           	}
     .            .          .              .            .           .               .           .           .           	/*
     .            .          .              .            .           .               .           .           .           	 *  The tsd_fast() / initialized checks are folded into the branch
     .            .          .              .            .           .               .           .           .           	 *  testing (deallocated_after >= threshold) later in this function.
     .            .          .              .            .           .               .           .           .           	 *  The threshold will be set to 0 when !tsd_fast.
     .            .          .              .            .           .               .           .           .           	 */
 3,716 ( 0.04%)   0          0              0            0           0               0           0           0           	assert(tsd_fast(tsd) ||
     .            .          .              .            .           .               .           .           .           	    *tsd_thread_deallocated_next_event_fastp_get_unsafe(tsd) == 0);
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           	emap_alloc_ctx_t alloc_ctx;
 3,716 ( 0.04%)  88 ( 0.06%) 1 ( 0.01%)   929 ( 0.04%)   0           0               0           0           0           	if (!size_hint) {
     .            .          .              .            .           .               .           .           .           		bool err = emap_alloc_ctx_try_lookup_fast(tsd,
     .            .          .              .            .           .               .           .           .           		    &arena_emap_global, ptr, &alloc_ctx);
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           		/* Note: profiled objects will have alloc_ctx.slab set */
     .            .          .              .            .           .               .           .           .           		if (unlikely(err || !alloc_ctx.slab ||
     .            .          .              .            .           .               .           .           .           		    free_fastpath_nonfast_aligned(ptr,
     .            .          .              .            .           .               .           .           .           		    /* check_prof */ false))) {
     .            .          .              .            .           .               .           .           .           			return false;
-- line 3088 ----------------------------------------
-- line 3089 ----------------------------------------
     .            .          .              .            .           .               .           .           .           		}
     .            .          .              .            .           .               .           .           .           		assert(alloc_ctx.szind != SC_NSIZES);
     .            .          .              .            .           .               .           .           .           	} else {
     .            .          .              .            .           .               .           .           .           		/*
     .            .          .              .            .           .               .           .           .           		 * Check for both sizes that are too large, and for sampled /
     .            .          .              .            .           .               .           .           .           		 * special aligned objects.  The alignment check will also check
     .            .          .              .            .           .               .           .           .           		 * for null ptr.
     .            .          .              .            .           .               .           .           .           		 */
10,195 ( 0.11%) 371 ( 0.26%) 2 ( 0.03%) 1,854 ( 0.08%)   0           0           1,850 ( 0.06%)  4 ( 0.08%)  0           		if (unlikely(size > SC_LOOKUP_MAXCLASS ||
     .            .          .              .            .           .               .           .           .           		    free_fastpath_nonfast_aligned(ptr,
     .            .          .              .            .           .               .           .           .           		    /* check_prof */ true))) {
 3,708 ( 0.04%) 176 ( 0.12%) 1 ( 0.01%) 1,850 ( 0.08%)   0           0           1,850 ( 0.06%)  2 ( 0.04%)  0           			return false;
     .            .          .              .            .           .               .           .           .           		}
   925 ( 0.01%)   0          0              0            0           0             925 ( 0.03%)  2 ( 0.04%)  0           		alloc_ctx.szind = sz_size2index_lookup(size);
     .            .          .              .            .           .               .           .           .           		/* Max lookup class must be small. */
 3,700 ( 0.04%)   0          0              0            0           0               0           0           0           		assert(alloc_ctx.szind < SC_NBINS);
     .            .          .              .            .           .               .           .           .           		/* This is a dead store, except when opt size checking is on. */
   925 ( 0.01%) 159 ( 0.11%) 1 ( 0.01%)     0            0           0             925 ( 0.03%)  0           0           		alloc_ctx.slab = true;
     .            .          .              .            .           .               .           .           .           	}
     .            .          .              .            .           .               .           .           .           	/*
     .            .          .              .            .           .               .           .           .           	 * Currently the fastpath only handles small sizes.  The branch on
     .            .          .              .            .           .               .           .           .           	 * SC_LOOKUP_MAXCLASS makes sure of it.  This lets us avoid checking
     .            .          .              .            .           .               .           .           .           	 * tcache szind upper limit (i.e. tcache_maxclass) as well.
     .            .          .              .            .           .               .           .           .           	 */
11,100 ( 0.12%) 298 ( 0.21%) 2 ( 0.03%) 1,850 ( 0.08%)   0           0           3,700 ( 0.12%)  2 ( 0.04%)  0           	assert(alloc_ctx.slab);
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           	uint64_t deallocated, threshold;
     .            .          .              .            .           .               .           .           .           	te_free_fastpath_ctx(tsd, &deallocated, &threshold);
     .            .          .              .            .           .               .           .           .           
 2,775 ( 0.03%)  46 ( 0.03%) 1 ( 0.01%)   925 ( 0.04%)   0           0           1,850 ( 0.06%)  0           0           	size_t usize = sz_index2size(alloc_ctx.szind);
 3,700 ( 0.04%)   0          0          1,850 ( 0.08%)   0           0             925 ( 0.03%)  1 ( 0.02%)  0           	uint64_t deallocated_after = deallocated + usize;
     .            .          .              .            .           .               .           .           .           	/*
     .            .          .              .            .           .               .           .           .           	 * Check for events and tsd non-nominal (fast_threshold will be set to
     .            .          .              .            .           .               .           .           .           	 * 0) in a single branch.  Note that this handles the uninitialized case
     .            .          .              .            .           .               .           .           .           	 * as well (TSD init will be triggered on the non-fastpath).  Therefore
     .            .          .              .            .           .               .           .           .           	 * anything depends on a functional TSD (e.g. the alloc_ctx sanity check
     .            .          .              .            .           .               .           .           .           	 * below) needs to be after this branch.
     .            .          .              .            .           .               .           .           .           	 */
 5,550 ( 0.06%)   0          0          1,850 ( 0.08%)   0           0               0           0           0           	if (unlikely(deallocated_after >= threshold)) {
     2 ( 0.00%)   0          0              0            0           0               0           0           0           		return false;
     .            .          .              .            .           .               .           .           .           	}
 9,240 ( 0.10%) 467 ( 0.32%) 3 ( 0.04%) 1,848 ( 0.08%)   0           0           2,772 ( 0.09%)  3 ( 0.06%)  0           	assert(tsd_fast(tsd));
   924 ( 0.01%)   0          0              0            0           0             924 ( 0.03%)  0           0           	bool fail = maybe_check_alloc_ctx(tsd, ptr, &alloc_ctx);
 1,848 ( 0.02%)   0          0            924 ( 0.04%)   0           0               0           0           0           	if (fail) {
     .            .          .              .            .           .               .           .           .           		/* See the comment in isfree. */
 4,620 ( 0.05%) 190 ( 0.13%) 1 ( 0.01%)   924 ( 0.04%)   0           0           3,696 ( 0.12%)  2 ( 0.04%)  0           		return true;
     .            .          .              .            .           .               .           .           .           	}
     .            .          .              .            .           .               .           .           .           
   924 ( 0.01%)   0          0              0            0           0             924 ( 0.03%)  0           0           	tcache_t *tcache = tcache_get_from_ind(tsd, TCACHE_IND_AUTOMATIC,
     .            .          .              .            .           .               .           .           .           	    /* slow */ false, /* is_alloc */ false);
 9,240 ( 0.10%) 162 ( 0.11%) 1 ( 0.01%) 1,848 ( 0.08%)   0           0             924 ( 0.03%)  0           0           	cache_bin_t *bin = &tcache->bins[alloc_ctx.szind];
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           	/*
     .            .          .              .            .           .               .           .           .           	 * If junking were enabled, this is where we would do it.  It's not
     .            .          .              .            .           .               .           .           .           	 * though, since we ensured above that we're on the fast path.  Assert
     .            .          .              .            .           .               .           .           .           	 * that to double-check.
     .            .          .              .            .           .               .           .           .           	 */
 9,240 ( 0.10%) 374 ( 0.26%) 2 ( 0.03%) 2,772 ( 0.11%)   0           0           2,772 ( 0.09%)  0           0           	assert(!opt_junk_free);
     .            .          .              .            .           .               .           .           .           
 2,772 ( 0.03%)   0          0              0            0           0               0           0           0           	if (!cache_bin_dalloc_easy(bin, ptr)) {
 3,696 ( 0.04%)  68 ( 0.05%) 1 ( 0.01%) 1,848 ( 0.08%)   0           0           1,848 ( 0.06%)  0           0           		return false;
     .            .          .              .            .           .               .           .           .           	}
     .            .          .              .            .           .               .           .           .           
 1,848 ( 0.02%)   0          0            924 ( 0.04%)   0           0             924 ( 0.03%)  0           0           	*tsd_thread_deallocatedp_get(tsd) = deallocated_after;
     .            .          .              .            .           .               .           .           .           
   924 ( 0.01%)   0          0              0            0           0               0           0           0           	return true;
     .            .          .              .            .           .               .           .           .           }
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           JEMALLOC_EXPORT void JEMALLOC_NOTHROW
     .            .          .              .            .           .               .           .           .           je_free(void *ptr) {
     .            .          .              .            .           .               .           .           .           	LOG("core.free.entry", "ptr: %p", ptr);
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           	if (!free_fastpath(ptr, 0, false)) {
     .            .          .              .            .           .               .           .           .           		free_default(ptr);
-- line 3162 ----------------------------------------
-- line 3310 ----------------------------------------
     .            .          .              .            .           .               .           .           .            */
     .            .          .              .            .           .               .           .           .           /******************************************************************************/
     .            .          .              .            .           .               .           .           .           /*
     .            .          .              .            .           .               .           .           .            * Begin non-standard functions.
     .            .          .              .            .           .               .           .           .            */
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           JEMALLOC_ALWAYS_INLINE unsigned
     .            .          .              .            .           .               .           .           .           mallocx_tcache_get(int flags) {
   721 ( 0.01%)   3 ( 0.00%) 1 ( 0.01%)   103 ( 0.00%)   0           0               0           0           0           	if (likely((flags & MALLOCX_TCACHE_MASK) == 0)) {
   206 ( 0.00%)   0          0              0            0           0               0           0           0           		return TCACHE_IND_AUTOMATIC;
     .            .          .              .            .           .               .           .           .           	} else if ((flags & MALLOCX_TCACHE_MASK) == MALLOCX_TCACHE_NONE) {
     .            .          .              .            .           .               .           .           .           		return TCACHE_IND_NONE;
     .            .          .              .            .           .               .           .           .           	} else {
     .            .          .              .            .           .               .           .           .           		return MALLOCX_TCACHE_GET(flags);
     .            .          .              .            .           .               .           .           .           	}
     .            .          .              .            .           .               .           .           .           }
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           JEMALLOC_ALWAYS_INLINE unsigned
     .            .          .              .            .           .               .           .           .           mallocx_arena_get(int flags) {
   588 ( 0.01%)   0          0             98 ( 0.00%)   0           0               0           0           0           	if (unlikely((flags & MALLOCX_ARENA_MASK) != 0)) {
     .            .          .              .            .           .               .           .           .           		return MALLOCX_ARENA_GET(flags);
     .            .          .              .            .           .               .           .           .           	} else {
    98 ( 0.00%)  28 ( 0.02%) 1 ( 0.01%)     0            0           0               0           0           0           		return ARENA_IND_AUTOMATIC;
     .            .          .              .            .           .               .           .           .           	}
     .            .          .              .            .           .               .           .           .           }
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           #ifdef JEMALLOC_EXPERIMENTAL_SMALLOCX_API
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           #define JEMALLOC_SMALLOCX_CONCAT_HELPER(x, y) x ## y
     .            .          .              .            .           .               .           .           .           #define JEMALLOC_SMALLOCX_CONCAT_HELPER2(x, y)  \
     .            .          .              .            .           .               .           .           .             JEMALLOC_SMALLOCX_CONCAT_HELPER(x, y)
-- line 3340 ----------------------------------------
-- line 3485 ----------------------------------------
     .            .          .              .            .           .               .           .           .           	assert(usize == isalloc(tsd_tsdn(tsd), p));
     .            .          .              .            .           .               .           .           .           	prof_realloc(tsd, p, size, usize, tctx, prof_active, old_ptr,
     .            .          .              .            .           .               .           .           .           	    old_usize, &old_prof_info, sample_event);
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           	return p;
     .            .          .              .            .           .               .           .           .           }
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           static void *
 1,666 ( 0.02%)  59 ( 0.04%) 2 ( 0.03%)   294 ( 0.01%)  54 ( 0.94%)  2 ( 0.06%)    686 ( 0.02%)  8 ( 0.15%)  3 ( 0.07%)  do_rallocx(void *ptr, size_t size, int flags, bool is_realloc) {
     .            .          .              .            .           .               .           .           .           	void *p;
     .            .          .              .            .           .               .           .           .           	tsd_t *tsd;
     .            .          .              .            .           .               .           .           .           	size_t usize;
     .            .          .              .            .           .               .           .           .           	size_t old_usize;
   784 ( 0.01%)  28 ( 0.02%) 1 ( 0.01%)    98 ( 0.00%)   0           0              98 ( 0.00%)  2 ( 0.04%)  2 ( 0.05%)  	size_t alignment = MALLOCX_ALIGN_GET(flags);
     .            .          .              .            .           .               .           .           .           	arena_t *arena;
     .            .          .              .            .           .               .           .           .           
   392 ( 0.00%)   0          0              0            0           0               0           0           0           	assert(ptr != NULL);
   392 ( 0.00%)  30 ( 0.02%) 1 ( 0.01%)     0            0           0               0           0           0           	assert(size != 0);
   588 ( 0.01%)  90 ( 0.06%) 3 ( 0.04%)     0            0           0             196 ( 0.01%)  0           0           	assert(malloc_initialized() || IS_INITIALIZER);
   294 ( 0.00%)  29 ( 0.02%) 1 ( 0.01%)    98 ( 0.00%)   0           0             196 ( 0.01%)  4 ( 0.08%)  2 ( 0.05%)  	tsd = tsd_fetch();
     .            .          .              .            .           .               .           .           .           	check_entry_exit_locking(tsd_tsdn(tsd));
     .            .          .              .            .           .               .           .           .           
 1,078 ( 0.01%)  30 ( 0.02%) 1 ( 0.01%)   294 ( 0.01%)   0           0             392 ( 0.01%)  3 ( 0.06%)  2 ( 0.05%)  	bool zero = zero_get(MALLOCX_ZERO_GET(flags), /* slow */ true);
     .            .          .              .            .           .               .           .           .           
   686 ( 0.01%)  28 ( 0.02%) 1 ( 0.01%)   196 ( 0.01%)   0           0             392 ( 0.01%)  1 ( 0.02%)  1 ( 0.02%)  	unsigned arena_ind = mallocx_arena_get(flags);
   392 ( 0.00%)  98 ( 0.07%) 1 ( 0.01%)    98 ( 0.00%)   0           0              98 ( 0.00%)  0           0           	if (arena_get_from_ind(tsd, arena_ind, &arena)) {
     .            .          .              .            .           .               .           .           .           		goto label_oom;
     .            .          .              .            .           .               .           .           .           	}
     .            .          .              .            .           .               .           .           .           
   686 ( 0.01%)  60 ( 0.04%) 2 ( 0.03%)   196 ( 0.01%)   0           0             490 ( 0.02%)  7 ( 0.13%)  3 ( 0.07%)  	unsigned tcache_ind = mallocx_tcache_get(flags);
   294 ( 0.00%)   0          0             98 ( 0.00%)   0           0             196 ( 0.01%)  0           0           	tcache_t *tcache = tcache_get_from_ind(tsd, tcache_ind,
     .            .          .              .            .           .               .           .           .           	    /* slow */ true, /* is_alloc */ true);
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           	emap_alloc_ctx_t alloc_ctx;
     .            .          .              .            .           .               .           .           .           	emap_alloc_ctx_lookup(tsd_tsdn(tsd), &arena_emap_global, ptr,
     .            .          .              .            .           .               .           .           .           	    &alloc_ctx);
   392 ( 0.00%)   0          0              0            0           0               0           0           0           	assert(alloc_ctx.szind != SC_NSIZES);
   294 ( 0.00%)  33 ( 0.02%) 1 ( 0.01%)    98 ( 0.00%)   0           0             196 ( 0.01%)  0           0           	old_usize = sz_index2size(alloc_ctx.szind);
 1,176 ( 0.01%)  58 ( 0.04%) 2 ( 0.03%)   196 ( 0.01%)   0           0             490 ( 0.02%)  8 ( 0.15%)  6 ( 0.14%)  	assert(old_usize == isalloc(tsd_tsdn(tsd), ptr));
   196 ( 0.00%)  31 ( 0.02%) 1 ( 0.01%)     0            0           0               0           0           0           	if (aligned_usize_get(size, alignment, &usize, NULL, false)) {
     .            .          .              .            .           .               .           .           .           		goto label_oom;
     .            .          .              .            .           .               .           .           .           	}
     .            .          .              .            .           .               .           .           .           
   980 ( 0.01%)  31 ( 0.02%) 1 ( 0.01%)   392 ( 0.02%)   0           0             490 ( 0.02%)  2 ( 0.04%)  1 ( 0.02%)  	hook_ralloc_args_t hook_args = {is_realloc, {(uintptr_t)ptr, size,
     .            .          .              .            .           .               .           .           .           		flags, 0}};
   294 ( 0.00%)   0          0              0            0           0               0           0           0           	if (config_prof && opt_prof) {
     .            .          .              .            .           .               .           .           .           		p = irallocx_prof(tsd, ptr, old_usize, size, alignment, usize,
     .            .          .              .            .           .               .           .           .           		    zero, tcache, arena, &alloc_ctx, &hook_args);
     .            .          .              .            .           .               .           .           .           		if (unlikely(p == NULL)) {
     .            .          .              .            .           .               .           .           .           			goto label_oom;
     .            .          .              .            .           .               .           .           .           		}
     .            .          .              .            .           .               .           .           .           	} else {
   490 ( 0.01%)  62 ( 0.04%) 2 ( 0.03%)   294 ( 0.01%)   0           0             196 ( 0.01%)  3 ( 0.06%)  1 ( 0.02%)  		p = iralloct(tsd_tsdn(tsd), ptr, old_usize, size, alignment,
     .            .          .              .            .           .               .           .           .           		    zero, tcache, arena, &hook_args);
   490 ( 0.01%)   0          0             98 ( 0.00%)   0           0               0           0           0           		if (unlikely(p == NULL)) {
     .            .          .              .            .           .               .           .           .           			goto label_oom;
     .            .          .              .            .           .               .           .           .           		}
   392 ( 0.00%)   0          0              0            0           0               0           0           0           		assert(usize == isalloc(tsd_tsdn(tsd), p));
     .            .          .              .            .           .               .           .           .           	}
   392 ( 0.00%)  31 ( 0.02%) 1 ( 0.01%)     0            0           0               0           0           0           	assert(alignment == 0 || ((uintptr_t)p & (alignment - 1)) == ZU(0));
 1,078 ( 0.01%)  62 ( 0.04%) 2 ( 0.03%)   490 ( 0.02%)   0           0             588 ( 0.02%)  6 ( 0.11%)  2 ( 0.05%)  	thread_alloc_event(tsd, usize);
     .            .          .              .            .           .               .           .           .           	thread_dalloc_event(tsd, old_usize);
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           	UTRACE(ptr, size, p);
     .            .          .              .            .           .               .           .           .           	check_entry_exit_locking(tsd_tsdn(tsd));
     .            .          .              .            .           .               .           .           .           
   686 ( 0.01%)   0          0             98 ( 0.00%)   0           0               0           0           0           	if (config_fill && unlikely(opt_junk_alloc) && usize > old_usize
     .            .          .              .            .           .               .           .           .           	    && !zero) {
     .            .          .              .            .           .               .           .           .           		size_t excess_len = usize - old_usize;
     .            .          .              .            .           .               .           .           .           		void *excess_start = (void *)((uintptr_t)p + old_usize);
     .            .          .              .            .           .               .           .           .           		junk_alloc_callback(excess_start, excess_len);
     .            .          .              .            .           .               .           .           .           	}
     .            .          .              .            .           .               .           .           .           
   196 ( 0.00%)  29 ( 0.02%) 1 ( 0.01%)    98 ( 0.00%)   0           0               0           0           0           	return p;
     .            .          .              .            .           .               .           .           .           label_oom:
     .            .          .              .            .           .               .           .           .           	if (config_xmalloc && unlikely(opt_xmalloc)) {
     .            .          .              .            .           .               .           .           .           		malloc_write("<jemalloc>: Error in rallocx(): out of memory\n");
     .            .          .              .            .           .               .           .           .           		abort();
     .            .          .              .            .           .               .           .           .           	}
     .            .          .              .            .           .               .           .           .           	UTRACE(ptr, size, 0);
     .            .          .              .            .           .               .           .           .           	check_entry_exit_locking(tsd_tsdn(tsd));
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           	return NULL;
   588 ( 0.01%)  31 ( 0.02%) 1 ( 0.01%)   490 ( 0.02%)   0           0               0           0           0           }
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           JEMALLOC_EXPORT JEMALLOC_ALLOCATOR JEMALLOC_RESTRICT_RETURN
     .            .          .              .            .           .               .           .           .           void JEMALLOC_NOTHROW *
     .            .          .              .            .           .               .           .           .           JEMALLOC_ALLOC_SIZE(2)
     .            .          .              .            .           .               .           .           .           je_rallocx(void *ptr, size_t size, int flags) {
     .            .          .              .            .           .               .           .           .           	LOG("core.rallocx.entry", "ptr: %p, size: %zu, flags: %d", ptr,
     .            .          .              .            .           .               .           .           .           	    size, flags);
     .            .          .              .            .           .               .           .           .           	void *ret = do_rallocx(ptr, size, flags, false);
-- line 3576 ----------------------------------------
-- line 3615 ----------------------------------------
     .            .          .              .            .           .               .           .           .           		 */
     .            .          .              .            .           .               .           .           .           		return NULL;
     .            .          .              .            .           .               .           .           .           	}
     .            .          .              .            .           .               .           .           .           }
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           JEMALLOC_EXPORT JEMALLOC_ALLOCATOR JEMALLOC_RESTRICT_RETURN
     .            .          .              .            .           .               .           .           .           void JEMALLOC_NOTHROW *
     .            .          .              .            .           .               .           .           .           JEMALLOC_ALLOC_SIZE(2)
 3,430 ( 0.04%)  58 ( 0.04%) 2 ( 0.03%)   686 ( 0.03%) 169 ( 2.93%) 14 ( 0.39%)    490 ( 0.02%)  3 ( 0.06%)  1 ( 0.02%)  je_realloc(void *ptr, size_t size) {
   294 ( 0.00%)   0          0              0            0           0               0           0           0           	LOG("core.realloc.entry", "ptr: %p, size: %zu\n", ptr, size);
     .            .          .              .            .           .               .           .           .           
   980 ( 0.01%)  55 ( 0.04%) 2 ( 0.03%)   196 ( 0.01%)   0           0               0           0           0           	if (likely(ptr != NULL && size != 0)) {
   686 ( 0.01%)   5 ( 0.00%) 0            196 ( 0.01%)   0           0             196 ( 0.01%)  2 ( 0.04%)  2 ( 0.05%)  		void *ret = do_rallocx(ptr, size, 0, true);
   294 ( 0.00%)  29 ( 0.02%) 1 ( 0.01%)     0            0           0               0           0           0           		LOG("core.realloc.exit", "result: %p", ret);
   196 ( 0.00%)  29 ( 0.02%) 1 ( 0.01%)    98 ( 0.00%)   0           0               0           0           0           		return ret;
     .            .          .              .            .           .               .           .           .           	} else if (ptr != NULL && size == 0) {
     .            .          .              .            .           .               .           .           .           		void *ret = do_realloc_nonnull_zero(ptr);
     .            .          .              .            .           .               .           .           .           		LOG("core.realloc.exit", "result: %p", ret);
     .            .          .              .            .           .               .           .           .           		return ret;
     .            .          .              .            .           .               .           .           .           	} else {
     .            .          .              .            .           .               .           .           .           		/* realloc(NULL, size) is equivalent to malloc(size). */
     .            .          .              .            .           .               .           .           .           		void *ret;
     .            .          .              .            .           .               .           .           .           
-- line 3637 ----------------------------------------
-- line 3654 ----------------------------------------
     .            .          .              .            .           .               .           .           .           		if (sopts.slow) {
     .            .          .              .            .           .               .           .           .           			uintptr_t args[3] = {(uintptr_t)ptr, size};
     .            .          .              .            .           .               .           .           .           			hook_invoke_alloc(hook_alloc_realloc, ret,
     .            .          .              .            .           .               .           .           .           			    (uintptr_t)ret, args);
     .            .          .              .            .           .               .           .           .           		}
     .            .          .              .            .           .               .           .           .           		LOG("core.realloc.exit", "result: %p", ret);
     .            .          .              .            .           .               .           .           .           		return ret;
     .            .          .              .            .           .               .           .           .           	}
   588 ( 0.01%)  29 ( 0.02%) 0            490 ( 0.02%)   5 ( 0.09%)  0               0           0           0           }
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           JEMALLOC_ALWAYS_INLINE size_t
     .            .          .              .            .           .               .           .           .           ixallocx_helper(tsdn_t *tsdn, void *ptr, size_t old_usize, size_t size,
     .            .          .              .            .           .               .           .           .               size_t extra, size_t alignment, bool zero) {
     .            .          .              .            .           .               .           .           .           	size_t newsize;
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           	if (ixalloc(tsdn, ptr, old_usize, size, extra, alignment, zero,
     .            .          .              .            .           .               .           .           .           	    &newsize)) {
-- line 3670 ----------------------------------------
-- line 3894 ----------------------------------------
     .            .          .              .            .           .               .           .           .           	LOG("core.dallocx.exit", "");
     .            .          .              .            .           .               .           .           .           }
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           JEMALLOC_ALWAYS_INLINE size_t
     .            .          .              .            .           .               .           .           .           inallocx(tsdn_t *tsdn, size_t size, int flags) {
     .            .          .              .            .           .               .           .           .           	check_entry_exit_locking(tsdn);
     .            .          .              .            .           .               .           .           .           	size_t usize;
     .            .          .              .            .           .               .           .           .           	/* In case of out of range, let the user see it rather than fail. */
    75 ( 0.00%)   4 ( 0.00%) 1 ( 0.01%)    10 ( 0.00%)   0           0              25 ( 0.00%)  7 ( 0.13%)  4 ( 0.10%)  	aligned_usize_get(size, MALLOCX_ALIGN_GET(flags), &usize, NULL, false);
     .            .          .              .            .           .               .           .           .           	check_entry_exit_locking(tsdn);
     5 ( 0.00%)   0          0              5 ( 0.00%)   0           0               0           0           0           	return usize;
     .            .          .              .            .           .               .           .           .           }
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           JEMALLOC_NOINLINE void
    75 ( 0.00%)   6 ( 0.00%) 2 ( 0.03%)    15 ( 0.00%)   7 ( 0.12%)  2 ( 0.06%)     30 ( 0.00%)  5 ( 0.09%)  5 ( 0.12%)  sdallocx_default(void *ptr, size_t size, int flags) {
    20 ( 0.00%)   3 ( 0.00%) 1 ( 0.01%)     0            0           0               0           0           0           	assert(ptr != NULL);
    30 ( 0.00%)   8 ( 0.01%) 2 ( 0.03%)     0            0           0              10 ( 0.00%)  2 ( 0.04%)  2 ( 0.05%)  	assert(malloc_initialized() || IS_INITIALIZER);
     .            .          .              .            .           .               .           .           .           
    25 ( 0.00%)   0          0             10 ( 0.00%)   0           0              15 ( 0.00%)  7 ( 0.13%)  2 ( 0.05%)  	tsd_t *tsd = tsd_fetch_min();
    15 ( 0.00%)   3 ( 0.00%) 1 ( 0.01%)     5 ( 0.00%)   0           0              10 ( 0.00%)  0           0           	bool fast = tsd_fast(tsd);
    15 ( 0.00%)   0          0              5 ( 0.00%)   0           0              10 ( 0.00%)  1 ( 0.02%)  1 ( 0.02%)  	size_t usize = inallocx(tsd_tsdn(tsd), size, flags);
     .            .          .              .            .           .               .           .           .           	check_entry_exit_locking(tsd_tsdn(tsd));
     .            .          .              .            .           .               .           .           .           
     5 ( 0.00%)   3 ( 0.00%) 1 ( 0.01%)     0            0           0               5 ( 0.00%)  2 ( 0.04%)  1 ( 0.02%)  	unsigned tcache_ind = mallocx_tcache_get(flags);
    50 ( 0.00%)   3 ( 0.00%) 1 ( 0.01%)    15 ( 0.00%)   0           0              25 ( 0.00%)  1 ( 0.02%)  1 ( 0.02%)  	tcache_t *tcache = tcache_get_from_ind(tsd, tcache_ind, !fast,
    25 ( 0.00%)   0          0              5 ( 0.00%)   0           0               0           0           0           	    /* is_alloc */ false);
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           	UTRACE(ptr, 0, 0);
    30 ( 0.00%)   3 ( 0.00%) 1 ( 0.01%)    10 ( 0.00%)   0           0               5 ( 0.00%)  3 ( 0.06%)  1 ( 0.02%)  	if (likely(fast)) {
     .            .          .              .            .           .               .           .           .           		tsd_assert_fast(tsd);
     .            .          .              .            .           .               .           .           .           		isfree(tsd, ptr, usize, tcache, false);
     .            .          .              .            .           .               .           .           .           	} else {
     .            .          .              .            .           .               .           .           .           		uintptr_t args_raw[3] = {(uintptr_t)ptr, size, flags};
     .            .          .              .            .           .               .           .           .           		hook_invoke_dalloc(hook_dalloc_sdallocx, ptr, args_raw);
     .            .          .              .            .           .               .           .           .           		isfree(tsd, ptr, usize, tcache, true);
     .            .          .              .            .           .               .           .           .           	}
     .            .          .              .            .           .               .           .           .           	check_entry_exit_locking(tsd_tsdn(tsd));
    35 ( 0.00%)   0          0             25 ( 0.00%)   0           0               0           0           0           }
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           JEMALLOC_EXPORT void JEMALLOC_NOTHROW
10,219 ( 0.11%) 182 ( 0.13%) 2 ( 0.03%)   929 ( 0.04%)   0           0           5,574 ( 0.18%)  5 ( 0.09%)  0           je_sdallocx(void *ptr, size_t size, int flags) {
 2,787 ( 0.03%)   0          0              0            0           0               0           0           0           	LOG("core.sdallocx.entry", "ptr: %p, size: %zu, flags: %d", ptr,
     .            .          .              .            .           .               .           .           .           		size, flags);
     .            .          .              .            .           .               .           .           .           
10,219 ( 0.11%) 284 ( 0.20%) 2 ( 0.03%) 2,787 ( 0.11%)   0           0           3,716 ( 0.12%)  6 ( 0.11%)  0           	if (flags != 0 || !free_fastpath(ptr, size, true)) {
    30 ( 0.00%)   1 ( 0.00%) 0             15 ( 0.00%)   0           0               5 ( 0.00%)  0           0           		sdallocx_default(ptr, size, flags);
     .            .          .              .            .           .               .           .           .           	}
     .            .          .              .            .           .               .           .           .           
 2,787 ( 0.03%) 173 ( 0.12%) 1 ( 0.01%)     0            0           0               0           0           0           	LOG("core.sdallocx.exit", "");
 6,503 ( 0.07%) 301 ( 0.21%) 2 ( 0.03%) 4,645 ( 0.19%)   0           0               0           0           0           }
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           void JEMALLOC_NOTHROW
     .            .          .              .            .           .               .           .           .           je_sdallocx_noflags(void *ptr, size_t size) {
     .            .          .              .            .           .               .           .           .           	LOG("core.sdallocx.entry", "ptr: %p, size: %zu, flags: 0", ptr,
     .            .          .              .            .           .               .           .           .           		size);
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           	if (!free_fastpath(ptr, size, true)) {
     .            .          .              .            .           .               .           .           .           		sdallocx_default(ptr, size, 0);
-- line 3951 ----------------------------------------
-- line 4313 ----------------------------------------
     .            .          .              .            .           .               .           .           .            * the allocator isn't fully initialized at fork time.  The following library
     .            .          .              .            .           .               .           .           .            * constructor is a partial solution to this problem.  It may still be possible
     .            .          .              .            .           .               .           .           .            * to trigger the deadlock described above, but doing so would involve forking
     .            .          .              .            .           .               .           .           .            * via a library constructor that runs before jemalloc's runs.
     .            .          .              .            .           .               .           .           .            */
     .            .          .              .            .           .               .           .           .           #ifndef JEMALLOC_JET
     .            .          .              .            .           .               .           .           .           JEMALLOC_ATTR(constructor)
     .            .          .              .            .           .               .           .           .           static void
     3 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)     0            0           0               1 ( 0.00%)  0           0           jemalloc_constructor(void) {
     .            .          .              .            .           .               .           .           .           	malloc_init();
     3 ( 0.00%)   0          0              2 ( 0.00%)   0           0               0           0           0           }
     .            .          .              .            .           .               .           .           .           #endif
     .            .          .              .            .           .               .           .           .           
     .            .          .              .            .           .               .           .           .           #ifndef JEMALLOC_MUTEX_INIT_CB
     .            .          .              .            .           .               .           .           .           void
     .            .          .              .            .           .               .           .           .           jemalloc_prefork(void)
     .            .          .              .            .           .               .           .           .           #else
     .            .          .              .            .           .               .           .           .           JEMALLOC_EXPORT void
     .            .          .              .            .           .               .           .           .           _malloc_prefork(void)
-- line 4331 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/ashy5000/dev/cryptocurrency/contracts/target/debug/build/tikv-jemalloc-sys-7365f40ecb99e085/out/build/include/jemalloc/internal/tsd.h
--------------------------------------------------------------------------------
Ir              I1mr           ILmr         Dr              D1mr        DLmr       Dw              D1mw        DLmw        

-- line 261 ----------------------------------------
     .              .            .               .           .          .               .           .           .           JEMALLOC_ALWAYS_INLINE uint8_t
     .              .            .               .           .          .               .           .           .           tsd_state_get(tsd_t *tsd) {
     .              .            .               .           .          .               .           .           .           	/*
     .              .            .               .           .          .               .           .           .           	 * This should be atomic.  Unfortunately, compilers right now can't tell
     .              .            .               .           .          .               .           .           .           	 * that this can be done as a memory comparison, and forces a load into
     .              .            .               .           .          .               .           .           .           	 * a register that hurts fast-path performance.
     .              .            .               .           .          .               .           .           .           	 */
     .              .            .               .           .          .               .           .           .           	/* return atomic_load_u8(&tsd->state, ATOMIC_RELAXED); */
94,676 ( 1.00%) 1,147 ( 0.80%)  44 ( 0.62%) 28,634 ( 1.18%) 63 ( 1.09%) 0          43,953 ( 1.39%)  0           0           	return *(uint8_t *)&tsd->state;
     .              .            .               .           .          .               .           .           .           }
     .              .            .               .           .          .               .           .           .           
     .              .            .               .           .          .               .           .           .           /*
     .              .            .               .           .          .               .           .           .            * Wrapper around tsd_t that makes it possible to avoid implicit conversion
     .              .            .               .           .          .               .           .           .            * between tsd_t and tsdn_t, where tsdn_t is "nullable" and has to be
     .              .            .               .           .          .               .           .           .            * explicitly converted to tsd_t, which is non-nullable.
     .              .            .               .           .          .               .           .           .            */
     .              .            .               .           .          .               .           .           .           struct tsdn_s {
     .              .            .               .           .          .               .           .           .           	tsd_t tsd;
     .              .            .               .           .          .               .           .           .           };
     .              .            .               .           .          .               .           .           .           #define TSDN_NULL ((tsdn_t *)0)
     .              .            .               .           .          .               .           .           .           JEMALLOC_ALWAYS_INLINE tsdn_t *
     .              .            .               .           .          .               .           .           .           tsd_tsdn(tsd_t *tsd) {
28,604 ( 0.30%)   474 ( 0.33%)  17 ( 0.24%)  9,962 ( 0.41%)  0          0          11,269 ( 0.36%) 50 ( 0.94%) 25 ( 0.60%)  	return (tsdn_t *)tsd;
     .              .            .               .           .          .               .           .           .           }
     .              .            .               .           .          .               .           .           .           
     .              .            .               .           .          .               .           .           .           JEMALLOC_ALWAYS_INLINE bool
     .              .            .               .           .          .               .           .           .           tsdn_null(const tsdn_t *tsdn) {
43,053 ( 0.45%)   367 ( 0.25%)  16 ( 0.23%) 23,655 ( 0.97%)  0          0          11,284 ( 0.36%)  0           0           	return tsdn == NULL;
     .              .            .               .           .          .               .           .           .           }
     .              .            .               .           .          .               .           .           .           
     .              .            .               .           .          .               .           .           .           JEMALLOC_ALWAYS_INLINE tsd_t *
     .              .            .               .           .          .               .           .           .           tsdn_tsd(tsdn_t *tsdn) {
42,524 ( 0.45%)   994 ( 0.69%)  27 ( 0.38%) 15,553 ( 0.64%)  0          0          12,352 ( 0.39%)  1 ( 0.02%)  0           	assert(!tsdn_null(tsdn));
     .              .            .               .           .          .               .           .           .           
64,242 ( 0.68%) 1,574 ( 1.09%)  75 ( 1.06%)  4,226 ( 0.17%)  0          0          19,216 ( 0.61%) 23 ( 0.43%) 18 ( 0.43%)  	return &tsdn->tsd;
     .              .            .               .           .          .               .           .           .           }
     .              .            .               .           .          .               .           .           .           
     .              .            .               .           .          .               .           .           .           /*
     .              .            .               .           .          .               .           .           .            * We put the platform-specific data declarations and inlines into their own
     .              .            .               .           .          .               .           .           .            * header files to avoid cluttering this file.  They define tsd_boot0,
     .              .            .               .           .          .               .           .           .            * tsd_boot1, tsd_boot, tsd_booted_get, tsd_get_allocates, tsd_get, and tsd_set.
     .              .            .               .           .          .               .           .           .            */
     .              .            .               .           .          .               .           .           .           #ifdef JEMALLOC_MALLOC_THREAD_CLEANUP
-- line 303 ----------------------------------------
-- line 315 ----------------------------------------
     .              .            .               .           .          .               .           .           .            * foo.  This omits some safety checks, and so can be used during tsd
     .              .            .               .           .          .               .           .           .            * initialization and cleanup.
     .              .            .               .           .          .               .           .           .            */
     .              .            .               .           .          .               .           .           .           #define O(n, t, nt)							\
     .              .            .               .           .          .               .           .           .           JEMALLOC_ALWAYS_INLINE t *						\
     .              .            .               .           .          .               .           .           .           tsd_##n##p_get_unsafe(tsd_t *tsd) {					\
     .              .            .               .           .          .               .           .           .           	return &tsd->TSD_MANGLE(n);					\
     .              .            .               .           .          .               .           .           .           }
50,589 ( 0.53%)   415 ( 0.29%)  16 ( 0.23%)  6,010 ( 0.25%)  0          0          22,525 ( 0.71%)  0           0           TSD_DATA_SLOW
19,515 ( 0.21%)   318 ( 0.22%)   8 ( 0.11%)  8,416 ( 0.35%)  0          0           1,966 ( 0.06%) 27 ( 0.51%) 27 ( 0.64%)  TSD_DATA_FAST
 4,606 ( 0.05%)   140 ( 0.10%)   4 ( 0.06%)  2,440 ( 0.10%)  1 ( 0.02%) 0           1,054 ( 0.03%)  0           0           TSD_DATA_SLOWER
     .              .            .               .           .          .               .           .           .           #undef O
     .              .            .               .           .          .               .           .           .           
     .              .            .               .           .          .               .           .           .           /* tsd_foop_get(tsd) returns a pointer to the thread-local instance of foo. */
     .              .            .               .           .          .               .           .           .           #define O(n, t, nt)							\
     .              .            .               .           .          .               .           .           .           JEMALLOC_ALWAYS_INLINE t *						\
     .              .            .               .           .          .               .           .           .           tsd_##n##p_get(tsd_t *tsd) {						\
     .              .            .               .           .          .               .           .           .           	/*								\
     .              .            .               .           .          .               .           .           .           	 * Because the state might change asynchronously if it's	\
-- line 333 ----------------------------------------
-- line 336 ----------------------------------------
     .              .            .               .           .          .               .           .           .           	uint8_t state = tsd_state_get(tsd);				\
     .              .            .               .           .          .               .           .           .           	assert(state == tsd_state_nominal ||				\
     .              .            .               .           .          .               .           .           .           	    state == tsd_state_nominal_slow ||				\
     .              .            .               .           .          .               .           .           .           	    state == tsd_state_nominal_recompute ||			\
     .              .            .               .           .          .               .           .           .           	    state == tsd_state_reincarnated ||				\
     .              .            .               .           .          .               .           .           .           	    state == tsd_state_minimal_initialized);			\
     .              .            .               .           .          .               .           .           .           	return tsd_##n##p_get_unsafe(tsd);				\
     .              .            .               .           .          .               .           .           .           }
41,528 ( 0.44%) 1,520 ( 1.05%) 105 ( 1.48%) 11,618 ( 0.48%)  0          0          14,290 ( 0.45%) 10 ( 0.19%)  7 ( 0.17%)  TSD_DATA_SLOW
39,541 ( 0.42%) 1,500 ( 1.04%)  44 ( 0.62%)  5,133 ( 0.21%)  0          0          11,223 ( 0.36%)  8 ( 0.15%)  2 ( 0.05%)  TSD_DATA_FAST
23,624 ( 0.25%) 1,721 ( 1.19%)  69 ( 0.97%)  2,522 ( 0.10%)  0          0           8,936 ( 0.28%)  6 ( 0.11%)  2 ( 0.05%)  TSD_DATA_SLOWER
     .              .            .               .           .          .               .           .           .           #undef O
     .              .            .               .           .          .               .           .           .           
     .              .            .               .           .          .               .           .           .           /*
     .              .            .               .           .          .               .           .           .            * tsdn_foop_get(tsdn) returns either the thread-local instance of foo (if tsdn
     .              .            .               .           .          .               .           .           .            * isn't NULL), or NULL (if tsdn is NULL), cast to the nullable pointer type.
     .              .            .               .           .          .               .           .           .            */
     .              .            .               .           .          .               .           .           .           #define O(n, t, nt)							\
     .              .            .               .           .          .               .           .           .           JEMALLOC_ALWAYS_INLINE nt *						\
-- line 354 ----------------------------------------
-- line 356 ----------------------------------------
     .              .            .               .           .          .               .           .           .           	if (tsdn_null(tsdn)) {						\
     .              .            .               .           .          .               .           .           .           		return NULL;						\
     .              .            .               .           .          .               .           .           .           	}								\
     .              .            .               .           .          .               .           .           .           	tsd_t *tsd = tsdn_tsd(tsdn);					\
     .              .            .               .           .          .               .           .           .           	return (nt *)tsd_##n##p_get(tsd);				\
     .              .            .               .           .          .               .           .           .           }
     .              .            .               .           .          .               .           .           .           TSD_DATA_SLOW
     .              .            .               .           .          .               .           .           .           TSD_DATA_FAST
20,668 ( 0.22%)   786 ( 0.55%)  33 ( 0.46%)  5,377 ( 0.22%)  0          0           9,985 ( 0.32%) 26 ( 0.49%) 17 ( 0.41%)  TSD_DATA_SLOWER
     .              .            .               .           .          .               .           .           .           #undef O
     .              .            .               .           .          .               .           .           .           
     .              .            .               .           .          .               .           .           .           /* tsd_foo_get(tsd) returns the value of the thread-local instance of foo. */
     .              .            .               .           .          .               .           .           .           #define O(n, t, nt)							\
     .              .            .               .           .          .               .           .           .           JEMALLOC_ALWAYS_INLINE t						\
     .              .            .               .           .          .               .           .           .           tsd_##n##_get(tsd_t *tsd) {						\
     .              .            .               .           .          .               .           .           .           	return *tsd_##n##p_get(tsd);					\
     .              .            .               .           .          .               .           .           .           }
10,778 ( 0.11%)   153 ( 0.11%)   7 ( 0.10%)  2,625 ( 0.11%)  5 ( 0.09%) 0           5,753 ( 0.18%)  4 ( 0.08%)  3 ( 0.07%)  TSD_DATA_SLOW
     .              .            .               .           .          .               .           .           .           TSD_DATA_FAST
     .              .            .               .           .          .               .           .           .           TSD_DATA_SLOWER
     .              .            .               .           .          .               .           .           .           #undef O
     .              .            .               .           .          .               .           .           .           
     .              .            .               .           .          .               .           .           .           /* tsd_foo_set(tsd, val) updates the thread-local instance of foo to be val. */
     .              .            .               .           .          .               .           .           .           #define O(n, t, nt)							\
     .              .            .               .           .          .               .           .           .           JEMALLOC_ALWAYS_INLINE void						\
     .              .            .               .           .          .               .           .           .           tsd_##n##_set(tsd_t *tsd, t val) {					\
     .              .            .               .           .          .               .           .           .           	assert(tsd_state_get(tsd) != tsd_state_reincarnated &&		\
     .              .            .               .           .          .               .           .           .           	    tsd_state_get(tsd) != tsd_state_minimal_initialized);	\
     .              .            .               .           .          .               .           .           .           	*tsd_##n##p_get(tsd) = val;					\
     .              .            .               .           .          .               .           .           .           }
 1,874 ( 0.02%)    74 ( 0.05%)  10 ( 0.14%)    694 ( 0.03%)  0          0             338 ( 0.01%)  0           0           TSD_DATA_SLOW
     .              .            .               .           .          .               .           .           .           TSD_DATA_FAST
     .              .            .               .           .          .               .           .           .           TSD_DATA_SLOWER
     .              .            .               .           .          .               .           .           .           #undef O
     .              .            .               .           .          .               .           .           .           
     .              .            .               .           .          .               .           .           .           JEMALLOC_ALWAYS_INLINE void
     .              .            .               .           .          .               .           .           .           tsd_assert_fast(tsd_t *tsd) {
     .              .            .               .           .          .               .           .           .           	/*
     .              .            .               .           .          .               .           .           .           	 * Note that our fastness assertion does *not* include global slowness
     .              .            .               .           .          .               .           .           .           	 * counters; it's not in general possible to ensure that they won't
     .              .            .               .           .          .               .           .           .           	 * change asynchronously from underneath us.
     .              .            .               .           .          .               .           .           .           	 */
   684 ( 0.01%)     0            0               0           0          0               0           0           0           	assert(!malloc_slow && tsd_tcache_enabled_get(tsd) &&
     .              .            .               .           .          .               .           .           .           	    tsd_reentrancy_level_get(tsd) == 0);
   226 ( 0.00%)    94 ( 0.07%)  11 ( 0.15%)     25 ( 0.00%)  0          0              30 ( 0.00%) 10 ( 0.19%)  3 ( 0.07%)  }
     .              .            .               .           .          .               .           .           .           
     .              .            .               .           .          .               .           .           .           JEMALLOC_ALWAYS_INLINE bool
     .              .            .               .           .          .               .           .           .           tsd_fast(tsd_t *tsd) {
    69 ( 0.00%)     3 ( 0.00%)   1 ( 0.01%)      0           0          0              23 ( 0.00%)  2 ( 0.04%)  1 ( 0.02%)  	bool fast = (tsd_state_get(tsd) == tsd_state_nominal);
    90 ( 0.00%)    16 ( 0.01%)   1 ( 0.01%)     45 ( 0.00%)  0          0              22 ( 0.00%)  1 ( 0.02%)  0           	if (fast) {
     .              .            .               .           .          .               .           .           .           		tsd_assert_fast(tsd);
     .              .            .               .           .          .               .           .           .           	}
     .              .            .               .           .          .               .           .           .           
    23 ( 0.00%)     1 ( 0.00%)   1 ( 0.01%)     23 ( 0.00%)  0          0               0           0           0           	return fast;
     .              .            .               .           .          .               .           .           .           }
     .              .            .               .           .          .               .           .           .           
     .              .            .               .           .          .               .           .           .           JEMALLOC_ALWAYS_INLINE tsd_t *
     .              .            .               .           .          .               .           .           .           tsd_fetch_impl(bool init, bool minimal) {
   492 ( 0.01%)     5 ( 0.00%)   3 ( 0.04%)    246 ( 0.01%)  0          0             246 ( 0.01%) 12 ( 0.23%)  7 ( 0.17%)  	tsd_t *tsd = tsd_get(init);
     .              .            .               .           .          .               .           .           .           
   736 ( 0.01%)     1 ( 0.00%)   1 ( 0.01%)    123 ( 0.01%)  0          0               0           0           0           	if (!init && tsd_get_allocates() && tsd == NULL) {
     .              .            .               .           .          .               .           .           .           		return NULL;
     .              .            .               .           .          .               .           .           .           	}
   738 ( 0.01%)    73 ( 0.05%)   9 ( 0.13%)    123 ( 0.01%)  0          0             123 ( 0.00%)  1 ( 0.02%)  0           	assert(tsd != NULL);
     .              .            .               .           .          .               .           .           .           
   615 ( 0.01%)     2 ( 0.00%)   2 ( 0.03%)      0           0          0               0           0           0           	if (unlikely(tsd_state_get(tsd) != tsd_state_nominal)) {
     6 ( 0.00%)     1 ( 0.00%)   0               2 ( 0.00%)  0          0               1 ( 0.00%)  0           0           		return tsd_fetch_slow(tsd, minimal);
     .              .            .               .           .          .               .           .           .           	}
   732 ( 0.01%)   169 ( 0.12%)  10 ( 0.14%)    122 ( 0.01%)  0          0             122 ( 0.00%) 20 ( 0.38%) 10 ( 0.24%)  	assert(tsd_fast(tsd));
     .              .            .               .           .          .               .           .           .           	tsd_assert_fast(tsd);
     .              .            .               .           .          .               .           .           .           
   122 ( 0.00%)     0            0             122 ( 0.01%)  0          0               0           0           0           	return tsd;
     .              .            .               .           .          .               .           .           .           }
     .              .            .               .           .          .               .           .           .           
     .              .            .               .           .          .               .           .           .           /* Get a minimal TSD that requires no cleanup.  See comments in free(). */
     .              .            .               .           .          .               .           .           .           JEMALLOC_ALWAYS_INLINE tsd_t *
     .              .            .               .           .          .               .           .           .           tsd_fetch_min(void) {
     5 ( 0.00%)     0            0               0           0          0               0           0           0           	return tsd_fetch_impl(true, true);
     .              .            .               .           .          .               .           .           .           }
     .              .            .               .           .          .               .           .           .           
     .              .            .               .           .          .               .           .           .           /* For internal background threads use only. */
     .              .            .               .           .          .               .           .           .           JEMALLOC_ALWAYS_INLINE tsd_t *
     .              .            .               .           .          .               .           .           .           tsd_internal_fetch(void) {
     .              .            .               .           .          .               .           .           .           	tsd_t *tsd = tsd_fetch_min();
     .              .            .               .           .          .               .           .           .           	/* Use reincarnated state to prevent full initialization. */
     .              .            .               .           .          .               .           .           .           	tsd_state_set(tsd, tsd_state_reincarnated);
     .              .            .               .           .          .               .           .           .           
     .              .            .               .           .          .               .           .           .           	return tsd;
     .              .            .               .           .          .               .           .           .           }
     .              .            .               .           .          .               .           .           .           
     .              .            .               .           .          .               .           .           .           JEMALLOC_ALWAYS_INLINE tsd_t *
     .              .            .               .           .          .               .           .           .           tsd_fetch(void) {
   118 ( 0.00%)     1 ( 0.00%)   1 ( 0.01%)      0           0          0               0           0           0           	return tsd_fetch_impl(true, false);
     .              .            .               .           .          .               .           .           .           }
     .              .            .               .           .          .               .           .           .           
     .              .            .               .           .          .               .           .           .           static inline bool
    36 ( 0.00%)     3 ( 0.00%)   1 ( 0.01%)      6 ( 0.00%)  0          0              18 ( 0.00%)  1 ( 0.02%)  1 ( 0.02%)  tsd_nominal(tsd_t *tsd) {
    18 ( 0.00%)     0            0               0           0          0               6 ( 0.00%)  0           0           	bool nominal = tsd_state_get(tsd) <= tsd_state_nominal_max;
    24 ( 0.00%)     4 ( 0.00%)   2 ( 0.03%)      0           0          0               0           0           0           	assert(nominal || tsd_reentrancy_level_get(tsd) > 0);
     .              .            .               .           .          .               .           .           .           
     6 ( 0.00%)     3 ( 0.00%)   1 ( 0.01%)      6 ( 0.00%)  0          0               0           0           0           	return nominal;
    12 ( 0.00%)     0            0              12 ( 0.00%)  0          0               0           0           0           }
     .              .            .               .           .          .               .           .           .           
     .              .            .               .           .          .               .           .           .           JEMALLOC_ALWAYS_INLINE tsdn_t *
     .              .            .               .           .          .               .           .           .           tsdn_fetch(void) {
     .              .            .               .           .          .               .           .           .           	if (!tsd_booted_get()) {
     .              .            .               .           .          .               .           .           .           		return NULL;
     .              .            .               .           .          .               .           .           .           	}
     .              .            .               .           .          .               .           .           .           
     .              .            .               .           .          .               .           .           .           	return tsd_tsdn(tsd_fetch_impl(false, false));
     .              .            .               .           .          .               .           .           .           }
     .              .            .               .           .          .               .           .           .           
     .              .            .               .           .          .               .           .           .           JEMALLOC_ALWAYS_INLINE rtree_ctx_t *
     .              .            .               .           .          .               .           .           .           tsd_rtree_ctx(tsd_t *tsd) {
 2,231 ( 0.02%)    24 ( 0.02%)   1 ( 0.01%)    498 ( 0.02%)  0          0           1,000 ( 0.03%)  0           0           	return tsd_rtree_ctxp_get(tsd);
     .              .            .               .           .          .               .           .           .           }
     .              .            .               .           .          .               .           .           .           
     .              .            .               .           .          .               .           .           .           JEMALLOC_ALWAYS_INLINE rtree_ctx_t *
     .              .            .               .           .          .               .           .           .           tsdn_rtree_ctx(tsdn_t *tsdn, rtree_ctx_t *fallback) {
     .              .            .               .           .          .               .           .           .           	/*
     .              .            .               .           .          .               .           .           .           	 * If tsd cannot be accessed, initialize the fallback rtree_ctx and
     .              .            .               .           .          .               .           .           .           	 * return a pointer to it.
     .              .            .               .           .          .               .           .           .           	 */
 3,159 ( 0.03%)   133 ( 0.09%)   3 ( 0.04%)    898 ( 0.04%)  0          0           1,031 ( 0.03%)  0           0           	if (unlikely(tsdn_null(tsdn))) {
 1,752 ( 0.02%)   401 ( 0.28%)   2 ( 0.03%)    449 ( 0.02%)  0          0           1,029 ( 0.03%)  0           0           		rtree_ctx_data_init(fallback);
 4,256 ( 0.04%)   221 ( 0.15%)   6 ( 0.08%)  1,259 ( 0.05%)  0          0           2,719 ( 0.09%)  1 ( 0.02%)  0           		return fallback;
     .              .            .               .           .          .               .           .           .           	}
 2,483 ( 0.03%)    65 ( 0.05%)   1 ( 0.01%)    500 ( 0.02%)  0          0           1,530 ( 0.05%)  0           0           	return tsd_rtree_ctx(tsdn_tsd(tsdn));
     .              .            .               .           .          .               .           .           .           }
     .              .            .               .           .          .               .           .           .           
     .              .            .               .           .          .               .           .           .           static inline bool
     .              .            .               .           .          .               .           .           .           tsd_state_nocleanup(tsd_t *tsd) {
     .              .            .               .           .          .               .           .           .           	return tsd_state_get(tsd) == tsd_state_reincarnated ||
     .              .            .               .           .          .               .           .           .           	    tsd_state_get(tsd) == tsd_state_minimal_initialized;
     .              .            .               .           .          .               .           .           .           }
     .              .            .               .           .          .               .           .           .           
     .              .            .               .           .          .               .           .           .           /*
     .              .            .               .           .          .               .           .           .            * These "raw" tsd reentrancy functions don't have any debug checking to make
     .              .            .               .           .          .               .           .           .            * sure that we're not touching arena 0.  Better is to call pre_reentrancy and
     .              .            .               .           .          .               .           .           .            * post_reentrancy if this is possible.
     .              .            .               .           .          .               .           .           .            */
     .              .            .               .           .          .               .           .           .           static inline void
     8 ( 0.00%)     2 ( 0.00%)   2 ( 0.03%)      2 ( 0.00%)  0          0               4 ( 0.00%)  0           0           tsd_pre_reentrancy_raw(tsd_t *tsd) {
     1 ( 0.00%)     0            0               0           0          0               1 ( 0.00%)  0           0           	bool fast = tsd_fast(tsd);
     8 ( 0.00%)     1 ( 0.00%)   1 ( 0.01%)      2 ( 0.00%)  0          0               2 ( 0.00%)  0           0           	assert(tsd_reentrancy_level_get(tsd) < INT8_MAX);
     3 ( 0.00%)     0            0               1 ( 0.00%)  0          0               1 ( 0.00%)  0           0           	++*tsd_reentrancy_levelp_get(tsd);
     2 ( 0.00%)     0            0               1 ( 0.00%)  0          0               0           0           0           	if (fast) {
     .              .            .               .           .          .               .           .           .           		/* Prepare slow path for reentrancy. */
     .              .            .               .           .          .               .           .           .           		tsd_slow_update(tsd);
     .              .            .               .           .          .               .           .           .           		assert(tsd_state_get(tsd) == tsd_state_nominal_slow);
     .              .            .               .           .          .               .           .           .           	}
     3 ( 0.00%)     1 ( 0.00%)   1 ( 0.01%)      2 ( 0.00%)  0          0               0           0           0           }
     .              .            .               .           .          .               .           .           .           
     .              .            .               .           .          .               .           .           .           static inline void
     8 ( 0.00%)     0            0               2 ( 0.00%)  0          0               4 ( 0.00%)  0           0           tsd_post_reentrancy_raw(tsd_t *tsd) {
     1 ( 0.00%)     0            0               0           0          0               1 ( 0.00%)  0           0           	int8_t *reentrancy_level = tsd_reentrancy_levelp_get(tsd);
     4 ( 0.00%)     0            0               0           0          0               0           0           0           	assert(*reentrancy_level > 0);
    10 ( 0.00%)     1 ( 0.00%)   1 ( 0.01%)      5 ( 0.00%)  0          0               1 ( 0.00%)  0           0           	if (--*reentrancy_level == 0) {
     3 ( 0.00%)     0            0               1 ( 0.00%)  0          0               1 ( 0.00%)  0           0           		tsd_slow_update(tsd);
     .              .            .               .           .          .               .           .           .           	}
     3 ( 0.00%)     0            0               2 ( 0.00%)  0          0               0           0           0           }
     .              .            .               .           .          .               .           .           .           
     .              .            .               .           .          .               .           .           .           #endif /* JEMALLOC_INTERNAL_TSD_H */

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/ashy5000/dev/cryptocurrency/contracts/target/debug/build/tikv-jemalloc-sys-7365f40ecb99e085/out/build/src/sc.c
--------------------------------------------------------------------------------
Ir             I1mr       ILmr       Dr             D1mr       DLmr       Dw             D1mw       DLmw       

-- line 9 ----------------------------------------
    .          .          .              .          .          .              .          .          .           /*
    .          .          .              .          .          .              .          .          .            * This module computes the size classes used to satisfy allocations.  The logic
    .          .          .              .          .          .              .          .          .            * here was ported more or less line-by-line from a shell script, and because of
    .          .          .              .          .          .              .          .          .            * that is not the most idiomatic C.  Eventually we should fix this, but for now
    .          .          .              .          .          .              .          .          .            * at least the damage is compartmentalized to this file.
    .          .          .              .          .          .              .          .          .            */
    .          .          .              .          .          .              .          .          .           
    .          .          .              .          .          .              .          .          .           size_t
1,608 ( 0.02%) 2 ( 0.00%) 2 ( 0.03%)     0          0          0          1,072 ( 0.03%) 1 ( 0.02%) 0           reg_size_compute(int lg_base, int lg_delta, int ndelta) {
3,216 ( 0.03%) 0          0            804 ( 0.03%) 0          0              0          0          0           	return (ZU(1) << lg_base) + (ZU(ndelta) << lg_delta);
  536 ( 0.01%) 0          0            536 ( 0.02%) 0          0              0          0          0           }
    .          .          .              .          .          .              .          .          .           
    .          .          .              .          .          .              .          .          .           /* Returns the number of pages in the slab. */
    .          .          .              .          .          .              .          .          .           static int
  288 ( 0.00%) 1 ( 0.00%) 1 ( 0.01%)     0          0          0            180 ( 0.01%) 1 ( 0.02%) 0           slab_size(int lg_page, int lg_base, int lg_delta, int ndelta) {
  216 ( 0.00%) 0          0             36 ( 0.00%) 0          0             36 ( 0.00%) 0          0           	size_t page = (ZU(1) << lg_page);
  252 ( 0.00%) 0          0            108 ( 0.00%) 0          0             72 ( 0.00%) 0          0           	size_t reg_size = reg_size_compute(lg_base, lg_delta, ndelta);
    .          .          .              .          .          .              .          .          .           
   72 ( 0.00%) 0          0             36 ( 0.00%) 0          0             36 ( 0.00%) 0          0           	size_t try_slab_size = page;
  144 ( 0.00%) 1 ( 0.00%) 1 ( 0.01%)    72 ( 0.00%) 0          0             36 ( 0.00%) 0          0           	size_t try_nregs = try_slab_size / reg_size;
   36 ( 0.00%) 0          0              0          0          0             36 ( 0.00%) 0          0           	size_t perfect_slab_size = 0;
   36 ( 0.00%) 0          0              0          0          0             36 ( 0.00%) 0          0           	bool perfect = false;
    .          .          .              .          .          .              .          .          .           	/*
    .          .          .              .          .          .              .          .          .           	 * This loop continues until we find the least common multiple of the
    .          .          .              .          .          .              .          .          .           	 * page size and size class size.  Size classes are all of the form
    .          .          .              .          .          .              .          .          .           	 * base + ndelta * delta == (ndelta + base/ndelta) * delta, which is
    .          .          .              .          .          .              .          .          .           	 * (ndelta + ngroup) * delta.  The way we choose slabbing strategies
    .          .          .              .          .          .              .          .          .           	 * means that delta is at most the page size and ndelta < ngroup.  So
    .          .          .              .          .          .              .          .          .           	 * the loop executes for at most 2 * ngroup - 1 iterations, which is
    .          .          .              .          .          .              .          .          .           	 * also the bound on the number of pages in a slab chosen by default.
    .          .          .              .          .          .              .          .          .           	 * With the current default settings, this is at most 7.
    .          .          .              .          .          .              .          .          .           	 */
  720 ( 0.01%) 0          0            171 ( 0.01%) 0          0              0          0          0           	while (!perfect) {
  270 ( 0.00%) 0          0            135 ( 0.01%) 0          0            135 ( 0.00%) 0          0           		perfect_slab_size = try_slab_size;
  270 ( 0.00%) 0          0            135 ( 0.01%) 0          0            135 ( 0.00%) 0          0           		size_t perfect_nregs = try_nregs;
  270 ( 0.00%) 0          0            270 ( 0.01%) 0          0              0          0          0           		try_slab_size += page;
  540 ( 0.01%) 0          0            270 ( 0.01%) 0          0            135 ( 0.00%) 0          0           		try_nregs = try_slab_size / reg_size;
  540 ( 0.01%) 0          0            405 ( 0.02%) 0          0              0          0          0           		if (perfect_slab_size == perfect_nregs * reg_size) {
   36 ( 0.00%) 0          0              0          0          0             36 ( 0.00%) 0          0           			perfect = true;
    .          .          .              .          .          .              .          .          .           		}
    .          .          .              .          .          .              .          .          .           	}
  108 ( 0.00%) 0          0             72 ( 0.00%) 0          0              0          0          0           	return (int)(perfect_slab_size / page);
   72 ( 0.00%) 0          0             72 ( 0.00%) 0          0              0          0          0           }
    .          .          .              .          .          .              .          .          .           
    .          .          .              .          .          .              .          .          .           static void
    .          .          .              .          .          .              .          .          .           size_class(
    .          .          .              .          .          .              .          .          .               /* Output. */
    .          .          .              .          .          .              .          .          .               sc_t *sc,
    .          .          .              .          .          .              .          .          .               /* Configuration decisions. */
    .          .          .              .          .          .              .          .          .               int lg_max_lookup, int lg_page, int lg_ngroup,
    .          .          .              .          .          .              .          .          .               /* Inputs specific to the size class. */
2,320 ( 0.02%) 2 ( 0.00%) 2 ( 0.03%)     0          0          0          1,624 ( 0.05%) 1 ( 0.02%) 0               int index, int lg_base, int lg_delta, int ndelta) {
  696 ( 0.01%) 0          0            464 ( 0.02%) 0          0            232 ( 0.01%) 0          0           	sc->index = index;
  696 ( 0.01%) 0          0            464 ( 0.02%) 0          0            232 ( 0.01%) 0          0           	sc->lg_base = lg_base;
  696 ( 0.01%) 0          0            464 ( 0.02%) 0          0            232 ( 0.01%) 0          0           	sc->lg_delta = lg_delta;
  696 ( 0.01%) 0          0            464 ( 0.02%) 0          0            232 ( 0.01%) 0          0           	sc->ndelta = ndelta;
1,624 ( 0.02%) 1 ( 0.00%) 1 ( 0.01%)   696 ( 0.03%) 0          0            464 ( 0.01%) 0          0           	size_t size = reg_size_compute(lg_base, lg_delta, ndelta);
2,552 ( 0.03%) 0          0            696 ( 0.03%) 0          0            232 ( 0.01%) 0          0           	sc->psz = (size % (ZU(1) << lg_page) == 0);
  464 ( 0.00%) 0          0            232 ( 0.01%) 0          0              0          0          0           	if (index == 0) {
    4 ( 0.00%) 1 ( 0.00%) 1 ( 0.01%)     0          0          0              0          0          0           		assert(!sc->psz);
    .          .          .              .          .          .              .          .          .           	}
2,088 ( 0.02%) 1 ( 0.00%) 1 ( 0.01%)   696 ( 0.03%) 0          0              0          0          0           	if (size < (ZU(1) << (lg_page + lg_ngroup))) {
   72 ( 0.00%) 0          0             36 ( 0.00%) 0          0             36 ( 0.00%) 0          0           		sc->bin = true;
  324 ( 0.00%) 1 ( 0.00%) 1 ( 0.01%)   180 ( 0.01%) 0          0             72 ( 0.00%) 0          0           		sc->pgs = slab_size(lg_page, lg_base, lg_delta, ndelta);
    .          .          .              .          .          .              .          .          .           	} else {
  392 ( 0.00%) 0          0            196 ( 0.01%) 0          0            196 ( 0.01%) 0          0           		sc->bin = false;
  392 ( 0.00%) 0          0            196 ( 0.01%) 0          0            196 ( 0.01%) 0          0           		sc->pgs = 0;
    .          .          .              .          .          .              .          .          .           	}
1,624 ( 0.02%) 0          0            464 ( 0.02%) 0          0              0          0          0           	if (size <= (ZU(1) << lg_max_lookup)) {
   87 ( 0.00%) 0          0             58 ( 0.00%) 0          0             29 ( 0.00%) 0          0           		sc->lg_delta_lookup = lg_delta;
    .          .          .              .          .          .              .          .          .           	} else {
  406 ( 0.00%) 0          0            203 ( 0.01%) 0          0            203 ( 0.01%) 0          0           		sc->lg_delta_lookup = 0;
    .          .          .              .          .          .              .          .          .           	}
  725 ( 0.01%) 0          0            464 ( 0.02%) 0          0              0          0          0           }
    .          .          .              .          .          .              .          .          .           
    .          .          .              .          .          .              .          .          .           static void
    .          .          .              .          .          .              .          .          .           size_classes(
    .          .          .              .          .          .              .          .          .               /* Output. */
    .          .          .              .          .          .              .          .          .               sc_data_t *sc_data,
    .          .          .              .          .          .              .          .          .               /* Determined by the system. */
    .          .          .              .          .          .              .          .          .               size_t lg_ptr_size, int lg_quantum,
    .          .          .              .          .          .              .          .          .               /* Configuration decisions. */
   10 ( 0.00%) 2 ( 0.00%) 2 ( 0.03%)     0          0          0              7 ( 0.00%) 1 ( 0.02%) 1 ( 0.02%)      int lg_tiny_min, int lg_max_lookup, int lg_page, int lg_ngroup) {
    6 ( 0.00%) 0          0              1 ( 0.00%) 0          0              1 ( 0.00%) 1 ( 0.02%) 1 ( 0.02%)  	int ptr_bits = (1 << lg_ptr_size) * 8;
    6 ( 0.00%) 0          0              1 ( 0.00%) 0          0              1 ( 0.00%) 0          0           	int ngroup = (1 << lg_ngroup);
    1 ( 0.00%) 0          0              0          0          0              1 ( 0.00%) 0          0           	int ntiny = 0;
    1 ( 0.00%) 0          0              0          0          0              1 ( 0.00%) 0          0           	int nlbins = 0;
    1 ( 0.00%) 0          0              0          0          0              1 ( 0.00%) 0          0           	int lg_tiny_maxclass = (unsigned)-1;
    1 ( 0.00%) 1 ( 0.00%) 1 ( 0.01%)     0          0          0              1 ( 0.00%) 0          0           	int nbins = 0;
    1 ( 0.00%) 0          0              0          0          0              1 ( 0.00%) 0          0           	int npsizes = 0;
    .          .          .              .          .          .              .          .          .           
    1 ( 0.00%) 0          0              0          0          0              1 ( 0.00%) 0          0           	int index = 0;
    .          .          .              .          .          .              .          .          .           
    1 ( 0.00%) 0          0              0          0          0              1 ( 0.00%) 0          0           	int ndelta = 0;
    2 ( 0.00%) 0          0              1 ( 0.00%) 0          0              1 ( 0.00%) 0          0           	int lg_base = lg_tiny_min;
    2 ( 0.00%) 0          0              1 ( 0.00%) 0          0              1 ( 0.00%) 0          0           	int lg_delta = lg_base;
    .          .          .              .          .          .              .          .          .           
    .          .          .              .          .          .              .          .          .           	/* Outputs that we update as we go. */
    1 ( 0.00%) 0          0              0          0          0              1 ( 0.00%) 0          0           	size_t lookup_maxclass = 0;
    1 ( 0.00%) 0          0              0          0          0              1 ( 0.00%) 0          0           	size_t small_maxclass = 0;
    1 ( 0.00%) 0          0              0          0          0              1 ( 0.00%) 0          0           	int lg_large_minclass = 0;
    1 ( 0.00%) 1 ( 0.00%) 1 ( 0.01%)     0          0          0              1 ( 0.00%) 0          0           	size_t large_maxclass = 0;
    .          .          .              .          .          .              .          .          .           
    .          .          .              .          .          .              .          .          .           	/* Tiny size classes. */
    7 ( 0.00%) 1 ( 0.00%) 1 ( 0.01%)     4 ( 0.00%) 0          0              0          0          0           	while (lg_base < lg_quantum) {
   11 ( 0.00%) 0          0              2 ( 0.00%) 0          0              1 ( 0.00%) 0          0           		sc_t *sc = &sc_data->sc[index];
   13 ( 0.00%) 1 ( 0.00%) 1 ( 0.01%)     8 ( 0.00%) 0          0              3 ( 0.00%) 1 ( 0.02%) 0           		size_class(sc, lg_max_lookup, lg_page, lg_ngroup, index,
    .          .          .              .          .          .              .          .          .           		    lg_base, lg_delta, ndelta);
    4 ( 0.00%) 0          0              2 ( 0.00%) 0          0              0          0          0           		if (sc->lg_delta_lookup != 0) {
    3 ( 0.00%) 0          0              1 ( 0.00%) 0          0              1 ( 0.00%) 0          0           			nlbins = index + 1;
    .          .          .              .          .          .              .          .          .           		}
    4 ( 0.00%) 0          0              2 ( 0.00%) 0          0              0          0          0           		if (sc->psz) {
    .          .          .              .          .          .              .          .          .           			npsizes++;
    .          .          .              .          .          .              .          .          .           		}
    4 ( 0.00%) 0          0              2 ( 0.00%) 0          0              0          0          0           		if (sc->bin) {
    1 ( 0.00%) 0          0              1 ( 0.00%) 0          0              0          0          0           			nbins++;
    .          .          .              .          .          .              .          .          .           		}
    1 ( 0.00%) 0          0              1 ( 0.00%) 0          0              0          0          0           		ntiny++;
    .          .          .              .          .          .              .          .          .           		/* Final written value is correct. */
    2 ( 0.00%) 0          0              1 ( 0.00%) 0          0              1 ( 0.00%) 0          0           		lg_tiny_maxclass = lg_base;
    1 ( 0.00%) 0          0              1 ( 0.00%) 0          0              0          0          0           		index++;
    2 ( 0.00%) 0          0              1 ( 0.00%) 0          0              1 ( 0.00%) 0          0           		lg_delta = lg_base;
    1 ( 0.00%) 0          0              1 ( 0.00%) 0          0              0          0          0           		lg_base++;
    .          .          .              .          .          .              .          .          .           	}
    .          .          .              .          .          .              .          .          .           
    .          .          .              .          .          .              .          .          .           	/* First non-tiny (pseudo) group. */
    2 ( 0.00%) 1 ( 0.00%) 1 ( 0.01%)     1 ( 0.00%) 0          0              0          0          0           	if (ntiny != 0) {
   11 ( 0.00%) 0          0              2 ( 0.00%) 0          0              1 ( 0.00%) 0          0           		sc_t *sc = &sc_data->sc[index];
    .          .          .              .          .          .              .          .          .           		/*
    .          .          .              .          .          .              .          .          .           		 * See the note in sc.h; the first non-tiny size class has an
    .          .          .              .          .          .              .          .          .           		 * unusual encoding.
    .          .          .              .          .          .              .          .          .           		 */
    1 ( 0.00%) 0          0              1 ( 0.00%) 0          0              0          0          0           		lg_base--;
    1 ( 0.00%) 0          0              0          0          0              1 ( 0.00%) 0          0           		ndelta = 1;
   13 ( 0.00%) 1 ( 0.00%) 1 ( 0.01%)     8 ( 0.00%) 0          0              3 ( 0.00%) 0          0           		size_class(sc, lg_max_lookup, lg_page, lg_ngroup, index,
    .          .          .              .          .          .              .          .          .           		    lg_base, lg_delta, ndelta);
    1 ( 0.00%) 0          0              1 ( 0.00%) 0          0              0          0          0           		index++;
    1 ( 0.00%) 0          0              1 ( 0.00%) 0          0              0          0          0           		lg_base++;
    1 ( 0.00%) 0          0              1 ( 0.00%) 0          0              0          0          0           		lg_delta++;
    4 ( 0.00%) 1 ( 0.00%) 1 ( 0.01%)     2 ( 0.00%) 0          0              0          0          0           		if (sc->psz) {
    .          .          .              .          .          .              .          .          .           			npsizes++;
    .          .          .              .          .          .              .          .          .           		}
    4 ( 0.00%) 0          0              2 ( 0.00%) 0          0              0          0          0           		if (sc->bin) {
    1 ( 0.00%) 0          0              1 ( 0.00%) 0          0              0          0          0           			nbins++;
    .          .          .              .          .          .              .          .          .           		}
    .          .          .              .          .          .              .          .          .           	}
   13 ( 0.00%) 1 ( 0.00%) 1 ( 0.01%)     8 ( 0.00%) 0          0              0          0          0           	while (ndelta < ngroup) {
   33 ( 0.00%) 1 ( 0.00%) 1 ( 0.01%)     6 ( 0.00%) 0          0              3 ( 0.00%) 0          0           		sc_t *sc = &sc_data->sc[index];
   39 ( 0.00%) 0          0             24 ( 0.00%) 0          0              9 ( 0.00%) 0          0           		size_class(sc, lg_max_lookup, lg_page, lg_ngroup, index,
    .          .          .              .          .          .              .          .          .           		    lg_base, lg_delta, ndelta);
    3 ( 0.00%) 0          0              3 ( 0.00%) 0          0              0          0          0           		index++;
    3 ( 0.00%) 0          0              3 ( 0.00%) 0          0              0          0          0           		ndelta++;
   12 ( 0.00%) 0          0              6 ( 0.00%) 0          0              0          0          0           		if (sc->psz) {
    .          .          .              .          .          .              .          .          .           			npsizes++;
    .          .          .              .          .          .              .          .          .           		}
   12 ( 0.00%) 0          0              6 ( 0.00%) 0          0              0          0          0           		if (sc->bin) {
    3 ( 0.00%) 0          0              3 ( 0.00%) 0          0              0          0          0           			nbins++;
    .          .          .              .          .          .              .          .          .           		}
    .          .          .              .          .          .              .          .          .           	}
    .          .          .              .          .          .              .          .          .           
    .          .          .              .          .          .              .          .          .           	/* All remaining groups. */
    2 ( 0.00%) 0          0              2 ( 0.00%) 0          0              0          0          0           	lg_base = lg_base + lg_ngroup;
  233 ( 0.00%) 1 ( 0.00%) 1 ( 0.01%)   116 ( 0.00%) 0          0              0          0          0           	while (lg_base < ptr_bits - 1) {
   57 ( 0.00%) 1 ( 0.00%) 1 ( 0.01%)     0          0          0             57 ( 0.00%) 0          0           		ndelta = 1;
    .          .          .              .          .          .              .          .          .           		int ndelta_limit;
  228 ( 0.00%) 0          0            114 ( 0.00%) 0          0              0          0          0           		if (lg_base == ptr_bits - 2) {
    4 ( 0.00%) 0          0              1 ( 0.00%) 0          0              1 ( 0.00%) 0          0           			ndelta_limit = ngroup - 1;
    .          .          .              .          .          .              .          .          .           		} else {
  112 ( 0.00%) 0          0             56 ( 0.00%) 0          0             56 ( 0.00%) 0          0           			ndelta_limit = ngroup;
    .          .          .              .          .          .              .          .          .           		}
  908 ( 0.01%) 0          0            568 ( 0.02%) 0          0              0          0          0           		while (ndelta <= ndelta_limit) {
2,497 ( 0.03%) 1 ( 0.00%) 1 ( 0.01%)   454 ( 0.02%) 0          0            227 ( 0.01%) 0          0           			sc_t *sc = &sc_data->sc[index];
2,951 ( 0.03%) 0          0          1,816 ( 0.07%) 0          0            681 ( 0.02%) 0          0           			size_class(sc, lg_max_lookup, lg_page, lg_ngroup, index,
    .          .          .              .          .          .              .          .          .           			    lg_base, lg_delta, ndelta);
  908 ( 0.01%) 1 ( 0.00%) 1 ( 0.01%)   454 ( 0.02%) 0          0              0          0          0           			if (sc->lg_delta_lookup != 0) {
   72 ( 0.00%) 0          0             24 ( 0.00%) 0          0             24 ( 0.00%) 0          0           				nlbins = index + 1;
    .          .          .              .          .          .              .          .          .           				/* Final written value is correct. */
  168 ( 0.00%) 0          0             24 ( 0.00%) 0          0             24 ( 0.00%) 0          0           				lookup_maxclass = (ZU(1) << lg_base)
  144 ( 0.00%) 0          0             48 ( 0.00%) 0          0              0          0          0           				    + (ZU(ndelta) << lg_delta);
    .          .          .              .          .          .              .          .          .           			}
  908 ( 0.01%) 1 ( 0.00%) 1 ( 0.01%)   454 ( 0.02%) 0          0              0          0          0           			if (sc->psz) {
  199 ( 0.00%) 0          0            199 ( 0.01%) 0          0              0          0          0           				npsizes++;
    .          .          .              .          .          .              .          .          .           			}
  908 ( 0.01%) 0          0            454 ( 0.02%) 0          0              0          0          0           			if (sc->bin) {
   31 ( 0.00%) 0          0             31 ( 0.00%) 0          0              0          0          0           				nbins++;
    .          .          .              .          .          .              .          .          .           				/* Final written value is correct. */
  217 ( 0.00%) 1 ( 0.00%) 1 ( 0.01%)    31 ( 0.00%) 0          0             31 ( 0.00%) 0          0           				small_maxclass = (ZU(1) << lg_base)
  186 ( 0.00%) 0          0             62 ( 0.00%) 0          0              0          0          0           				    + (ZU(ndelta) << lg_delta);
   62 ( 0.00%) 0          0             31 ( 0.00%) 0          0              0          0          0           				if (lg_ngroup > 0) {
  124 ( 0.00%) 0          0             31 ( 0.00%) 0          0             31 ( 0.00%) 0          0           					lg_large_minclass = lg_base + 1;
    .          .          .              .          .          .              .          .          .           				} else {
    .          .          .              .          .          .              .          .          .           					lg_large_minclass = lg_base + 2;
    .          .          .              .          .          .              .          .          .           				}
    .          .          .              .          .          .              .          .          .           			}
1,589 ( 0.02%) 0          0            227 ( 0.01%) 0          0            227 ( 0.01%) 0          0           			large_maxclass = (ZU(1) << lg_base)
1,362 ( 0.01%) 0          0            454 ( 0.02%) 0          0              0          0          0           			    + (ZU(ndelta) << lg_delta);
  227 ( 0.00%) 0          0            227 ( 0.01%) 0          0              0          0          0           			index++;
  227 ( 0.00%) 0          0            227 ( 0.01%) 0          0              0          0          0           			ndelta++;
    .          .          .              .          .          .              .          .          .           		}
   57 ( 0.00%) 0          0             57 ( 0.00%) 0          0              0          0          0           		lg_base++;
   57 ( 0.00%) 0          0             57 ( 0.00%) 0          0              0          0          0           		lg_delta++;
    .          .          .              .          .          .              .          .          .           	}
    .          .          .              .          .          .              .          .          .           	/* Additional outputs. */
    2 ( 0.00%) 0          0              1 ( 0.00%) 0          0              1 ( 0.00%) 0          0           	int nsizes = index;
    5 ( 0.00%) 1 ( 0.00%) 1 ( 0.01%)     1 ( 0.00%) 0          0              2 ( 0.00%) 0          0           	unsigned lg_ceil_nsizes = lg_ceil(nsizes);
    .          .          .              .          .          .              .          .          .           
    .          .          .              .          .          .              .          .          .           	/* Fill in the output data. */
    3 ( 0.00%) 0          0              2 ( 0.00%) 0          0              1 ( 0.00%) 0          0           	sc_data->ntiny = ntiny;
    3 ( 0.00%) 0          0              2 ( 0.00%) 0          0              1 ( 0.00%) 0          0           	sc_data->nlbins = nlbins;
    3 ( 0.00%) 0          0              2 ( 0.00%) 0          0              1 ( 0.00%) 0          0           	sc_data->nbins = nbins;
    3 ( 0.00%) 0          0              2 ( 0.00%) 0          0              1 ( 0.00%) 0          0           	sc_data->nsizes = nsizes;
    3 ( 0.00%) 1 ( 0.00%) 1 ( 0.01%)     2 ( 0.00%) 0          0              1 ( 0.00%) 0          0           	sc_data->lg_ceil_nsizes = lg_ceil_nsizes;
    3 ( 0.00%) 0          0              2 ( 0.00%) 0          0              1 ( 0.00%) 0          0           	sc_data->npsizes = npsizes;
    3 ( 0.00%) 0          0              2 ( 0.00%) 0          0              1 ( 0.00%) 0          0           	sc_data->lg_tiny_maxclass = lg_tiny_maxclass;
    3 ( 0.00%) 0          0              2 ( 0.00%) 0          0              1 ( 0.00%) 0          0           	sc_data->lookup_maxclass = lookup_maxclass;
    3 ( 0.00%) 0          0              2 ( 0.00%) 0          0              1 ( 0.00%) 0          0           	sc_data->small_maxclass = small_maxclass;
    3 ( 0.00%) 1 ( 0.00%) 1 ( 0.01%)     2 ( 0.00%) 0          0              1 ( 0.00%) 0          0           	sc_data->lg_large_minclass = lg_large_minclass;
    6 ( 0.00%) 0          0              2 ( 0.00%) 0          0              1 ( 0.00%) 0          0           	sc_data->large_minclass = (ZU(1) << lg_large_minclass);
    3 ( 0.00%) 0          0              2 ( 0.00%) 0          0              1 ( 0.00%) 0          0           	sc_data->large_maxclass = large_maxclass;
    .          .          .              .          .          .              .          .          .           
    .          .          .              .          .          .              .          .          .           	/*
    .          .          .              .          .          .              .          .          .           	 * We compute these values in two ways:
    .          .          .              .          .          .              .          .          .           	 *   - Incrementally, as above.
    .          .          .              .          .          .              .          .          .           	 *   - In macros, in sc.h.
    .          .          .              .          .          .              .          .          .           	 * The computation is easier when done incrementally, but putting it in
    .          .          .              .          .          .              .          .          .           	 * a constant makes it available to the fast paths without having to
    .          .          .              .          .          .              .          .          .           	 * touch the extra global cacheline.  We assert, however, that the two
    .          .          .              .          .          .              .          .          .           	 * computations are equivalent.
    .          .          .              .          .          .              .          .          .           	 */
    4 ( 0.00%) 0          0              0          0          0              0          0          0           	assert(sc_data->npsizes == SC_NPSIZES);
    4 ( 0.00%) 1 ( 0.00%) 1 ( 0.01%)     0          0          0              0          0          0           	assert(sc_data->lg_tiny_maxclass == SC_LG_TINY_MAXCLASS);
    4 ( 0.00%) 1 ( 0.00%) 1 ( 0.01%)     0          0          0              0          0          0           	assert(sc_data->small_maxclass == SC_SMALL_MAXCLASS);
    4 ( 0.00%) 1 ( 0.00%) 1 ( 0.01%)     0          0          0              0          0          0           	assert(sc_data->large_minclass == SC_LARGE_MINCLASS);
    4 ( 0.00%) 1 ( 0.00%) 1 ( 0.01%)     0          0          0              0          0          0           	assert(sc_data->lg_large_minclass == SC_LG_LARGE_MINCLASS);
    4 ( 0.00%) 1 ( 0.00%) 1 ( 0.01%)     0          0          0              0          0          0           	assert(sc_data->large_maxclass == SC_LARGE_MAXCLASS);
    .          .          .              .          .          .              .          .          .           
    .          .          .              .          .          .              .          .          .           	/*
    .          .          .              .          .          .              .          .          .           	 * In the allocation fastpath, we want to assume that we can
    .          .          .              .          .          .              .          .          .           	 * unconditionally subtract the requested allocation size from
    .          .          .              .          .          .              .          .          .           	 * a ssize_t, and detect passing through 0 correctly.  This
    .          .          .              .          .          .              .          .          .           	 * results in optimal generated code.  For this to work, the
    .          .          .              .          .          .              .          .          .           	 * maximum allocation size must be less than SSIZE_MAX.
    .          .          .              .          .          .              .          .          .           	 */
    .          .          .              .          .          .              .          .          .           	assert(SC_LARGE_MAXCLASS < SSIZE_MAX);
    3 ( 0.00%) 0          0              2 ( 0.00%) 0          0              0          0          0           }
    .          .          .              .          .          .              .          .          .           
    .          .          .              .          .          .              .          .          .           void
    5 ( 0.00%) 1 ( 0.00%) 1 ( 0.01%)     0          0          0              2 ( 0.00%) 0          0           sc_data_init(sc_data_t *sc_data) {
   11 ( 0.00%) 1 ( 0.00%) 1 ( 0.01%)     1 ( 0.00%) 0          0              2 ( 0.00%) 1 ( 0.02%) 1 ( 0.02%)  	size_classes(sc_data, LG_SIZEOF_PTR, LG_QUANTUM, SC_LG_TINY_MIN,
    .          .          .              .          .          .              .          .          .           	    SC_LG_MAX_LOOKUP, LG_PAGE, SC_LG_NGROUP);
    .          .          .              .          .          .              .          .          .           
    2 ( 0.00%) 0          0              1 ( 0.00%) 0          0              1 ( 0.00%) 0          0           	sc_data->initialized = true;
    3 ( 0.00%) 0          0              2 ( 0.00%) 0          0              0          0          0           }
    .          .          .              .          .          .              .          .          .           
    .          .          .              .          .          .              .          .          .           static void
    .          .          .              .          .          .              .          .          .           sc_data_update_sc_slab_size(sc_t *sc, size_t reg_size, size_t pgs_guess) {
    .          .          .              .          .          .              .          .          .           	size_t min_pgs = reg_size / PAGE;
    .          .          .              .          .          .              .          .          .           	if (reg_size % PAGE != 0) {
    .          .          .              .          .          .              .          .          .           		min_pgs++;
    .          .          .              .          .          .              .          .          .           	}
    .          .          .              .          .          .              .          .          .           	/*
-- line 269 ----------------------------------------
-- line 296 ----------------------------------------
    .          .          .              .          .          .              .          .          .           		    sc->ndelta);
    .          .          .              .          .          .              .          .          .           		if (begin <= reg_size && reg_size <= end) {
    .          .          .              .          .          .              .          .          .           			sc_data_update_sc_slab_size(sc, reg_size, pgs);
    .          .          .              .          .          .              .          .          .           		}
    .          .          .              .          .          .              .          .          .           	}
    .          .          .              .          .          .              .          .          .           }
    .          .          .              .          .          .              .          .          .           
    .          .          .              .          .          .              .          .          .           void
    5 ( 0.00%) 2 ( 0.00%) 2 ( 0.03%)     0          0          0              2 ( 0.00%) 0          0           sc_boot(sc_data_t *data) {
    3 ( 0.00%) 0          0              1 ( 0.00%) 0          0              1 ( 0.00%) 0          0           	sc_data_init(data);
    3 ( 0.00%) 0          0              2 ( 0.00%) 0          0              0          0          0           }

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/ashy5000/.cargo/registry/src/index.crates.io-6f17d22bba15001f/smartstring-1.0.1/src/boxed.rs
--------------------------------------------------------------------------------
Ir              I1mr        ILmr       Dr              D1mr         DLmr       Dw              D1mw       DLmw       

-- line 27 ----------------------------------------
     .           .          .               .            .          .               .          .          .               ptr: NonNull<u8>,
     .           .          .               .            .          .               .          .          .           }
     .           .          .               .            .          .               .          .          .           
     .           .          .               .            .          .               .          .          .           /// Checks if a pointer is aligned to an even address (good)
     .           .          .               .            .          .               .          .          .           /// or an odd address (either actually an InlineString or very, very bad).
     .           .          .               .            .          .               .          .          .           ///
     .           .          .               .            .          .               .          .          .           /// Returns `true` if aligned to an odd address, `false` if even. The sense of
     .           .          .               .            .          .               .          .          .           /// the boolean is "does this look like an InlineString? true/false"
16,772 ( 0.18%) 32 ( 0.02%) 1 ( 0.01%)      0            0          0          16,772 ( 0.53%) 0          0           fn check_alignment(ptr: *const u8) -> bool {
33,544 ( 0.35%)  0          0           8,386 ( 0.34%)   1 ( 0.02%) 0           8,386 ( 0.27%) 0          0               ptr.align_offset(2) > 0
33,544 ( 0.35%)  0          0          16,772 ( 0.69%)   0          0               0          0          0           }
     .           .          .               .            .          .               .          .          .           
     .           .          .               .            .          .               .          .          .           impl GenericString for BoxedString {
   292 ( 0.00%)  7 ( 0.00%) 1 ( 0.01%)      0            0          0             219 ( 0.01%) 0          0               fn set_size(&mut self, size: usize) {
    73 ( 0.00%)  0          0               0            0          0              73 ( 0.00%) 0          0                   self.len = size;
   219 ( 0.00%)  0          0             146 ( 0.01%)   0          0               0          0          0                   debug_assert!(self.len <= self.cap);
   146 ( 0.00%)  0          0              73 ( 0.00%)   0          0               0          0          0               }
     .           .          .               .            .          .               .          .          .           
   172 ( 0.00%) 10 ( 0.01%) 1 ( 0.01%)      0            0          0              86 ( 0.00%) 0          0               fn as_mut_capacity_slice(&mut self) -> &mut [u8] {
     .           .          .               .            .          .               .          .          .                   #[allow(unsafe_code)]
     .           .          .               .            .          .               .          .          .                   unsafe {
   774 ( 0.01%)  0          0             172 ( 0.01%)   0          0             344 ( 0.01%) 0          0                       core::slice::from_raw_parts_mut(self.ptr.as_ptr(), self.capacity())
     .           .          .               .            .          .               .          .          .                   }
   172 ( 0.00%)  0          0              86 ( 0.00%)   0          0               0          0          0               }
     .           .          .               .            .          .               .          .          .           }
     .           .          .               .            .          .               .          .          .           
     .           .          .               .            .          .               .          .          .           impl BoxedString {
     .           .          .               .            .          .               .          .          .               const MINIMAL_CAPACITY: usize = MAX_INLINE * 2;
     .           .          .               .            .          .               .          .          .           
16,772 ( 0.18%) 32 ( 0.02%) 0               0            0          0           8,386 ( 0.27%) 0          0               pub(crate) fn check_alignment(this: &Self) -> bool {
25,158 ( 0.27%)  0          0           8,386 ( 0.34%) 220 ( 3.81%) 0          16,772 ( 0.53%) 0          0                   check_alignment(this.ptr.as_ptr())
33,544 ( 0.35%)  0          0           8,386 ( 0.34%)   0          0               0          0          0               }
     .           .          .               .            .          .               .          .          .           
   332 ( 0.00%)  1 ( 0.00%) 1 ( 0.01%)      0            0          0             166 ( 0.01%) 0          0               fn layout_for(cap: usize) -> Layout {
     .           .          .               .            .          .               .          .          .                   // Always request memory that is specifically aligned to at least 2, so
     .           .          .               .            .          .               .          .          .                   // the least significant bit is guaranteed to be 0.
 1,328 ( 0.01%) 15 ( 0.01%) 2 ( 0.03%)    332 ( 0.01%)   4 ( 0.07%) 0             996 ( 0.03%) 0          0                   let layout = Layout::array::<u8>(cap)
 1,328 ( 0.01%) 11 ( 0.01%) 1 ( 0.01%)    166 ( 0.01%)   0          0             498 ( 0.02%) 0          0                       .and_then(|layout| layout.align_to(align_of::<u16>()))
     .           .          .               .            .          .               .          .          .                       .unwrap();
     .           .          .               .            .          .               .          .          .                   assert!(
   830 ( 0.01%)  0          0               0            0          0             166 ( 0.01%) 0          0                       layout.size() <= isize::MAX as usize,
     .           .          .               .            .          .               .          .          .                       "allocation too large!"
     .           .          .               .            .          .               .          .          .                   );
   332 ( 0.00%)  0          0             332 ( 0.01%)   0          0               0          0          0                   layout
   332 ( 0.00%)  0          0             166 ( 0.01%)   0          0               0          0          0               }
     .           .          .               .            .          .               .          .          .           
    26 ( 0.00%) 12 ( 0.01%) 1 ( 0.01%)      0            0          0              13 ( 0.00%) 0          0               fn alloc(cap: usize) -> NonNull<u8> {
    91 ( 0.00%)  0          0               0            0          0              65 ( 0.00%) 0          0                   let layout = Self::layout_for(cap);
     .           .          .               .            .          .               .          .          .                   #[allow(unsafe_code)]
   143 ( 0.00%) 13 ( 0.01%) 1 ( 0.01%)     26 ( 0.00%)   0          0              39 ( 0.00%) 0          0                   let ptr = match NonNull::new(unsafe { alloc::alloc::alloc(layout) }) {
    39 ( 0.00%)  0          0              13 ( 0.00%)   0          0              26 ( 0.00%) 0          0                       Some(ptr) => ptr,
     .           .          .               .            .          .               .          .          .                       None => alloc::alloc::handle_alloc_error(layout),
     .           .          .               .            .          .               .          .          .                   };
    52 ( 0.00%) 13 ( 0.01%) 1 ( 0.01%)     13 ( 0.00%)   0          0              13 ( 0.00%) 0          0                   debug_assert!(ptr.as_ptr().align_offset(2) == 0);
     .           .          .               .            .          .               .          .          .                   ptr
    26 ( 0.00%)  0          0              13 ( 0.00%)   0          0               0          0          0               }
     .           .          .               .            .          .               .          .          .           
   560 ( 0.01%)  3 ( 0.00%) 1 ( 0.01%)     70 ( 0.00%)   0          0             350 ( 0.01%) 0          0               fn realloc(&mut self, cap: usize) {
   280 ( 0.00%)  0          0              70 ( 0.00%)   0          0             210 ( 0.01%) 0          0                   let layout = Self::layout_for(cap);
   490 ( 0.01%)  3 ( 0.00%) 1 ( 0.01%)    140 ( 0.01%)   0          0             350 ( 0.01%) 0          0                   let old_layout = Self::layout_for(self.cap);
   280 ( 0.00%)  0          0              70 ( 0.00%)   0          0             210 ( 0.01%) 0          0                   let old_ptr = self.ptr.as_ptr();
     .           .          .               .            .          .               .          .          .                   #[allow(unsafe_code)]
   630 ( 0.01%)  3 ( 0.00%) 1 ( 0.01%)    210 ( 0.01%)   0          0             210 ( 0.01%) 0          0                   let ptr = unsafe { alloc::alloc::realloc(old_ptr, old_layout, layout.size()) };
   700 ( 0.01%)  3 ( 0.00%) 1 ( 0.01%)    140 ( 0.01%)   0          0             210 ( 0.01%) 0          0                   self.ptr = match NonNull::new(ptr) {
   140 ( 0.00%)  0          0              70 ( 0.00%)   0          0              70 ( 0.00%) 0          0                       Some(ptr) => ptr,
     .           .          .               .            .          .               .          .          .                       None => alloc::alloc::handle_alloc_error(layout),
     .           .          .               .            .          .               .          .          .                   };
    70 ( 0.00%)  0          0               0            0          0              70 ( 0.00%) 0          0                   self.cap = cap;
   420 ( 0.00%)  3 ( 0.00%) 1 ( 0.01%)    140 ( 0.01%)   0          0             140 ( 0.00%) 0          0                   debug_assert!(self.ptr.as_ptr().align_offset(2) == 0);
   140 ( 0.00%)  0          0              70 ( 0.00%)   0          0               0          0          0               }
     .           .          .               .            .          .               .          .          .           
   350 ( 0.00%)  3 ( 0.00%) 1 ( 0.01%)      0            0          0             280 ( 0.01%) 0          0               pub(crate) fn ensure_capacity(&mut self, target_cap: usize) {
   140 ( 0.00%)  0          0              70 ( 0.00%)   0          0              70 ( 0.00%) 0          0                   let mut cap = self.cap;
   146 ( 0.00%)  0          0              72 ( 0.00%)   0          0               0          0          0                   while cap < target_cap {
    14 ( 0.00%)  0          0               2 ( 0.00%)   0          0               4 ( 0.00%) 0          0                       cap *= 2;
     .           .          .               .            .          .               .          .          .                   }
   140 ( 0.00%)  0          0              70 ( 0.00%)   0          0              70 ( 0.00%) 0          0                   self.realloc(cap)
   140 ( 0.00%) 70 ( 0.05%) 1 ( 0.01%)     70 ( 0.00%)   0          0               0          0          0               }
     .           .          .               .            .          .               .          .          .           
    91 ( 0.00%) 10 ( 0.01%) 1 ( 0.01%)     13 ( 0.00%)   0          0              52 ( 0.00%) 0          0               pub(crate) fn new(cap: usize) -> Self {
    65 ( 0.00%)  0          0              13 ( 0.00%)   0          0              39 ( 0.00%) 0          0                   let cap = cap.max(Self::MINIMAL_CAPACITY);
    39 ( 0.00%)  0          0               0            0          0              39 ( 0.00%) 0          0                   Self {
     .           .          .               .            .          .               .          .          .                       cap,
     .           .          .               .            .          .               .          .          .                       len: 0,
    65 ( 0.00%)  0          0              39 ( 0.00%)   0          0              13 ( 0.00%) 0          0                       ptr: Self::alloc(cap),
     .           .          .               .            .          .               .          .          .                   }
    26 ( 0.00%)  0          0              13 ( 0.00%)   0          0               0          0          0               }
     .           .          .               .            .          .               .          .          .           
   117 ( 0.00%) 26 ( 0.02%) 2 ( 0.03%)      0            0          0              91 ( 0.00%) 0          0               pub(crate) fn from_str(cap: usize, src: &str) -> Self {
    39 ( 0.00%)  0          0              26 ( 0.00%)   0          0              13 ( 0.00%) 0          0                   let mut out = Self::new(cap);
    52 ( 0.00%) 13 ( 0.01%) 1 ( 0.01%)      0            0          0              39 ( 0.00%) 0          0                   out.len = src.len();
   169 ( 0.00%) 26 ( 0.02%) 2 ( 0.03%)      0            0          0              78 ( 0.00%) 0          0                   out.as_mut_capacity_slice()[..src.len()].copy_from_slice(src.as_bytes());
    78 ( 0.00%)  0          0              39 ( 0.00%)   0          0              39 ( 0.00%) 0          0                   out
    26 ( 0.00%)  0          0              13 ( 0.00%)   0          0               0          0          0               }
     .           .          .               .            .          .               .          .          .           
    92 ( 0.00%) 80 ( 0.06%) 1 ( 0.01%)      0            0          0              92 ( 0.00%) 0          0               pub(crate) fn capacity(&self) -> usize {
    92 ( 0.00%)  0          0              92 ( 0.00%)   0          0               0          0          0                   self.cap
    92 ( 0.00%)  0          0              92 ( 0.00%)   0          0               0          0          0               }
     .           .          .               .            .          .               .          .          .           
     .           .          .               .            .          .               .          .          .               pub(crate) fn shrink_to_fit(&mut self) {
     .           .          .               .            .          .               .          .          .                   self.realloc(self.len);
     .           .          .               .            .          .               .          .          .               }
     .           .          .               .            .          .               .          .          .           }
     .           .          .               .            .          .               .          .          .           
     .           .          .               .            .          .               .          .          .           impl Drop for BoxedString {
    26 ( 0.00%)  5 ( 0.00%) 0               0            0          0              13 ( 0.00%) 0          0               fn drop(&mut self) {
     .           .          .               .            .          .               .          .          .                   #[allow(unsafe_code)]
     .           .          .               .            .          .               .          .          .                   unsafe {
   104 ( 0.00%)  0          0              39 ( 0.00%)   3 ( 0.05%) 0              52 ( 0.00%) 0          0                       alloc::alloc::dealloc(self.ptr.as_ptr(), Self::layout_for(self.cap))
     .           .          .               .            .          .               .          .          .                   }
    26 ( 0.00%)  0          0              13 ( 0.00%)   0          0               0          0          0               }
     .           .          .               .            .          .               .          .          .           }
     .           .          .               .            .          .               .          .          .           
     .           .          .               .            .          .               .          .          .           impl Clone for BoxedString {
    42 ( 0.00%) 11 ( 0.01%) 2 ( 0.03%)      6 ( 0.00%)   0          0              24 ( 0.00%) 0          0               fn clone(&self) -> Self {
    66 ( 0.00%)  0          0              48 ( 0.00%)   2 ( 0.03%) 0              30 ( 0.00%) 0          0                   Self::from_str(self.capacity(), self.deref())
    12 ( 0.00%)  0          0               6 ( 0.00%)   0          0               0          0          0               }
     .           .          .               .            .          .               .          .          .           }
     .           .          .               .            .          .               .          .          .           
     .           .          .               .            .          .               .          .          .           impl Deref for BoxedString {
     .           .          .               .            .          .               .          .          .               type Target = str;
     .           .          .               .            .          .               .          .          .           
   468 ( 0.00%)  6 ( 0.00%) 1 ( 0.01%)      0            0          0             156 ( 0.00%) 0          0               fn deref(&self) -> &Self::Target {
     .           .          .               .            .          .               .          .          .                   #[allow(unsafe_code)]
     .           .          .               .            .          .               .          .          .                   unsafe {
 1,248 ( 0.01%)  0          0             312 ( 0.01%)   0          0             468 ( 0.01%) 0          0                       core::str::from_utf8_unchecked(core::slice::from_raw_parts(self.ptr.as_ptr(), self.len))
     .           .          .               .            .          .               .          .          .                   }
   312 ( 0.00%)  6 ( 0.00%) 0             156 ( 0.01%)   0          0               0          0          0               }
     .           .          .               .            .          .               .          .          .           }
     .           .          .               .            .          .               .          .          .           
     .           .          .               .            .          .               .          .          .           impl DerefMut for BoxedString {
     .           .          .               .            .          .               .          .          .               fn deref_mut(&mut self) -> &mut Self::Target {
     .           .          .               .            .          .               .          .          .                   #[allow(unsafe_code)]
     .           .          .               .            .          .               .          .          .                   unsafe {
     .           .          .               .            .          .               .          .          .                       core::str::from_utf8_unchecked_mut(core::slice::from_raw_parts_mut(
     .           .          .               .            .          .               .          .          .                           self.ptr.as_ptr(),
-- line 162 ----------------------------------------
-- line 163 ----------------------------------------
     .           .          .               .            .          .               .          .          .                           self.len,
     .           .          .               .            .          .               .          .          .                       ))
     .           .          .               .            .          .               .          .          .                   }
     .           .          .               .            .          .               .          .          .               }
     .           .          .               .            .          .               .          .          .           }
     .           .          .               .            .          .               .          .          .           
     .           .          .               .            .          .               .          .          .           impl From<String> for BoxedString {
     .           .          .               .            .          .               .          .          .               #[allow(unsafe_code, unused_mut)]
    24 ( 0.00%)  1 ( 0.00%) 1 ( 0.01%)      4 ( 0.00%)   0          0              12 ( 0.00%) 0          0               fn from(mut s: String) -> Self {
    24 ( 0.00%)  0          0               0            0          0               8 ( 0.00%) 0          0                   if s.is_empty() {
     .           .          .               .            .          .               .          .          .                       Self::new(s.capacity())
     .           .          .               .            .          .               .          .          .                   } else {
     .           .          .               .            .          .               .          .          .                       #[cfg(has_allocator)]
     .           .          .               .            .          .               .          .          .                       {
     .           .          .               .            .          .               .          .          .                           // TODO: Use String::into_raw_parts when stabilised, meanwhile let's get unsafe
     .           .          .               .            .          .               .          .          .                           let len = s.len();
     .           .          .               .            .          .               .          .          .                           let cap = s.capacity();
     .           .          .               .            .          .               .          .          .                           #[allow(unsafe_code)]
-- line 180 ----------------------------------------
-- line 192 ----------------------------------------
     .           .          .               .            .          .               .          .          .                                   len,
     .           .          .               .            .          .               .          .          .                                   ptr: aligned_ptr.cast(),
     .           .          .               .            .          .               .          .          .                               }
     .           .          .               .            .          .               .          .          .                           } else {
     .           .          .               .            .          .               .          .          .                               Self::from_str(cap, &s)
     .           .          .               .            .          .               .          .          .                           }
     .           .          .               .            .          .               .          .          .                       }
     .           .          .               .            .          .               .          .          .                       #[cfg(not(has_allocator))]
    44 ( 0.00%)  0          0               0            0          0              24 ( 0.00%) 0          0                       Self::from_str(s.capacity(), &s)
     .           .          .               .            .          .               .          .          .                   }
    16 ( 0.00%)  0          0              12 ( 0.00%)   2 ( 0.03%) 0               4 ( 0.00%) 0          0               }
     .           .          .               .            .          .               .          .          .           }
     .           .          .               .            .          .               .          .          .           
     .           .          .               .            .          .               .          .          .           impl From<BoxedString> for String {
     .           .          .               .            .          .               .          .          .               #[allow(unsafe_code)]
     .           .          .               .            .          .               .          .          .               fn from(s: BoxedString) -> Self {
     .           .          .               .            .          .               .          .          .                   #[cfg(has_allocator)]
     .           .          .               .            .          .               .          .          .                   {
     .           .          .               .            .          .               .          .          .                       let ptr = s.ptr;
-- line 210 ----------------------------------------

   693 ( 0.01%) 12 ( 0.01%) 3 ( 0.04%)    615 ( 0.03%)   0          0              78 ( 0.00%) 0          0           <counts for unidentified lines in /home/ashy5000/.cargo/registry/src/index.crates.io-6f17d22bba15001f/smartstring-1.0.1/src/boxed.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/ashy5000/dev/cryptocurrency/contracts/target/debug/build/tikv-jemalloc-sys-7365f40ecb99e085/out/build/include/jemalloc/internal/rtree.h
--------------------------------------------------------------------------------
Ir             I1mr         ILmr        Dr             D1mr       DLmr       Dw             D1mw        DLmw        

-- line 131 ----------------------------------------
    .            .           .              .          .          .              .           .           .           
    .            .           .              .          .          .              .           .           .           bool rtree_new(rtree_t *rtree, base_t *base, bool zeroed);
    .            .           .              .          .          .              .           .           .           
    .            .           .              .          .          .              .           .           .           rtree_leaf_elm_t *rtree_leaf_elm_lookup_hard(tsdn_t *tsdn, rtree_t *rtree,
    .            .           .              .          .          .              .           .           .               rtree_ctx_t *rtree_ctx, uintptr_t key, bool dependent, bool init_missing);
    .            .           .              .          .          .              .           .           .           
    .            .           .              .          .          .              .           .           .           JEMALLOC_ALWAYS_INLINE unsigned
    .            .           .              .          .          .              .           .           .           rtree_leaf_maskbits(void) {
1,090 ( 0.01%) 165 ( 0.11%)  7 ( 0.10%)     0          0          0          1,090 ( 0.03%) 14 ( 0.26%) 10 ( 0.24%)  	unsigned ptrbits = ZU(1) << (LG_SIZEOF_PTR+3);
3,270 ( 0.03%)  25 ( 0.02%)  3 ( 0.04%)     0          0          0          1,090 ( 0.03%)  3 ( 0.06%)  3 ( 0.07%)  	unsigned cumbits = (rtree_levels[RTREE_HEIGHT-1].cumbits -
1,090 ( 0.01%)  94 ( 0.07%)  3 ( 0.04%)     0          0          0              0           0           0           	    rtree_levels[RTREE_HEIGHT-1].bits);
2,180 ( 0.02%)  56 ( 0.04%)  3 ( 0.04%) 2,180 ( 0.09%) 0          0              0           0           0           	return ptrbits - cumbits;
    .            .           .              .          .          .              .           .           .           }
    .            .           .              .          .          .              .           .           .           
    .            .           .              .          .          .              .           .           .           JEMALLOC_ALWAYS_INLINE uintptr_t
    .            .           .              .          .          .              .           .           .           rtree_leafkey(uintptr_t key) {
3,198 ( 0.03%) 215 ( 0.15%)  5 ( 0.07%)     0          0          0            533 ( 0.02%)  0           0           	uintptr_t mask = ~((ZU(1) << rtree_leaf_maskbits()) - 1);
1,066 ( 0.01%)  63 ( 0.04%)  3 ( 0.04%) 1,066 ( 0.04%) 0          0              0           0           0           	return (key & mask);
    .            .           .              .          .          .              .           .           .           }
    .            .           .              .          .          .              .           .           .           
    .            .           .              .          .          .              .           .           .           JEMALLOC_ALWAYS_INLINE size_t
    .            .           .              .          .          .              .           .           .           rtree_cache_direct_map(uintptr_t key) {
2,665 ( 0.03%)  55 ( 0.04%)  2 ( 0.03%)   533 ( 0.02%) 0          0              0           0           0           	return (size_t)((key >> rtree_leaf_maskbits()) &
    .            .           .              .          .          .              .           .           .           	    (RTREE_CTX_NCACHE - 1));
    .            .           .              .          .          .              .           .           .           }
    .            .           .              .          .          .              .           .           .           
    .            .           .              .          .          .              .           .           .           JEMALLOC_ALWAYS_INLINE uintptr_t
    .            .           .              .          .          .              .           .           .           rtree_subkey(uintptr_t key, unsigned level) {
  533 ( 0.01%)  34 ( 0.02%)  3 ( 0.04%)     0          0          0            533 ( 0.02%)  0           0           	unsigned ptrbits = ZU(1) << (LG_SIZEOF_PTR+3);
2,665 ( 0.03%) 213 ( 0.15%)  5 ( 0.07%) 1,066 ( 0.04%) 6 ( 0.10%) 4 ( 0.11%)   533 ( 0.02%)  0           0           	unsigned cumbits = rtree_levels[level].cumbits;
1,599 ( 0.02%)  33 ( 0.02%)  2 ( 0.03%) 1,066 ( 0.04%) 0          0            533 ( 0.02%)  1 ( 0.02%)  1 ( 0.02%)  	unsigned shiftbits = ptrbits - cumbits;
2,665 ( 0.03%) 183 ( 0.13%)  8 ( 0.11%) 1,066 ( 0.04%) 0          0            533 ( 0.02%)  6 ( 0.11%)  4 ( 0.10%)  	unsigned maskbits = rtree_levels[level].bits;
3,731 ( 0.04%)  77 ( 0.05%)  4 ( 0.06%)   533 ( 0.02%) 0          0            533 ( 0.02%)  0           0           	uintptr_t mask = (ZU(1) << maskbits) - 1;
3,198 ( 0.03%)  89 ( 0.06%)  4 ( 0.06%) 1,599 ( 0.07%) 0          0              0           0           0           	return ((key >> shiftbits) & mask);
    .            .           .              .          .          .              .           .           .           }
    .            .           .              .          .          .              .           .           .           
    .            .           .              .          .          .              .           .           .           /*
    .            .           .              .          .          .              .           .           .            * Atomic getters.
    .            .           .              .          .          .              .           .           .            *
    .            .           .              .          .          .              .           .           .            * dependent: Reading a value on behalf of a pointer to a valid allocation
    .            .           .              .          .          .              .           .           .            *            is guaranteed to be a clean read even without synchronization,
    .            .           .              .          .          .              .           .           .            *            because the rtree update became visible in memory before the
-- line 172 ----------------------------------------
-- line 174 ----------------------------------------
    .            .           .              .          .          .              .           .           .            * !dependent: An arbitrary read, e.g. on behalf of ivsalloc(), may not be
    .            .           .              .          .          .              .           .           .            *             dependent on a previous rtree write, which means a stale read
    .            .           .              .          .          .              .           .           .            *             could result if synchronization were omitted here.
    .            .           .              .          .          .              .           .           .            */
    .            .           .              .          .          .              .           .           .           #  ifdef RTREE_LEAF_COMPACT
    .            .           .              .          .          .              .           .           .           JEMALLOC_ALWAYS_INLINE uintptr_t
    .            .           .              .          .          .              .           .           .           rtree_leaf_elm_bits_read(tsdn_t *tsdn, rtree_t *rtree,
    .            .           .              .          .          .              .           .           .               rtree_leaf_elm_t *elm, bool dependent) {
1,566 ( 0.02%)  31 ( 0.02%)  2 ( 0.03%)   522 ( 0.02%) 0          0            783 ( 0.02%)  0           0           	return (uintptr_t)atomic_load_p(&elm->le_bits, dependent
  522 ( 0.01%)  65 ( 0.05%)  2 ( 0.03%)   261 ( 0.01%) 0          0              0           0           0           	    ? ATOMIC_RELAXED : ATOMIC_ACQUIRE);
    .            .           .              .          .          .              .           .           .           }
    .            .           .              .          .          .              .           .           .           
    .            .           .              .          .          .              .           .           .           JEMALLOC_ALWAYS_INLINE uintptr_t
    .            .           .              .          .          .              .           .           .           rtree_leaf_elm_bits_encode(rtree_contents_t contents) {
  832 ( 0.01%)   0           0              0          0          0              0           0           0           	assert((uintptr_t)contents.edata % (uintptr_t)EDATA_ALIGNMENT == 0);
1,040 ( 0.01%) 197 ( 0.14%)  7 ( 0.10%)   208 ( 0.01%) 0          0            208 ( 0.01%)  0           0           	uintptr_t edata_bits = (uintptr_t)contents.edata
    .            .           .              .          .          .              .           .           .           	    & (((uintptr_t)1 << LG_VADDR) - 1);
    .            .           .              .          .          .              .           .           .           
  832 ( 0.01%)  32 ( 0.02%)  1 ( 0.01%)   208 ( 0.01%) 0          0            208 ( 0.01%)  0           0           	uintptr_t szind_bits = (uintptr_t)contents.metadata.szind << LG_VADDR;
  624 ( 0.01%)  55 ( 0.04%)  2 ( 0.03%)   208 ( 0.01%) 0          0            208 ( 0.01%)  0           0           	uintptr_t slab_bits = (uintptr_t)contents.metadata.slab;
  832 ( 0.01%)  55 ( 0.04%)  2 ( 0.03%)   208 ( 0.01%) 0          0            208 ( 0.01%)  0           0           	uintptr_t is_head_bits = (uintptr_t)contents.metadata.is_head << 1;
  832 ( 0.01%)   0           0            208 ( 0.01%) 0          0            208 ( 0.01%)  0           0           	uintptr_t state_bits = (uintptr_t)contents.metadata.state <<
    .            .           .              .          .          .              .           .           .           	    RTREE_LEAF_STATE_SHIFT;
1,040 ( 0.01%) 110 ( 0.08%)  4 ( 0.06%)   832 ( 0.03%) 0          0            208 ( 0.01%)  0           0           	uintptr_t metadata_bits = szind_bits | state_bits | is_head_bits |
    .            .           .              .          .          .              .           .           .           	    slab_bits;
  832 ( 0.01%)  32 ( 0.02%)  1 ( 0.01%)     0          0          0              0           0           0           	assert((edata_bits & metadata_bits) == 0);
    .            .           .              .          .          .              .           .           .           
  416 ( 0.00%) 142 ( 0.10%)  5 ( 0.07%)   416 ( 0.02%) 0          0              0           0           0           	return edata_bits | metadata_bits;
    .            .           .              .          .          .              .           .           .           }
    .            .           .              .          .          .              .           .           .           
    .            .           .              .          .          .              .           .           .           JEMALLOC_ALWAYS_INLINE rtree_contents_t
    .            .           .              .          .          .              .           .           .           rtree_leaf_elm_bits_decode(uintptr_t bits) {
    .            .           .              .          .          .              .           .           .           	rtree_contents_t contents;
    .            .           .              .          .          .              .           .           .           	/* Do the easy things first. */
  594 ( 0.01%)   0           0            198 ( 0.01%) 0          0            198 ( 0.01%)  0           0           	contents.metadata.szind = bits >> LG_VADDR;
  990 ( 0.01%)   1 ( 0.00%)  1 ( 0.01%)   198 ( 0.01%) 0          0            198 ( 0.01%)  0           0           	contents.metadata.slab = (bool)(bits & 1);
  990 ( 0.01%)  59 ( 0.04%)  2 ( 0.03%)   198 ( 0.01%) 0          0            198 ( 0.01%)  0           0           	contents.metadata.is_head = (bool)(bits & (1 << 1));
    .            .           .              .          .          .              .           .           .           
  792 ( 0.01%)   0           0            198 ( 0.01%) 0          0            198 ( 0.01%)  0           0           	uintptr_t state_bits = (bits & RTREE_LEAF_STATE_MASK) >>
    .            .           .              .          .          .              .           .           .           	    RTREE_LEAF_STATE_SHIFT;
  792 ( 0.01%)   1 ( 0.00%)  1 ( 0.01%)     0          0          0              0           0           0           	assert(state_bits <= extent_state_max);
  396 ( 0.00%) 130 ( 0.09%)  3 ( 0.04%)   198 ( 0.01%) 0          0            198 ( 0.01%)  0           0           	contents.metadata.state = (extent_state_t)state_bits;
    .            .           .              .          .          .              .           .           .           
  198 ( 0.00%)   0           0              0          0          0            198 ( 0.01%)  0           0           	uintptr_t low_bit_mask = ~((uintptr_t)EDATA_ALIGNMENT - 1);
    .            .           .              .          .          .              .           .           .           #    ifdef __aarch64__
    .            .           .              .          .          .              .           .           .           	/*
    .            .           .              .          .          .              .           .           .           	 * aarch64 doesn't sign extend the highest virtual address bit to set
    .            .           .              .          .          .              .           .           .           	 * the higher ones.  Instead, the high bits get zeroed.
    .            .           .              .          .          .              .           .           .           	 */
    .            .           .              .          .          .              .           .           .           	uintptr_t high_bit_mask = ((uintptr_t)1 << LG_VADDR) - 1;
    .            .           .              .          .          .              .           .           .           	/* Mask off metadata. */
    .            .           .              .          .          .              .           .           .           	uintptr_t mask = high_bit_mask & low_bit_mask;
    .            .           .              .          .          .              .           .           .           	contents.edata = (edata_t *)(bits & mask);
    .            .           .              .          .          .              .           .           .           #    else
    .            .           .              .          .          .              .           .           .           	/* Restore sign-extended high bits, mask metadata bits. */
  594 ( 0.01%)   1 ( 0.00%)  1 ( 0.01%)   198 ( 0.01%) 0          0            198 ( 0.01%)  0           0           	contents.edata = (edata_t *)((uintptr_t)((intptr_t)(bits << RTREE_NHIB)
  396 ( 0.00%) 128 ( 0.09%)  2 ( 0.03%)   198 ( 0.01%) 0          0              0           0           0           	    >> RTREE_NHIB) & low_bit_mask);
    .            .           .              .          .          .              .           .           .           #    endif
  792 ( 0.01%)   0           0              0          0          0              0           0           0           	assert((uintptr_t)contents.edata % (uintptr_t)EDATA_ALIGNMENT == 0);
1,188 ( 0.01%)  63 ( 0.04%)  4 ( 0.06%)   594 ( 0.02%) 0          0            594 ( 0.02%)  0           0           	return contents;
    .            .           .              .          .          .              .           .           .           }
    .            .           .              .          .          .              .           .           .           
    .            .           .              .          .          .              .           .           .           #  endif /* RTREE_LEAF_COMPACT */
    .            .           .              .          .          .              .           .           .           
    .            .           .              .          .          .              .           .           .           JEMALLOC_ALWAYS_INLINE rtree_contents_t
    .            .           .              .          .          .              .           .           .           rtree_leaf_elm_read(tsdn_t *tsdn, rtree_t *rtree, rtree_leaf_elm_t *elm,
    .            .           .              .          .          .              .           .           .               bool dependent) {
    .            .           .              .          .          .              .           .           .           #ifdef RTREE_LEAF_COMPACT
2,376 ( 0.03%)  32 ( 0.02%)  2 ( 0.03%) 1,188 ( 0.05%) 0          0          1,188 ( 0.04%)  4 ( 0.08%)  3 ( 0.07%)  	uintptr_t bits = rtree_leaf_elm_bits_read(tsdn, rtree, elm, dependent);
    .            .           .              .          .          .              .           .           .           	rtree_contents_t contents = rtree_leaf_elm_bits_decode(bits);
1,286 ( 0.01%)  60 ( 0.04%)  2 ( 0.03%)   692 ( 0.03%) 0          0            594 ( 0.02%)  4 ( 0.08%)  4 ( 0.10%)  	return contents;
    .            .           .              .          .          .              .           .           .           #else
    .            .           .              .          .          .              .           .           .           	rtree_contents_t contents;
    .            .           .              .          .          .              .           .           .           	unsigned metadata_bits = atomic_load_u(&elm->le_metadata, dependent
    .            .           .              .          .          .              .           .           .           	    ? ATOMIC_RELAXED : ATOMIC_ACQUIRE);
    .            .           .              .          .          .              .           .           .           	contents.metadata.slab = (bool)(metadata_bits & 1);
    .            .           .              .          .          .              .           .           .           	contents.metadata.is_head = (bool)(metadata_bits & (1 << 1));
    .            .           .              .          .          .              .           .           .           
    .            .           .              .          .          .              .           .           .           	uintptr_t state_bits = (metadata_bits & RTREE_LEAF_STATE_MASK) >>
-- line 252 ----------------------------------------
-- line 262 ----------------------------------------
    .            .           .              .          .          .              .           .           .           	return contents;
    .            .           .              .          .          .              .           .           .           #endif
    .            .           .              .          .          .              .           .           .           }
    .            .           .              .          .          .              .           .           .           
    .            .           .              .          .          .              .           .           .           JEMALLOC_ALWAYS_INLINE void
    .            .           .              .          .          .              .           .           .           rtree_contents_encode(rtree_contents_t contents, void **bits,
    .            .           .              .          .          .              .           .           .               unsigned *additional) {
    .            .           .              .          .          .              .           .           .           #ifdef RTREE_LEAF_COMPACT
  624 ( 0.01%)  87 ( 0.06%)  3 ( 0.04%)   208 ( 0.01%) 0          0            208 ( 0.01%)  0           0           	*bits = (void *)rtree_leaf_elm_bits_encode(contents);
    .            .           .              .          .          .              .           .           .           #else
    .            .           .              .          .          .              .           .           .           	*additional = (unsigned)contents.metadata.slab
    .            .           .              .          .          .              .           .           .           	    | ((unsigned)contents.metadata.is_head << 1)
    .            .           .              .          .          .              .           .           .           	    | ((unsigned)contents.metadata.state << RTREE_LEAF_STATE_SHIFT)
    .            .           .              .          .          .              .           .           .           	    | ((unsigned)contents.metadata.szind << (RTREE_LEAF_STATE_SHIFT +
    .            .           .              .          .          .              .           .           .           	    RTREE_LEAF_STATE_WIDTH));
    .            .           .              .          .          .              .           .           .           	*bits = contents.edata;
    .            .           .              .          .          .              .           .           .           #endif
  208 ( 0.00%)   0           0              0          0          0              0           0           0           }
    .            .           .              .          .          .              .           .           .           
    .            .           .              .          .          .              .           .           .           JEMALLOC_ALWAYS_INLINE void
    .            .           .              .          .          .              .           .           .           rtree_leaf_elm_write_commit(tsdn_t *tsdn, rtree_t *rtree,
    .            .           .              .          .          .              .           .           .               rtree_leaf_elm_t *elm, void *bits, unsigned additional) {
    .            .           .              .          .          .              .           .           .           #ifdef RTREE_LEAF_COMPACT
1,624 ( 0.02%) 142 ( 0.10%)  5 ( 0.07%)   696 ( 0.03%) 0          0            928 ( 0.03%)  0           0           	atomic_store_p(&elm->le_bits, bits, ATOMIC_RELEASE);
    .            .           .              .          .          .              .           .           .           #else
    .            .           .              .          .          .              .           .           .           	atomic_store_u(&elm->le_metadata, additional, ATOMIC_RELEASE);
    .            .           .              .          .          .              .           .           .           	/*
    .            .           .              .          .          .              .           .           .           	 * Write edata last, since the element is atomically considered valid
    .            .           .              .          .          .              .           .           .           	 * as soon as the edata field is non-NULL.
    .            .           .              .          .          .              .           .           .           	 */
    .            .           .              .          .          .              .           .           .           	atomic_store_p(&elm->le_edata, bits, ATOMIC_RELEASE);
    .            .           .              .          .          .              .           .           .           #endif
  232 ( 0.00%)   0           0              0          0          0              0           0           0           }
    .            .           .              .          .          .              .           .           .           
    .            .           .              .          .          .              .           .           .           JEMALLOC_ALWAYS_INLINE void
    .            .           .              .          .          .              .           .           .           rtree_leaf_elm_write(tsdn_t *tsdn, rtree_t *rtree,
    .            .           .              .          .          .              .           .           .               rtree_leaf_elm_t *elm, rtree_contents_t contents) {
3,700 ( 0.04%) 293 ( 0.20%) 10 ( 0.14%) 1,110 ( 0.05%) 0          0          1,480 ( 0.05%)  0           0           	assert((uintptr_t)contents.edata % EDATA_ALIGNMENT == 0);
    .            .           .              .          .          .              .           .           .           	void *bits;
    .            .           .              .          .          .              .           .           .           	unsigned additional;
    .            .           .              .          .          .              .           .           .           
    .            .           .              .          .          .              .           .           .           	rtree_contents_encode(contents, &bits, &additional);
1,850 ( 0.02%) 119 ( 0.08%)  4 ( 0.06%)   925 ( 0.04%) 0          0            925 ( 0.03%)  0           0           	rtree_leaf_elm_write_commit(tsdn, rtree, elm, bits, additional);
  185 ( 0.00%)   0           0              0          0          0              0           0           0           }
    .            .           .              .          .          .              .           .           .           
    .            .           .              .          .          .              .           .           .           /* The state field can be updated independently (and more frequently). */
    .            .           .              .          .          .              .           .           .           JEMALLOC_ALWAYS_INLINE void
    .            .           .              .          .          .              .           .           .           rtree_leaf_elm_state_update(tsdn_t *tsdn, rtree_t *rtree,
    .            .           .              .          .          .              .           .           .               rtree_leaf_elm_t *elm1, rtree_leaf_elm_t *elm2, extent_state_t state) {
  693 ( 0.01%)  51 ( 0.04%)  2 ( 0.03%)   189 ( 0.01%) 0          0            252 ( 0.01%)  0           0           	assert(elm1 != NULL);
    .            .           .              .          .          .              .           .           .           #ifdef RTREE_LEAF_COMPACT
   63 ( 0.00%)   0           0              0          0          0             63 ( 0.00%)  0           0           	uintptr_t bits = rtree_leaf_elm_bits_read(tsdn, rtree, elm1,
    .            .           .              .          .          .              .           .           .           	    /* dependent */ true);
   63 ( 0.00%)   0           0             63 ( 0.00%) 0          0              0           0           0           	bits &= ~RTREE_LEAF_STATE_MASK;
  252 ( 0.00%)  63 ( 0.04%)  1 ( 0.01%)   126 ( 0.01%) 0          0              0           0           0           	bits |= state << RTREE_LEAF_STATE_SHIFT;
  441 ( 0.00%)   0           0            189 ( 0.01%) 0          0            252 ( 0.01%)  0           0           	atomic_store_p(&elm1->le_bits, (void *)bits, ATOMIC_RELEASE);
  126 ( 0.00%)   0           0             63 ( 0.00%) 0          0              0           0           0           	if (elm2 != NULL) {
  441 ( 0.00%)  30 ( 0.02%)  1 ( 0.01%)   189 ( 0.01%) 0          0            252 ( 0.01%)  0           0           		atomic_store_p(&elm2->le_bits, (void *)bits, ATOMIC_RELEASE);
    .            .           .              .          .          .              .           .           .           	}
    .            .           .              .          .          .              .           .           .           #else
    .            .           .              .          .          .              .           .           .           	unsigned bits = atomic_load_u(&elm1->le_metadata, ATOMIC_RELAXED);
    .            .           .              .          .          .              .           .           .           	bits &= ~RTREE_LEAF_STATE_MASK;
    .            .           .              .          .          .              .           .           .           	bits |= state << RTREE_LEAF_STATE_SHIFT;
    .            .           .              .          .          .              .           .           .           	atomic_store_u(&elm1->le_metadata, bits, ATOMIC_RELEASE);
    .            .           .              .          .          .              .           .           .           	if (elm2 != NULL) {
    .            .           .              .          .          .              .           .           .           		atomic_store_u(&elm2->le_metadata, bits, ATOMIC_RELEASE);
    .            .           .              .          .          .              .           .           .           	}
    .            .           .              .          .          .              .           .           .           #endif
   63 ( 0.00%)   0           0              0          0          0              0           0           0           }
    .            .           .              .          .          .              .           .           .           
    .            .           .              .          .          .              .           .           .           /*
    .            .           .              .          .          .              .           .           .            * Tries to look up the key in the L1 cache, returning false if there's a hit, or
    .            .           .              .          .          .              .           .           .            * true if there's a miss.
    .            .           .              .          .          .              .           .           .            * Key is allowed to be NULL; returns true in this case.
    .            .           .              .          .          .              .           .           .            */
    .            .           .              .          .          .              .           .           .           JEMALLOC_ALWAYS_INLINE bool
    .            .           .              .          .          .              .           .           .           rtree_leaf_elm_lookup_fast(tsdn_t *tsdn, rtree_t *rtree, rtree_ctx_t *rtree_ctx,
-- line 338 ----------------------------------------
-- line 351 ----------------------------------------
    .            .           .              .          .          .              .           .           .           	*elm = &leaf[subkey];
    .            .           .              .          .          .              .           .           .           
    .            .           .              .          .          .              .           .           .           	return false;
    .            .           .              .          .          .              .           .           .           }
    .            .           .              .          .          .              .           .           .           
    .            .           .              .          .          .              .           .           .           JEMALLOC_ALWAYS_INLINE rtree_leaf_elm_t *
    .            .           .              .          .          .              .           .           .           rtree_leaf_elm_lookup(tsdn_t *tsdn, rtree_t *rtree, rtree_ctx_t *rtree_ctx,
    .            .           .              .          .          .              .           .           .               uintptr_t key, bool dependent, bool init_missing) {
2,128 ( 0.02%)  32 ( 0.02%)  1 ( 0.01%)     0          0          0              0           0           0           	assert(key != 0);
3,192 ( 0.03%) 653 ( 0.45%) 22 ( 0.31%)   532 ( 0.02%) 0          0            532 ( 0.02%)  4 ( 0.08%)  2 ( 0.05%)  	assert(!dependent || !init_missing);
    .            .           .              .          .          .              .           .           .           
1,596 ( 0.02%) 247 ( 0.17%)  4 ( 0.06%)   532 ( 0.02%) 0          0          1,064 ( 0.03%)  6 ( 0.11%)  4 ( 0.10%)  	size_t slot = rtree_cache_direct_map(key);
  532 ( 0.01%)  32 ( 0.02%)  1 ( 0.01%)     0          0          0            532 ( 0.02%)  4 ( 0.08%)  4 ( 0.10%)  	uintptr_t leafkey = rtree_leafkey(key);
2,128 ( 0.02%)  23 ( 0.02%)  1 ( 0.01%)     0          0          0              0           0           0           	assert(leafkey != RTREE_LEAFKEY_INVALID);
    .            .           .              .          .          .              .           .           .           
    .            .           .              .          .          .              .           .           .           	/* Fast path: L1 direct mapped cache. */
5,320 ( 0.06%) 485 ( 0.34%) 18 ( 0.25%) 2,128 ( 0.09%) 0          0              0           0           0           	if (likely(rtree_ctx->cache[slot].leafkey == leafkey)) {
3,717 ( 0.04%) 180 ( 0.12%)  4 ( 0.06%) 1,593 ( 0.07%) 0          0            531 ( 0.02%)  1 ( 0.02%)  0           		rtree_leaf_elm_t *leaf = rtree_ctx->cache[slot].leaf;
3,717 ( 0.04%) 460 ( 0.32%) 15 ( 0.21%)   531 ( 0.02%) 0          0          1,062 ( 0.03%) 13 ( 0.24%) 11 ( 0.26%)  		assert(leaf != NULL);
  531 ( 0.01%)  91 ( 0.06%)  2 ( 0.03%)     0          0          0            531 ( 0.02%)  4 ( 0.08%)  2 ( 0.05%)  		uintptr_t subkey = rtree_subkey(key, RTREE_HEIGHT-1);
2,655 ( 0.03%)  86 ( 0.06%)  4 ( 0.06%) 1,062 ( 0.04%) 0          0              0           0           0           		return &leaf[subkey];
    .            .           .              .          .          .              .           .           .           	}
    .            .           .              .          .          .              .           .           .           	/*
    .            .           .              .          .          .              .           .           .           	 * Search the L2 LRU cache.  On hit, swap the matching element into the
    .            .           .              .          .          .              .           .           .           	 * slot in L1 cache, and move the position in L2 up by 1.
    .            .           .              .          .          .              .           .           .           	 */
    .            .           .              .          .          .              .           .           .           #define RTREE_CACHE_CHECK_L2(i) do {					\
    .            .           .              .          .          .              .           .           .           	if (likely(rtree_ctx->l2_cache[i].leafkey == leafkey)) {	\
    .            .           .              .          .          .              .           .           .           		rtree_leaf_elm_t *leaf = rtree_ctx->l2_cache[i].leaf;	\
-- line 379 ----------------------------------------
-- line 396 ----------------------------------------
    .            .           .              .          .          .              .           .           .           		}							\
    .            .           .              .          .          .              .           .           .           		rtree_ctx->cache[slot].leafkey = leafkey;		\
    .            .           .              .          .          .              .           .           .           		rtree_ctx->cache[slot].leaf = leaf;			\
    .            .           .              .          .          .              .           .           .           		uintptr_t subkey = rtree_subkey(key, RTREE_HEIGHT-1);	\
    .            .           .              .          .          .              .           .           .           		return &leaf[subkey];					\
    .            .           .              .          .          .              .           .           .           	}								\
    .            .           .              .          .          .              .           .           .           } while (0)
    .            .           .              .          .          .              .           .           .           	/* Check the first cache entry. */
    7 ( 0.00%)   2 ( 0.00%)  2 ( 0.03%)     3 ( 0.00%) 0          0              0           0           0           	RTREE_CACHE_CHECK_L2(0);
    .            .           .              .          .          .              .           .           .           	/* Search the remaining cache elements. */
   25 ( 0.00%)   2 ( 0.00%)  2 ( 0.03%)    15 ( 0.00%) 0          0              1 ( 0.00%)  1 ( 0.02%)  0           	for (unsigned i = 1; i < RTREE_CTX_NCACHE_L2; i++) {
   77 ( 0.00%)   1 ( 0.00%)  1 ( 0.01%)    28 ( 0.00%) 0          0              0           0           0           		RTREE_CACHE_CHECK_L2(i);
    .            .           .              .          .          .              .           .           .           	}
    .            .           .              .          .          .              .           .           .           #undef RTREE_CACHE_CHECK_L2
    .            .           .              .          .          .              .           .           .           
   10 ( 0.00%)   1 ( 0.00%)  1 ( 0.01%)     6 ( 0.00%) 0          0              1 ( 0.00%)  0           0           	return rtree_leaf_elm_lookup_hard(tsdn, rtree, rtree_ctx, key,
    .            .           .              .          .          .              .           .           .           	    dependent, init_missing);
    .            .           .              .          .          .              .           .           .           }
    .            .           .              .          .          .              .           .           .           
    .            .           .              .          .          .              .           .           .           /*
    .            .           .              .          .          .              .           .           .            * Returns true on lookup failure.
    .            .           .              .          .          .              .           .           .            */
    .            .           .              .          .          .              .           .           .           static inline bool
    .            .           .              .          .          .              .           .           .           rtree_read_independent(tsdn_t *tsdn, rtree_t *rtree, rtree_ctx_t *rtree_ctx,
-- line 419 ----------------------------------------
-- line 425 ----------------------------------------
    .            .           .              .          .          .              .           .           .           	}
    .            .           .              .          .          .              .           .           .           	*r_contents = rtree_leaf_elm_read(tsdn, rtree, elm,
    .            .           .              .          .          .              .           .           .           	    /* dependent */ false);
    .            .           .              .          .          .              .           .           .           	return false;
    .            .           .              .          .          .              .           .           .           }
    .            .           .              .          .          .              .           .           .           
    .            .           .              .          .          .              .           .           .           static inline rtree_contents_t
    .            .           .              .          .          .              .           .           .           rtree_read(tsdn_t *tsdn, rtree_t *rtree, rtree_ctx_t *rtree_ctx,
2,058 ( 0.02%) 160 ( 0.11%)  3 ( 0.04%)   490 ( 0.02%) 0          0          1,274 ( 0.04%)  9 ( 0.17%)  8 ( 0.19%)      uintptr_t key) {
   98 ( 0.00%)  33 ( 0.02%)  1 ( 0.01%)     0          0          0             98 ( 0.00%)  0           0           	rtree_leaf_elm_t *elm = rtree_leaf_elm_lookup(tsdn, rtree, rtree_ctx,
    .            .           .              .          .          .              .           .           .           	    key, /* dependent */ true, /* init_missing */ false);
1,078 ( 0.01%)  62 ( 0.04%)  2 ( 0.03%)   294 ( 0.01%) 0          0            392 ( 0.01%)  6 ( 0.11%)  6 ( 0.14%)  	assert(elm != NULL);
   98 ( 0.00%)   0           0              0          0          0              0           0           0           	return rtree_leaf_elm_read(tsdn, rtree, elm, /* dependent */ true);
  588 ( 0.01%)   0           0            490 ( 0.02%) 0          0              0           0           0           }
    .            .           .              .          .          .              .           .           .           
    .            .           .              .          .          .              .           .           .           static inline rtree_metadata_t
    .            .           .              .          .          .              .           .           .           rtree_metadata_read(tsdn_t *tsdn, rtree_t *rtree, rtree_ctx_t *rtree_ctx,
1,960 ( 0.02%)  89 ( 0.06%)  3 ( 0.04%)   490 ( 0.02%) 0          0          1,176 ( 0.04%) 11 ( 0.21%)  9 ( 0.21%)      uintptr_t key) {
   98 ( 0.00%)  27 ( 0.02%)  1 ( 0.01%)     0          0          0             98 ( 0.00%)  0           0           	rtree_leaf_elm_t *elm = rtree_leaf_elm_lookup(tsdn, rtree, rtree_ctx,
    .            .           .              .          .          .              .           .           .           	    key, /* dependent */ true, /* init_missing */ false);
1,078 ( 0.01%)  87 ( 0.06%)  3 ( 0.04%)   294 ( 0.01%) 0          0            392 ( 0.01%)  2 ( 0.04%)  2 ( 0.05%)  	assert(elm != NULL);
    .            .           .              .          .          .              .           .           .           	return rtree_leaf_elm_read(tsdn, rtree, elm,
  686 ( 0.01%)   0           0            392 ( 0.02%) 0          0            196 ( 0.01%)  0           0           	    /* dependent */ true).metadata;
  490 ( 0.01%)   0           0            392 ( 0.02%) 0          0              0           0           0           }
    .            .           .              .          .          .              .           .           .           
    .            .           .              .          .          .              .           .           .           /*
    .            .           .              .          .          .              .           .           .            * Returns true when the request cannot be fulfilled by fastpath.
    .            .           .              .          .          .              .           .           .            */
    .            .           .              .          .          .              .           .           .           static inline bool
    .            .           .              .          .          .              .           .           .           rtree_metadata_try_read_fast(tsdn_t *tsdn, rtree_t *rtree, rtree_ctx_t *rtree_ctx,
    .            .           .              .          .          .              .           .           .               uintptr_t key, rtree_metadata_t *r_rtree_metadata) {
    .            .           .              .          .          .              .           .           .           	rtree_leaf_elm_t *elm;
-- line 456 ----------------------------------------
-- line 467 ----------------------------------------
    .            .           .              .          .          .              .           .           .           	*r_rtree_metadata = rtree_leaf_elm_read(tsdn, rtree, elm,
    .            .           .              .          .          .              .           .           .           	    /* dependent */ true).metadata;
    .            .           .              .          .          .              .           .           .           	return false;
    .            .           .              .          .          .              .           .           .           }
    .            .           .              .          .          .              .           .           .           
    .            .           .              .          .          .              .           .           .           JEMALLOC_ALWAYS_INLINE void
    .            .           .              .          .          .              .           .           .           rtree_write_range_impl(tsdn_t *tsdn, rtree_t *rtree, rtree_ctx_t *rtree_ctx,
    .            .           .              .          .          .              .           .           .               uintptr_t base, uintptr_t end, rtree_contents_t contents, bool clearing) {
  460 ( 0.00%)  69 ( 0.05%)  3 ( 0.04%)   138 ( 0.01%) 0          0            184 ( 0.01%)  0           0           	assert((base & PAGE_MASK) == 0 && (end & PAGE_MASK) == 0);
    .            .           .              .          .          .              .           .           .           	/*
    .            .           .              .          .          .              .           .           .           	 * Only used for emap_(de)register_interior, which implies the
    .            .           .              .          .          .              .           .           .           	 * boundaries have been registered already.  Therefore all the lookups
    .            .           .              .          .          .              .           .           .           	 * are dependent w/o init_missing, assuming the range spans across at
    .            .           .              .          .          .              .           .           .           	 * most 2 rtree leaf nodes (each covers 1 GiB of vaddr).
    .            .           .              .          .          .              .           .           .           	 */
    .            .           .              .          .          .              .           .           .           	void *bits;
    .            .           .              .          .          .              .           .           .           	unsigned additional;
    .            .           .              .          .          .              .           .           .           	rtree_contents_encode(contents, &bits, &additional);
    .            .           .              .          .          .              .           .           .           
   23 ( 0.00%)   0           0              0          0          0             23 ( 0.00%)  0           0           	rtree_leaf_elm_t *elm = NULL; /* Dead store. */
  326 ( 0.00%)  46 ( 0.03%)  2 ( 0.03%)   210 ( 0.01%) 0          0             23 ( 0.00%)  0           0           	for (uintptr_t addr = base; addr <= end; addr += PAGE) {
  419 ( 0.00%)  46 ( 0.03%)  2 ( 0.03%)   186 ( 0.01%) 0          0            138 ( 0.00%)  0           0           		if (addr == base ||
  144 ( 0.00%)   0           0             24 ( 0.00%) 0          0              0           0           0           		    (addr & ((ZU(1) << rtree_leaf_maskbits()) - 1)) == 0) {
   23 ( 0.00%)  23 ( 0.02%)  1 ( 0.01%)     0          0          0             23 ( 0.00%)  0           0           			elm = rtree_leaf_elm_lookup(tsdn, rtree, rtree_ctx, addr,
    .            .           .              .          .          .              .           .           .           			    /* dependent */ true, /* init_missing */ false);
   92 ( 0.00%)   0           0              0          0          0              0           0           0           			assert(elm != NULL);
    .            .           .              .          .          .              .           .           .           		}
  188 ( 0.00%)  23 ( 0.02%)  1 ( 0.01%)     0          0          0              0           0           0           		assert(elm == rtree_leaf_elm_lookup(tsdn, rtree, rtree_ctx, addr,
    .            .           .              .          .          .              .           .           .           		    /* dependent */ true, /* init_missing */ false));
  188 ( 0.00%)  23 ( 0.02%)  1 ( 0.01%)     0          0          0              0           0           0           		assert(!clearing || rtree_leaf_elm_read(tsdn, rtree, elm,
    .            .           .              .          .          .              .           .           .           		    /* dependent */ true).edata != NULL);
  470 ( 0.00%)  46 ( 0.03%)  2 ( 0.03%)   235 ( 0.01%) 0          0            235 ( 0.01%)  0           0           		rtree_leaf_elm_write_commit(tsdn, rtree, elm, bits, additional);
   47 ( 0.00%)   0           0             47 ( 0.00%) 0          0              0           0           0           		elm++;
    .            .           .              .          .          .              .           .           .           	}
   23 ( 0.00%)   0           0              0          0          0              0           0           0           }
    .            .           .              .          .          .              .           .           .           
    .            .           .              .          .          .              .           .           .           JEMALLOC_ALWAYS_INLINE void
    .            .           .              .          .          .              .           .           .           rtree_write_range(tsdn_t *tsdn, rtree_t *rtree, rtree_ctx_t *rtree_ctx,
    .            .           .              .          .          .              .           .           .               uintptr_t base, uintptr_t end, rtree_contents_t contents) {
    .            .           .              .          .          .              .           .           .           	rtree_write_range_impl(tsdn, rtree, rtree_ctx, base, end, contents,
    .            .           .              .          .          .              .           .           .           	    /* clearing */ false);
   23 ( 0.00%)   0           0              0          0          0              0           0           0           }
    .            .           .              .          .          .              .           .           .           
    .            .           .              .          .          .              .           .           .           JEMALLOC_ALWAYS_INLINE bool
    .            .           .              .          .          .              .           .           .           rtree_write(tsdn_t *tsdn, rtree_t *rtree, rtree_ctx_t *rtree_ctx, uintptr_t key,
    .            .           .              .          .          .              .           .           .               rtree_contents_t contents) {
   55 ( 0.00%)  55 ( 0.04%)  2 ( 0.03%)     0          0          0             55 ( 0.00%)  0           0           	rtree_leaf_elm_t *elm = rtree_leaf_elm_lookup(tsdn, rtree, rtree_ctx,
    .            .           .              .          .          .              .           .           .           	    key, /* dependent */ false, /* init_missing */ true);
  770 ( 0.01%)  78 ( 0.05%)  3 ( 0.04%)   385 ( 0.02%) 0          0            330 ( 0.01%)  0           0           	if (elm == NULL) {
    .            .           .              .          .          .              .           .           .           		return true;
    .            .           .              .          .          .              .           .           .           	}
    .            .           .              .          .          .              .           .           .           
    .            .           .              .          .          .              .           .           .           	rtree_leaf_elm_write(tsdn, rtree, elm, contents);
    .            .           .              .          .          .              .           .           .           
   55 ( 0.00%)   0           0              0          0          0              0           0           0           	return false;
    .            .           .              .          .          .              .           .           .           }
    .            .           .              .          .          .              .           .           .           
    .            .           .              .          .          .              .           .           .           static inline void
    .            .           .              .          .          .              .           .           .           rtree_clear(tsdn_t *tsdn, rtree_t *rtree, rtree_ctx_t *rtree_ctx,
    .            .           .              .          .          .              .           .           .               uintptr_t key) {
    .            .           .              .          .          .              .           .           .           	rtree_leaf_elm_t *elm = rtree_leaf_elm_lookup(tsdn, rtree, rtree_ctx,
    .            .           .              .          .          .              .           .           .           	    key, /* dependent */ true, /* init_missing */ false);
    .            .           .              .          .          .              .           .           .           	assert(elm != NULL);
-- line 529 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/ashy5000/dev/cryptocurrency/contracts/target/debug/build/tikv-jemalloc-sys-7365f40ecb99e085/out/build/src/arena.c
--------------------------------------------------------------------------------
Ir              I1mr         ILmr       Dr             D1mr        DLmr       Dw             D1mw         DLmw         

-- line 236 ----------------------------------------
     .            .          .              .           .          .              .            .            .           	ret = (void *)((uintptr_t)edata_addr_get(slab) +
     .            .          .              .           .          .              .            .            .           	    (uintptr_t)(bin_info->reg_size * regind));
     .            .          .              .           .          .              .            .            .           	edata_nfree_dec(slab);
     .            .          .              .           .          .              .            .            .           	return ret;
     .            .          .              .           .          .              .            .            .           }
     .            .          .              .           .          .              .            .            .           
     .            .          .              .           .          .              .            .            .           static void
     .            .          .              .           .          .              .            .            .           arena_slab_reg_alloc_batch(edata_t *slab, const bin_info_t *bin_info,
   341 ( 0.00%)  31 ( 0.02%) 1 ( 0.01%)    31 ( 0.00%)  0          0            186 ( 0.01%)   0            0           			   unsigned cnt, void** ptrs) {
   124 ( 0.00%)  31 ( 0.02%) 1 ( 0.01%)    31 ( 0.00%)  0          0             62 ( 0.00%)   0            0           	slab_data_t *slab_data = edata_slab_data_get(slab);
     .            .          .              .           .          .              .            .            .           
   124 ( 0.00%)   0          0              0           0          0              0            0            0           	assert(edata_nfree_get(slab) >= cnt);
   124 ( 0.00%)  31 ( 0.02%) 1 ( 0.01%)     0           0          0              0            0            0           	assert(!bitmap_full(slab_data->bitmap, &bin_info->bitmap_info));
     .            .          .              .           .          .              .            .            .           
     .            .          .              .           .          .              .            .            .           #if (! defined JEMALLOC_INTERNAL_POPCOUNTL) || (defined BITMAP_USE_TREE)
     .            .          .              .           .          .              .            .            .           	for (unsigned i = 0; i < cnt; i++) {
     .            .          .              .           .          .              .            .            .           		size_t regind = bitmap_sfu(slab_data->bitmap,
     .            .          .              .           .          .              .            .            .           					   &bin_info->bitmap_info);
     .            .          .              .           .          .              .            .            .           		*(ptrs + i) = (void *)((uintptr_t)edata_addr_get(slab) +
     .            .          .              .           .          .              .            .            .           		    (uintptr_t)(bin_info->reg_size * regind));
     .            .          .              .           .          .              .            .            .           	}
     .            .          .              .           .          .              .            .            .           #else
    31 ( 0.00%)  31 ( 0.02%) 1 ( 0.01%)     0           0          0             31 ( 0.00%)   0            0           	unsigned group = 0;
   124 ( 0.00%)   0          0             93 ( 0.00%)  0          0             31 ( 0.00%)   0            0           	bitmap_t g = slab_data->bitmap[group];
    31 ( 0.00%)   0          0              0           0          0             31 ( 0.00%)   0            0           	unsigned i = 0;
   238 ( 0.00%)  62 ( 0.04%) 2 ( 0.03%)   138 ( 0.01%)  0          0              0            0            0           	while (i < cnt) {
   135 ( 0.00%)   0          0             45 ( 0.00%)  0          0              0            0            0           		while (g == 0) {
    35 ( 0.00%)   0          0             28 ( 0.00%)  0          0              7 ( 0.00%)   0            0           			g = slab_data->bitmap[++group];
     .            .          .              .           .          .              .            .            .           		}
   152 ( 0.00%)  31 ( 0.02%) 1 ( 0.01%)    38 ( 0.00%)  0          0             38 ( 0.00%)   0            0           		size_t shift = group << LG_BITMAP_GROUP_NBITS;
   190 ( 0.00%)   0          0             38 ( 0.00%)  0          0             76 ( 0.00%)   0            0           		size_t pop = popcount_lu(g);
   190 ( 0.00%)   0          0            114 ( 0.00%)  0          0              0            0            0           		if (pop > (cnt - i)) {
    44 ( 0.00%)   0          0             22 ( 0.00%)  0          0             11 ( 0.00%)   0            0           			pop = cnt - i;
     .            .          .              .           .          .              .            .            .           		}
     .            .          .              .           .          .              .            .            .           
     .            .          .              .           .          .              .            .            .           		/*
     .            .          .              .           .          .              .            .            .           		 * Load from memory locations only once, outside the
     .            .          .              .           .          .              .            .            .           		 * hot loop below.
     .            .          .              .           .          .              .            .            .           		 */
   152 ( 0.00%)  31 ( 0.02%) 1 ( 0.01%)    38 ( 0.00%)  0          0             76 ( 0.00%)   0            0           		uintptr_t base = (uintptr_t)edata_addr_get(slab);
   114 ( 0.00%)   0          0             76 ( 0.00%)  2 ( 0.03%) 0             38 ( 0.00%)   0            0           		uintptr_t regsize = (uintptr_t)bin_info->reg_size;
 5,578 ( 0.06%)   0          0          1,108 ( 0.05%)  0          0          1,108 ( 0.04%)   0            0           		while (pop--) {
 4,280 ( 0.05%)   0          0              0           0          0          2,140 ( 0.07%)   0            0           			size_t bit = cfs_lu(&g);
 4,280 ( 0.05%)   0          0          2,140 ( 0.09%)  0          0          1,070 ( 0.03%)   0            0           			size_t regind = shift + bit;
10,700 ( 0.11%)   0          0          5,350 ( 0.22%)  0          0          1,070 ( 0.03%) 139 ( 2.61%) 139 ( 3.32%)  			*(ptrs + i) = (void *)(base + regsize * regind);
     .            .          .              .           .          .              .            .            .           
 1,070 ( 0.01%)   0          0          1,070 ( 0.04%)  0          0              0            0            0           			i++;
     .            .          .              .           .          .              .            .            .           		}
   152 ( 0.00%)   0          0            114 ( 0.00%)  0          0             38 ( 0.00%)   0            0           		slab_data->bitmap[group] = g;
     .            .          .              .           .          .              .            .            .           	}
     .            .          .              .           .          .              .            .            .           #endif
   155 ( 0.00%)   0          0             62 ( 0.00%)  0          0             31 ( 0.00%)   0            0           	edata_nfree_sub(slab, cnt);
   186 ( 0.00%)   0          0            124 ( 0.01%)  0          0              0            0            0           }
     .            .          .              .           .          .              .            .            .           
     .            .          .              .           .          .              .            .            .           static void
     .            .          .              .           .          .              .            .            .           arena_large_malloc_stats_update(tsdn_t *tsdn, arena_t *arena, size_t usize) {
     .            .          .              .           .          .              .            .            .           	szind_t index, hindex;
     .            .          .              .           .          .              .            .            .           
     .            .          .              .           .          .              .            .            .           	cassert(config_stats);
     .            .          .              .           .          .              .            .            .           
     .            .          .              .           .          .              .            .            .           	if (usize < SC_LARGE_MINCLASS) {
-- line 296 ----------------------------------------
-- line 323 ----------------------------------------
     .            .          .              .           .          .              .            .            .           arena_large_ralloc_stats_update(tsdn_t *tsdn, arena_t *arena, size_t oldusize,
     .            .          .              .           .          .              .            .            .               size_t usize) {
     .            .          .              .           .          .              .            .            .           	arena_large_malloc_stats_update(tsdn, arena, usize);
     .            .          .              .           .          .              .            .            .           	arena_large_dalloc_stats_update(tsdn, arena, oldusize);
     .            .          .              .           .          .              .            .            .           }
     .            .          .              .           .          .              .            .            .           
     .            .          .              .           .          .              .            .            .           edata_t *
     .            .          .              .           .          .              .            .            .           arena_extent_alloc_large(tsdn_t *tsdn, arena_t *arena, size_t usize,
    13 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)     1 ( 0.00%)  0          0              7 ( 0.00%)   0            0               size_t alignment, bool zero) {
     3 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)     1 ( 0.00%)  0          0              2 ( 0.00%)   0            0           	bool deferred_work_generated = false;
     1 ( 0.00%)   0          0              0           0          0              1 ( 0.00%)   0            0           	szind_t szind = sz_size2index(usize);
     5 ( 0.00%)   0          0              2 ( 0.00%)  0          0              1 ( 0.00%)   0            0           	size_t esize = usize + sz_large_pad;
     .            .          .              .           .          .              .            .            .           
    10 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)     4 ( 0.00%)  0          0              3 ( 0.00%)   0            0           	bool guarded = san_large_extent_decide_guard(tsdn,
     .            .          .              .           .          .              .            .            .           	    arena_get_ehooks(arena), esize, alignment);
    19 ( 0.00%)   2 ( 0.00%) 1 ( 0.01%)     7 ( 0.00%)  0          0              5 ( 0.00%)   0            0           	edata_t *edata = pa_alloc(tsdn, &arena->pa_shard, esize, alignment,
     .            .          .              .           .          .              .            .            .           	    /* slab */ false, szind, zero, guarded, &deferred_work_generated);
     4 ( 0.00%)   0          0              0           0          0              0            0            0           	assert(deferred_work_generated == false);
     .            .          .              .           .          .              .            .            .           
     2 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)     1 ( 0.00%)  0          0              0            0            0           	if (edata != NULL) {
     3 ( 0.00%)   0          0              0           0          0              0            0            0           		if (config_stats) {
     .            .          .              .           .          .              .            .            .           			LOCKEDINT_MTX_LOCK(tsdn, arena->stats.mtx);
     .            .          .              .           .          .              .            .            .           			arena_large_malloc_stats_update(tsdn, arena, usize);
     .            .          .              .           .          .              .            .            .           			LOCKEDINT_MTX_UNLOCK(tsdn, arena->stats.mtx);
     .            .          .              .           .          .              .            .            .           		}
     .            .          .              .           .          .              .            .            .           	}
     .            .          .              .           .          .              .            .            .           
     6 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)     2 ( 0.00%)  0          0              0            0            0           	if (edata != NULL && sz_large_pad != 0) {
     6 ( 0.00%)   0          0              4 ( 0.00%)  0          0              1 ( 0.00%)   0            0           		arena_cache_oblivious_randomize(tsdn, arena, edata, alignment);
     .            .          .              .           .          .              .            .            .           	}
     .            .          .              .           .          .              .            .            .           
     1 ( 0.00%)   0          0              1 ( 0.00%)  0          0              0            0            0           	return edata;
     5 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)     4 ( 0.00%)  0          0              0            0            0           }
     .            .          .              .           .          .              .            .            .           
     .            .          .              .           .          .              .            .            .           void
     .            .          .              .           .          .              .            .            .           arena_extent_dalloc_large_prep(tsdn_t *tsdn, arena_t *arena, edata_t *edata) {
     .            .          .              .           .          .              .            .            .           	if (config_stats) {
     .            .          .              .           .          .              .            .            .           		LOCKEDINT_MTX_LOCK(tsdn, arena->stats.mtx);
     .            .          .              .           .          .              .            .            .           		arena_large_dalloc_stats_update(tsdn, arena,
     .            .          .              .           .          .              .            .            .           		    edata_usize_get(edata));
     .            .          .              .           .          .              .            .            .           		LOCKEDINT_MTX_UNLOCK(tsdn, arena->stats.mtx);
-- line 363 ----------------------------------------
-- line 586 ----------------------------------------
     .            .          .              .           .          .              .            .            .           arena_bin_slabs_nonfull_remove(bin_t *bin, edata_t *slab) {
     .            .          .              .           .          .              .            .            .           	edata_heap_remove(&bin->slabs_nonfull, slab);
     .            .          .              .           .          .              .            .            .           	if (config_stats) {
     .            .          .              .           .          .              .            .            .           		bin->stats.nonfull_slabs--;
     .            .          .              .           .          .              .            .            .           	}
     .            .          .              .           .          .              .            .            .           }
     .            .          .              .           .          .              .            .            .           
     .            .          .              .           .          .              .            .            .           static edata_t *
   310 ( 0.00%)  48 ( 0.03%) 1 ( 0.01%)     0           0          0            124 ( 0.00%)   0            0           arena_bin_slabs_nonfull_tryget(bin_t *bin) {
   310 ( 0.00%)  51 ( 0.04%) 1 ( 0.01%)    62 ( 0.00%)  0          0            124 ( 0.00%)   0            0           	edata_t *slab = edata_heap_remove_first(&bin->slabs_nonfull);
   124 ( 0.00%)   0          0             62 ( 0.00%)  0          0              0            0            0           	if (slab == NULL) {
   124 ( 0.00%)   0          0              0           0          0              0            0            0           		return NULL;
     .            .          .              .           .          .              .            .            .           	}
     .            .          .              .           .          .              .            .            .           	if (config_stats) {
     .            .          .              .           .          .              .            .            .           		bin->stats.reslabs++;
     .            .          .              .           .          .              .            .            .           		bin->stats.nonfull_slabs--;
     .            .          .              .           .          .              .            .            .           	}
     .            .          .              .           .          .              .            .            .           	return slab;
   124 ( 0.00%)  47 ( 0.03%) 1 ( 0.01%)   124 ( 0.01%)  0          0              0            0            0           }
     .            .          .              .           .          .              .            .            .           
     .            .          .              .           .          .              .            .            .           static void
    77 ( 0.00%)   0          0              0           0          0             44 ( 0.00%)   0            0           arena_bin_slabs_full_insert(arena_t *arena, bin_t *bin, edata_t *slab) {
    44 ( 0.00%)   0          0              0           0          0              0            0            0           	assert(edata_nfree_get(slab) == 0);
     .            .          .              .           .          .              .            .            .           	/*
     .            .          .              .           .          .              .            .            .           	 *  Tracking extents is required by arena_reset, which is not allowed
     .            .          .              .           .          .              .            .            .           	 *  for auto arenas.  Bypass this step to avoid touching the edata
     .            .          .              .           .          .              .            .            .           	 *  linkage (often results in cache misses) for auto arenas.
     .            .          .              .           .          .              .            .            .           	 */
    55 ( 0.00%)  11 ( 0.01%) 1 ( 0.01%)    11 ( 0.00%)  0          0             11 ( 0.00%)   0            0           	if (arena_is_auto(arena)) {
    11 ( 0.00%)   0          0              0           0          0              0            0            0           		return;
     .            .          .              .           .          .              .            .            .           	}
     .            .          .              .           .          .              .            .            .           	edata_list_active_append(&bin->slabs_full, slab);
    22 ( 0.00%)   0          0             22 ( 0.00%)  0          0              0            0            0           }
     .            .          .              .           .          .              .            .            .           
     .            .          .              .           .          .              .            .            .           static void
     .            .          .              .           .          .              .            .            .           arena_bin_slabs_full_remove(arena_t *arena, bin_t *bin, edata_t *slab) {
     .            .          .              .           .          .              .            .            .           	if (arena_is_auto(arena)) {
     .            .          .              .           .          .              .            .            .           		return;
     .            .          .              .           .          .              .            .            .           	}
     .            .          .              .           .          .              .            .            .           	edata_list_active_remove(&bin->slabs_full, slab);
     .            .          .              .           .          .              .            .            .           }
-- line 626 ----------------------------------------
-- line 824 ----------------------------------------
     .            .          .              .           .          .              .            .            .           	 * the metadata in this base anymore.
     .            .          .              .           .          .              .            .            .           	 */
     .            .          .              .           .          .              .            .            .           	arena_prepare_base_deletion(tsd, arena->base);
     .            .          .              .           .          .              .            .            .           	base_delete(tsd_tsdn(tsd), arena->base);
     .            .          .              .           .          .              .            .            .           }
     .            .          .              .           .          .              .            .            .           
     .            .          .              .           .          .              .            .            .           static edata_t *
     .            .          .              .           .          .              .            .            .           arena_slab_alloc(tsdn_t *tsdn, arena_t *arena, szind_t binind, unsigned binshard,
   372 ( 0.00%)  62 ( 0.04%) 2 ( 0.03%)    31 ( 0.00%)  0          0            217 ( 0.01%)   0            0               const bin_info_t *bin_info) {
   155 ( 0.00%)   0          0             62 ( 0.00%)  0          0             93 ( 0.00%)   0            0           	bool deferred_work_generated = false;
   124 ( 0.00%)   0          0              0           0          0             31 ( 0.00%)   0            0           	witness_assert_depth_to_rank(tsdn_witness_tsdp_get(tsdn),
     .            .          .              .           .          .              .            .            .           	    WITNESS_RANK_CORE, 0);
     .            .          .              .           .          .              .            .            .           
   279 ( 0.00%)  31 ( 0.02%) 1 ( 0.01%)    62 ( 0.00%)  0          0             93 ( 0.00%)   0            0           	bool guarded = san_slab_extent_decide_guard(tsdn,
     .            .          .              .           .          .              .            .            .           	    arena_get_ehooks(arena));
   589 ( 0.01%)  45 ( 0.03%) 1 ( 0.01%)   186 ( 0.01%) 13 ( 0.23%) 0            155 ( 0.00%)   0            0           	edata_t *slab = pa_alloc(tsdn, &arena->pa_shard, bin_info->slab_size,
     .            .          .              .           .          .              .            .            .           	    /* alignment */ PAGE, /* slab */ true, /* szind */ binind,
     .            .          .              .           .          .              .            .            .           	     /* zero */ false, guarded, &deferred_work_generated);
     .            .          .              .           .          .              .            .            .           
    93 ( 0.00%)   0          0             31 ( 0.00%)  0          0              0            0            0           	if (deferred_work_generated) {
     .            .          .              .           .          .              .            .            .           		arena_handle_deferred_work(tsdn, arena);
     .            .          .              .           .          .              .            .            .           	}
     .            .          .              .           .          .              .            .            .           
    62 ( 0.00%)   0          0             31 ( 0.00%)  0          0              0            0            0           	if (slab == NULL) {
     .            .          .              .           .          .              .            .            .           		return NULL;
     .            .          .              .           .          .              .            .            .           	}
   124 ( 0.00%)  31 ( 0.02%) 1 ( 0.01%)     0           0          0              0            0            0           	assert(edata_slab_get(slab));
     .            .          .              .           .          .              .            .            .           
     .            .          .              .           .          .              .            .            .           	/* Initialize slab internals. */
   124 ( 0.00%)  31 ( 0.02%) 1 ( 0.01%)    31 ( 0.00%)  0          0             62 ( 0.00%)   0            0           	slab_data_t *slab_data = edata_slab_data_get(slab);
   217 ( 0.00%)   0          0            124 ( 0.01%)  3 ( 0.05%) 0             31 ( 0.00%)   0            0           	edata_nfree_binshard_set(slab, bin_info->nregs, binshard);
   217 ( 0.00%)  31 ( 0.02%) 1 ( 0.01%)    62 ( 0.00%)  0          0             31 ( 0.00%)   0            0           	bitmap_init(slab_data->bitmap, &bin_info->bitmap_info, false);
     .            .          .              .           .          .              .            .            .           
    31 ( 0.00%)   0          0             31 ( 0.00%)  0          0              0            0            0           	return slab;
   155 ( 0.00%)   0          0            124 ( 0.01%)  0          0              0            0            0           }
     .            .          .              .           .          .              .            .            .           
     .            .          .              .           .          .              .            .            .           /*
     .            .          .              .           .          .              .            .            .            * Before attempting the _with_fresh_slab approaches below, the _no_fresh_slab
     .            .          .              .           .          .              .            .            .            * variants (i.e. through slabcur and nonfull) must be tried first.
     .            .          .              .           .          .              .            .            .            */
     .            .          .              .           .          .              .            .            .           static void
     .            .          .              .           .          .              .            .            .           arena_bin_refill_slabcur_with_fresh_slab(tsdn_t *tsdn, arena_t *arena,
   279 ( 0.00%)  31 ( 0.02%) 1 ( 0.01%)     0           0          0            186 ( 0.01%)   0            0               bin_t *bin, szind_t binind, edata_t *fresh_slab) {
   155 ( 0.00%)   0          0             62 ( 0.00%)  0          0             31 ( 0.00%)   0            0           	malloc_mutex_assert_owner(tsdn, &bin->lock);
     .            .          .              .           .          .              .            .            .           	/* Only called after slabcur and nonfull both failed. */
   124 ( 0.00%)   0          0              0           0          0              0            0            0           	assert(bin->slabcur == NULL);
   124 ( 0.00%)  31 ( 0.02%) 1 ( 0.01%)     0           0          0              0            0            0           	assert(edata_heap_first(&bin->slabs_nonfull) == NULL);
   124 ( 0.00%)  31 ( 0.02%) 1 ( 0.01%)     0           0          0              0            0            0           	assert(fresh_slab != NULL);
     .            .          .              .           .          .              .            .            .           
     .            .          .              .           .          .              .            .            .           	/* A new slab from arena_slab_alloc() */
   124 ( 0.00%)  31 ( 0.02%) 1 ( 0.01%)     0           0          0              0            0            0           	assert(edata_nfree_get(fresh_slab) == bin_infos[binind].nregs);
    93 ( 0.00%)  31 ( 0.02%) 1 ( 0.01%)     0           0          0              0            0            0           	if (config_stats) {
     .            .          .              .           .          .              .            .            .           		bin->stats.nslabs++;
     .            .          .              .           .          .              .            .            .           		bin->stats.curslabs++;
     .            .          .              .           .          .              .            .            .           	}
    93 ( 0.00%)  31 ( 0.02%) 1 ( 0.01%)    62 ( 0.00%)  0          0             31 ( 0.00%)   0            0           	bin->slabcur = fresh_slab;
    93 ( 0.00%)   0          0             62 ( 0.00%)  0          0              0            0            0           }
     .            .          .              .           .          .              .            .            .           
     .            .          .              .           .          .              .            .            .           /* Refill slabcur and then alloc using the fresh slab */
     .            .          .              .           .          .              .            .            .           static void *
     .            .          .              .           .          .              .            .            .           arena_bin_malloc_with_fresh_slab(tsdn_t *tsdn, arena_t *arena, bin_t *bin,
     .            .          .              .           .          .              .            .            .               szind_t binind, edata_t *fresh_slab) {
     .            .          .              .           .          .              .            .            .           	malloc_mutex_assert_owner(tsdn, &bin->lock);
     .            .          .              .           .          .              .            .            .           	arena_bin_refill_slabcur_with_fresh_slab(tsdn, arena, bin, binind,
     .            .          .              .           .          .              .            .            .           	    fresh_slab);
     .            .          .              .           .          .              .            .            .           
     .            .          .              .           .          .              .            .            .           	return arena_slab_reg_alloc(bin->slabcur, &bin_infos[binind]);
     .            .          .              .           .          .              .            .            .           }
     .            .          .              .           .          .              .            .            .           
     .            .          .              .           .          .              .            .            .           static bool
     .            .          .              .           .          .              .            .            .           arena_bin_refill_slabcur_no_fresh_slab(tsdn_t *tsdn, arena_t *arena,
   434 ( 0.00%)  97 ( 0.07%) 2 ( 0.03%)     0           0          0            248 ( 0.01%)   0            0               bin_t *bin) {
   310 ( 0.00%)   0          0            124 ( 0.01%)  0          0             62 ( 0.00%)   0            0           	malloc_mutex_assert_owner(tsdn, &bin->lock);
     .            .          .              .           .          .              .            .            .           	/* Only called after arena_slab_reg_alloc[_batch] failed. */
   248 ( 0.00%)   0          0              0           0          0              0            0            0           	assert(bin->slabcur == NULL || edata_nfree_get(bin->slabcur) == 0);
     .            .          .              .           .          .              .            .            .           
   248 ( 0.00%)  46 ( 0.03%) 1 ( 0.01%)   124 ( 0.01%)  0          0              0            0            0           	if (bin->slabcur != NULL) {
    77 ( 0.00%)   0          0             44 ( 0.00%)  0          0             11 ( 0.00%)   0            0           		arena_bin_slabs_full_insert(arena, bin, bin->slabcur);
     .            .          .              .           .          .              .            .            .           	}
     .            .          .              .           .          .              .            .            .           
     .            .          .              .           .          .              .            .            .           	/* Look for a usable slab. */
   310 ( 0.00%)  46 ( 0.03%) 1 ( 0.01%)   124 ( 0.01%)  0          0            124 ( 0.00%)   0            0           	bin->slabcur = arena_bin_slabs_nonfull_tryget(bin);
   248 ( 0.00%)   0          0              0           0          0              0            0            0           	assert(bin->slabcur == NULL || edata_nfree_get(bin->slabcur) > 0);
     .            .          .              .           .          .              .            .            .           
   248 ( 0.00%)  77 ( 0.05%) 1 ( 0.01%)   124 ( 0.01%)  0          0              0            0            0           	return (bin->slabcur == NULL);
   124 ( 0.00%)   0          0            124 ( 0.01%)  0          0              0            0            0           }
     .            .          .              .           .          .              .            .            .           
     .            .          .              .           .          .              .            .            .           bin_t *
     .            .          .              .           .          .              .            .            .           arena_bin_choose(tsdn_t *tsdn, arena_t *arena, szind_t binind,
   200 ( 0.00%)  14 ( 0.01%) 1 ( 0.01%)    20 ( 0.00%)  0          0            120 ( 0.00%)   0            0               unsigned *binshard_p) {
     .            .          .              .           .          .              .            .            .           	unsigned binshard;
   120 ( 0.00%)   0          0             20 ( 0.00%)  0          0             20 ( 0.00%)   0            0           	if (tsdn_null(tsdn) || tsd_arena_get(tsdn_tsd(tsdn)) == NULL) {
    40 ( 0.00%)  20 ( 0.01%) 1 ( 0.01%)    20 ( 0.00%)  0          0             20 ( 0.00%)   0            0           		binshard = 0;
     .            .          .              .           .          .              .            .            .           	} else {
    80 ( 0.00%)   0          0             40 ( 0.00%)  0          0             20 ( 0.00%)   0            0           		binshard = tsd_binshardsp_get(tsdn_tsd(tsdn))->binshard[binind];
     .            .          .              .           .          .              .            .            .           	}
    80 ( 0.00%)  20 ( 0.01%) 1 ( 0.01%)     0           0          0              0            0            0           	assert(binshard < bin_infos[binind].n_shards);
    40 ( 0.00%)  20 ( 0.01%) 1 ( 0.01%)    20 ( 0.00%)  0          0              0            0            0           	if (binshard_p != NULL) {
    60 ( 0.00%)   0          0             40 ( 0.00%)  0          0             20 ( 0.00%)   0            0           		*binshard_p = binshard;
     .            .          .              .           .          .              .            .            .           	}
   120 ( 0.00%)   0          0             60 ( 0.00%)  0          0             20 ( 0.00%)   0            0           	return arena_get_bin(arena, binind, binshard);
    40 ( 0.00%)   0          0             40 ( 0.00%)  0          0              0            0            0           }
     .            .          .              .           .          .              .            .            .           
     .            .          .              .           .          .              .            .            .           void
     .            .          .              .           .          .              .            .            .           arena_cache_bin_fill_small(tsdn_t *tsdn, arena_t *arena,
     .            .          .              .           .          .              .            .            .               cache_bin_t *cache_bin, cache_bin_info_t *cache_bin_info, szind_t binind,
   260 ( 0.00%)  40 ( 0.03%) 2 ( 0.03%)    20 ( 0.00%)  0          0            160 ( 0.01%)   0            0               const unsigned nfill) {
    80 ( 0.00%)   0          0              0           0          0              0            0            0           	assert(cache_bin_ncached_get_local(cache_bin, cache_bin_info) == 0);
     .            .          .              .           .          .              .            .            .           
   160 ( 0.00%)  20 ( 0.01%) 1 ( 0.01%)    20 ( 0.00%)  0          0             20 ( 0.00%)   0            0           	const bin_info_t *bin_info = &bin_infos[binind];
     .            .          .              .           .          .              .            .            .           
    40 ( 0.00%)   0          0             20 ( 0.00%)  0          0             20 ( 0.00%)   0            0           	CACHE_BIN_PTR_ARRAY_DECLARE(ptrs, nfill);
   140 ( 0.00%)  20 ( 0.01%) 1 ( 0.01%)    60 ( 0.00%)  0          0             20 ( 0.00%)   0            0           	cache_bin_init_ptr_array_for_fill(cache_bin, cache_bin_info, &ptrs,
     .            .          .              .           .          .              .            .            .           	    nfill);
     .            .          .              .           .          .              .            .            .           	/*
     .            .          .              .           .          .              .            .            .           	 * Bin-local resources are used first: 1) bin->slabcur, and 2) nonfull
     .            .          .              .           .          .              .            .            .           	 * slabs.  After both are exhausted, new slabs will be allocated through
     .            .          .              .           .          .              .            .            .           	 * arena_slab_alloc().
     .            .          .              .           .          .              .            .            .           	 *
     .            .          .              .           .          .              .            .            .           	 * Bin lock is only taken / released right before / after the while(...)
     .            .          .              .           .          .              .            .            .           	 * refill loop, with new slab allocation (which has its own locking)
-- line 944 ----------------------------------------
-- line 956 ----------------------------------------
     .            .          .              .           .          .              .            .            .           	 * made_progress below, initialized to true to jump start the first
     .            .          .              .           .          .              .            .            .           	 * iteration.
     .            .          .              .           .          .              .            .            .           	 *
     .            .          .              .           .          .              .            .            .           	 * In other words (again), the loop will only terminate early (i.e. stop
     .            .          .              .           .          .              .            .            .           	 * with filled < nfill) after going through the three steps: a) bin
     .            .          .              .           .          .              .            .            .           	 * local exhausted, b) unlock and slab_alloc returns null, c) re-lock
     .            .          .              .           .          .              .            .            .           	 * and bin local fails again.
     .            .          .              .           .          .              .            .            .           	 */
    20 ( 0.00%)   0          0              0           0          0             20 ( 0.00%)   0            0           	bool made_progress = true;
    20 ( 0.00%)   0          0              0           0          0             20 ( 0.00%)   0            0           	edata_t *fresh_slab = NULL;
    20 ( 0.00%)   0          0              0           0          0             20 ( 0.00%)   0            0           	bool alloc_and_retry = false;
    20 ( 0.00%)   0          0              0           0          0             20 ( 0.00%)   0            0           	unsigned filled = 0;
     .            .          .              .           .          .              .            .            .           	unsigned binshard;
   140 ( 0.00%)  15 ( 0.01%) 1 ( 0.01%)    60 ( 0.00%)  0          0             40 ( 0.00%)   0            0           	bin_t *bin = arena_bin_choose(tsdn, arena, binind, &binshard);
     .            .          .              .           .          .              .            .            .           
     .            .          .              .           .          .              .            .            .           label_refill:
   255 ( 0.00%)  31 ( 0.02%) 0            102 ( 0.00%)  0          0             51 ( 0.00%)   0            0           	malloc_mutex_lock(tsdn, &bin->lock);
     .            .          .              .           .          .              .            .            .           
   410 ( 0.00%)  95 ( 0.07%) 2 ( 0.03%)   226 ( 0.01%)  0          0              0            0            0           	while (filled < nfill) {
     .            .          .              .           .          .              .            .            .           		/* Try batch-fill from slabcur first. */
   279 ( 0.00%)   0          0            186 ( 0.01%) 19 ( 0.33%) 0             93 ( 0.00%)   0            0           		edata_t *slabcur = bin->slabcur;
   396 ( 0.00%)   0          0            135 ( 0.01%)  0          0             42 ( 0.00%)   0            0           		if (slabcur != NULL && edata_nfree_get(slabcur) > 0) {
    93 ( 0.00%)  31 ( 0.02%) 1 ( 0.01%)    62 ( 0.00%)  0          0             31 ( 0.00%)   0            0           			unsigned tofill = nfill - filled;
   124 ( 0.00%)   0          0             31 ( 0.00%)  0          0             62 ( 0.00%)   0            0           			unsigned nfree = edata_nfree_get(slabcur);
   155 ( 0.00%)   0          0             62 ( 0.00%)  0          0             31 ( 0.00%)   0            0           			unsigned cnt = tofill < nfree ? tofill : nfree;
     .            .          .              .           .          .              .            .            .           
   186 ( 0.00%)   0          0             93 ( 0.00%)  0          0             31 ( 0.00%)   0            0           			arena_slab_reg_alloc_batch(slabcur, bin_info, cnt,
    93 ( 0.00%)  31 ( 0.02%) 1 ( 0.01%)    62 ( 0.00%)  0          0              0            0            0           			    &ptrs.ptr[filled]);
    31 ( 0.00%)   0          0              0           0          0             31 ( 0.00%)   0            0           			made_progress = true;
    62 ( 0.00%)   0          0             62 ( 0.00%)  0          0              0            0            0           			filled += cnt;
    31 ( 0.00%)   0          0              0           0          0              0            0            0           			continue;
     .            .          .              .           .          .              .            .            .           		}
     .            .          .              .           .          .              .            .            .           		/* Next try refilling slabcur from nonfull slabs. */
   558 ( 0.01%)  48 ( 0.03%) 1 ( 0.01%)   186 ( 0.01%)  0          0             62 ( 0.00%)   0            0           		if (!arena_bin_refill_slabcur_no_fresh_slab(tsdn, arena, bin)) {
     .            .          .              .           .          .              .            .            .           			assert(bin->slabcur != NULL);
     .            .          .              .           .          .              .            .            .           			continue;
     .            .          .              .           .          .              .            .            .           		}
     .            .          .              .           .          .              .            .            .           
     .            .          .              .           .          .              .            .            .           		/* Then see if a new slab was reserved already. */
   124 ( 0.00%)  46 ( 0.03%) 1 ( 0.01%)    62 ( 0.00%)  0          0              0            0            0           		if (fresh_slab != NULL) {
   248 ( 0.00%)  31 ( 0.02%) 1 ( 0.01%)   155 ( 0.01%)  0          0             31 ( 0.00%)   0            0           			arena_bin_refill_slabcur_with_fresh_slab(tsdn, arena,
     .            .          .              .           .          .              .            .            .           			    bin, binind, fresh_slab);
   124 ( 0.00%)   0          0              0           0          0              0            0            0           			assert(bin->slabcur != NULL);
    31 ( 0.00%)  31 ( 0.02%) 0              0           0          0             31 ( 0.00%)   0            0           			fresh_slab = NULL;
    31 ( 0.00%)   0          0              0           0          0              0            0            0           			continue;
     .            .          .              .           .          .              .            .            .           		}
     .            .          .              .           .          .              .            .            .           
     .            .          .              .           .          .              .            .            .           		/* Try slab_alloc if made progress (or never did slab_alloc). */
    62 ( 0.00%)  14 ( 0.01%) 1 ( 0.01%)    31 ( 0.00%)  0          0              0            0            0           		if (made_progress) {
   124 ( 0.00%)  31 ( 0.02%) 1 ( 0.01%)     0           0          0              0            0            0           			assert(bin->slabcur == NULL);
   124 ( 0.00%)  31 ( 0.02%) 1 ( 0.01%)     0           0          0              0            0            0           			assert(fresh_slab == NULL);
    31 ( 0.00%)  31 ( 0.02%) 1 ( 0.01%)     0           0          0             31 ( 0.00%)   0            0           			alloc_and_retry = true;
     .            .          .              .           .          .              .            .            .           			/* Alloc a new slab then come back. */
    31 ( 0.00%)   0          0              0           0          0              0            0            0           			break;
     .            .          .              .           .          .              .            .            .           		}
     .            .          .              .           .          .              .            .            .           
     .            .          .              .           .          .              .            .            .           		/* OOM. */
     .            .          .              .           .          .              .            .            .           
     .            .          .              .           .          .              .            .            .           		assert(fresh_slab == NULL);
     .            .          .              .           .          .              .            .            .           		assert(!alloc_and_retry);
     .            .          .              .           .          .              .            .            .           		break;
     .            .          .              .           .          .              .            .            .           	} /* while (filled < nfill) loop. */
     .            .          .              .           .          .              .            .            .           
   153 ( 0.00%)   0          0              0           0          0              0            0            0           	if (config_stats && !alloc_and_retry) {
     .            .          .              .           .          .              .            .            .           		bin->stats.nmalloc += filled;
     .            .          .              .           .          .              .            .            .           		bin->stats.nrequests += cache_bin->tstats.nrequests;
     .            .          .              .           .          .              .            .            .           		bin->stats.curregs += filled;
     .            .          .              .           .          .              .            .            .           		bin->stats.nfills++;
     .            .          .              .           .          .              .            .            .           		cache_bin->tstats.nrequests = 0;
     .            .          .              .           .          .              .            .            .           	}
     .            .          .              .           .          .              .            .            .           
   255 ( 0.00%)  92 ( 0.06%) 2 ( 0.03%)   102 ( 0.00%)  0          0             51 ( 0.00%)   0            0           	malloc_mutex_unlock(tsdn, &bin->lock);
     .            .          .              .           .          .              .            .            .           
   102 ( 0.00%)   0          0             51 ( 0.00%)  0          0              0            0            0           	if (alloc_and_retry) {
   124 ( 0.00%)   0          0              0           0          0              0            0            0           		assert(fresh_slab == NULL);
   124 ( 0.00%)  31 ( 0.02%) 1 ( 0.01%)     0           0          0              0            0            0           		assert(filled < nfill);
   124 ( 0.00%)  62 ( 0.04%) 2 ( 0.03%)     0           0          0              0            0            0           		assert(made_progress);
     .            .          .              .           .          .              .            .            .           
   279 ( 0.00%)  45 ( 0.03%) 1 ( 0.01%)   155 ( 0.01%)  0          0             62 ( 0.00%)   0            0           		fresh_slab = arena_slab_alloc(tsdn, arena, binind, binshard,
     .            .          .              .           .          .              .            .            .           		    bin_info);
     .            .          .              .           .          .              .            .            .           		/* fresh_slab NULL case handled in the for loop. */
     .            .          .              .           .          .              .            .            .           
    31 ( 0.00%)  31 ( 0.02%) 1 ( 0.01%)     0           0          0             31 ( 0.00%)   0            0           		alloc_and_retry = false;
    31 ( 0.00%)   0          0              0           0          0             31 ( 0.00%)   0            0           		made_progress = false;
    31 ( 0.00%)   0          0              0           0          0              0            0            0           		goto label_refill;
     .            .          .              .           .          .              .            .            .           	}
    80 ( 0.00%)   0          0              0           0          0              0            0            0           	assert(filled == nfill || (fresh_slab == NULL && !made_progress));
     .            .          .              .           .          .              .            .            .           
     .            .          .              .           .          .              .            .            .           	/* Release if allocated but not used. */
    40 ( 0.00%)  20 ( 0.01%) 1 ( 0.01%)    20 ( 0.00%)  0          0              0            0            0           	if (fresh_slab != NULL) {
     .            .          .              .           .          .              .            .            .           		assert(edata_nfree_get(fresh_slab) == bin_info->nregs);
     .            .          .              .           .          .              .            .            .           		arena_slab_dalloc(tsdn, arena, fresh_slab);
     .            .          .              .           .          .              .            .            .           		fresh_slab = NULL;
     .            .          .              .           .          .              .            .            .           	}
     .            .          .              .           .          .              .            .            .           
   360 ( 0.00%)  40 ( 0.03%) 2 ( 0.03%)   160 ( 0.01%)  0          0            140 ( 0.00%)   0            0           	cache_bin_finish_fill(cache_bin, cache_bin_info, &ptrs, filled);
     .            .          .              .           .          .              .            .            .           	arena_decay_tick(tsdn, arena);
   120 ( 0.00%)   0          0             80 ( 0.00%)  0          0              0            0            0           }
     .            .          .              .           .          .              .            .            .           
     .            .          .              .           .          .              .            .            .           size_t
     .            .          .              .           .          .              .            .            .           arena_fill_small_fresh(tsdn_t *tsdn, arena_t *arena, szind_t binind,
     .            .          .              .           .          .              .            .            .               void **ptrs, size_t nfill, bool zero) {
     .            .          .              .           .          .              .            .            .           	assert(binind < SC_NBINS);
     .            .          .              .           .          .              .            .            .           	const bin_info_t *bin_info = &bin_infos[binind];
     .            .          .              .           .          .              .            .            .           	const size_t nregs = bin_info->nregs;
     .            .          .              .           .          .              .            .            .           	assert(nregs > 0);
-- line 1061 ----------------------------------------
-- line 1202 ----------------------------------------
     .            .          .              .           .          .              .            .            .           	if (likely(size <= SC_SMALL_MAXCLASS)) {
     .            .          .              .           .          .              .            .            .           		return arena_malloc_small(tsdn, arena, ind, zero);
     .            .          .              .           .          .              .            .            .           	}
     .            .          .              .           .          .              .            .            .           	return large_malloc(tsdn, arena, sz_index2size(ind), zero);
     .            .          .              .           .          .              .            .            .           }
     .            .          .              .           .          .              .            .            .           
     .            .          .              .           .          .              .            .            .           void *
     .            .          .              .           .          .              .            .            .           arena_palloc(tsdn_t *tsdn, arena_t *arena, size_t usize, size_t alignment,
    15 ( 0.00%)   2 ( 0.00%) 2 ( 0.03%)     1 ( 0.00%)  0          0              9 ( 0.00%)   2 ( 0.04%)   0               bool zero, tcache_t *tcache) {
     .            .          .              .           .          .              .            .            .           	void *ret;
     .            .          .              .           .          .              .            .            .           
     2 ( 0.00%)   0          0              1 ( 0.00%)  0          0              0            0            0           	if (usize <= SC_SMALL_MAXCLASS) {
     .            .          .              .           .          .              .            .            .           		/* Small; alignment doesn't require special slab placement. */
     .            .          .              .           .          .              .            .            .           
     .            .          .              .           .          .              .            .            .           		/* usize should be a result of sz_sa2u() */
     .            .          .              .           .          .              .            .            .           		assert((usize & (alignment - 1)) == 0);
     .            .          .              .           .          .              .            .            .           
     .            .          .              .           .          .              .            .            .           		/*
     .            .          .              .           .          .              .            .            .           		 * Small usize can't come from an alignment larger than a page.
     .            .          .              .           .          .              .            .            .           		 */
     .            .          .              .           .          .              .            .            .           		assert(alignment <= PAGE);
     .            .          .              .           .          .              .            .            .           
     .            .          .              .           .          .              .            .            .           		ret = arena_malloc(tsdn, arena, usize, sz_size2index(usize),
     .            .          .              .           .          .              .            .            .           		    zero, tcache, true);
     .            .          .              .           .          .              .            .            .           	} else {
     5 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)     1 ( 0.00%)  0          0              0            0            0           		if (likely(alignment <= CACHELINE)) {
     .            .          .              .           .          .              .            .            .           			ret = large_malloc(tsdn, arena, usize, zero);
     .            .          .              .           .          .              .            .            .           		} else {
     9 ( 0.00%)   3 ( 0.00%) 2 ( 0.03%)     5 ( 0.00%)  0          0              2 ( 0.00%)   1 ( 0.02%)   0           			ret = large_palloc(tsdn, arena, usize, alignment, zero);
     .            .          .              .           .          .              .            .            .           		}
     .            .          .              .           .          .              .            .            .           	}
     1 ( 0.00%)   0          0              1 ( 0.00%)  0          0              0            0            0           	return ret;
     6 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)     5 ( 0.00%)  0          0              0            0            0           }
     .            .          .              .           .          .              .            .            .           
     .            .          .              .           .          .              .            .            .           void
     .            .          .              .           .          .              .            .            .           arena_prof_promote(tsdn_t *tsdn, void *ptr, size_t usize) {
     .            .          .              .           .          .              .            .            .           	cassert(config_prof);
     .            .          .              .           .          .              .            .            .           	assert(ptr != NULL);
     .            .          .              .           .          .              .            .            .           	assert(isalloc(tsdn, ptr) == SC_LARGE_MINCLASS);
     .            .          .              .           .          .              .            .            .           	assert(usize <= SC_SMALL_MAXCLASS);
     .            .          .              .           .          .              .            .            .           
-- line 1242 ----------------------------------------
-- line 1389 ----------------------------------------
     .            .          .              .           .          .              .            .            .           	arena_t *arena = arena_get_from_edata(edata);
     .            .          .              .           .          .              .            .            .           
     .            .          .              .           .          .              .            .            .           	arena_dalloc_bin(tsdn, arena, edata, ptr);
     .            .          .              .           .          .              .            .            .           	arena_decay_tick(tsdn, arena);
     .            .          .              .           .          .              .            .            .           }
     .            .          .              .           .          .              .            .            .           
     .            .          .              .           .          .              .            .            .           bool
     .            .          .              .           .          .              .            .            .           arena_ralloc_no_move(tsdn_t *tsdn, void *ptr, size_t oldsize, size_t size,
 1,666 ( 0.02%)  85 ( 0.06%) 3 ( 0.04%)   196 ( 0.01%)  0          0            980 ( 0.03%)   7 ( 0.13%)   6 ( 0.14%)      size_t extra, bool zero, size_t *newsize) {
     .            .          .              .           .          .              .            .            .           	bool ret;
     .            .          .              .           .          .              .            .            .           	/* Calls with non-zero extra had to clamp extra. */
 1,568 ( 0.02%)  64 ( 0.04%) 2 ( 0.03%)   392 ( 0.02%)  0          0            588 ( 0.02%)   4 ( 0.08%)   4 ( 0.10%)  	assert(extra == 0 || size + extra <= SC_LARGE_MAXCLASS);
     .            .          .              .           .          .              .            .            .           
    98 ( 0.00%)   0          0              0           0          0             98 ( 0.00%)   2 ( 0.04%)   2 ( 0.05%)  	edata_t *edata = emap_edata_lookup(tsdn, &arena_emap_global, ptr);
   588 ( 0.01%)   0          0             98 ( 0.00%)  0          0              0            0            0           	if (unlikely(size > SC_LARGE_MAXCLASS)) {
     .            .          .              .           .          .              .            .            .           		ret = true;
   196 ( 0.00%)  97 ( 0.07%) 1 ( 0.01%)    98 ( 0.00%)  0          0             98 ( 0.00%)   4 ( 0.08%)   2 ( 0.05%)  		goto done;
     .            .          .              .           .          .              .            .            .           	}
     .            .          .              .           .          .              .            .            .           
    98 ( 0.00%)  15 ( 0.01%) 1 ( 0.01%)     0           0          0             98 ( 0.00%)   0            0           	size_t usize_min = sz_s2u(size);
   490 ( 0.01%)  94 ( 0.07%) 1 ( 0.01%)   196 ( 0.01%)  0          0            196 ( 0.01%)   0            0           	size_t usize_max = sz_s2u(size + extra);
   980 ( 0.01%)  31 ( 0.02%) 1 ( 0.01%)   196 ( 0.01%)  0          0              0            0            0           	if (likely(oldsize <= SC_SMALL_MAXCLASS && usize_min
    68 ( 0.00%)   0          0              0           0          0              0            0            0           	    <= SC_SMALL_MAXCLASS)) {
     .            .          .              .           .          .              .            .            .           		/*
     .            .          .              .           .          .              .            .            .           		 * Avoid moving the allocation if the size class can be left the
     .            .          .              .           .          .              .            .            .           		 * same.
     .            .          .              .           .          .              .            .            .           		 */
   392 ( 0.00%)   0          0              0           0          0              0            0            0           		assert(bin_infos[sz_size2index(oldsize)].reg_size ==
     .            .          .              .           .          .              .            .            .           		    oldsize);
   392 ( 0.00%)  31 ( 0.02%) 1 ( 0.01%)   196 ( 0.01%)  0          0             98 ( 0.00%)   7 ( 0.13%)   3 ( 0.07%)  		if ((usize_max > SC_SMALL_MAXCLASS
   196 ( 0.00%)  29 ( 0.02%) 1 ( 0.01%)     0           0          0              0            0            0           		    || sz_size2index(usize_max) != sz_size2index(oldsize))
    90 ( 0.00%)   0          0             60 ( 0.00%)  0          0              0            0            0           		    && (size > oldsize || usize_max < oldsize)) {
    30 ( 0.00%)   0          0              0           0          0             30 ( 0.00%)   0            0           			ret = true;
    30 ( 0.00%)   0          0              0           0          0              0            0            0           			goto done;
     .            .          .              .           .          .              .            .            .           		}
     .            .          .              .           .          .              .            .            .           
 1,020 ( 0.01%)   6 ( 0.00%) 2 ( 0.03%)   408 ( 0.02%)  0          0            544 ( 0.02%)   0            0           		arena_t *arena = arena_get_from_edata(edata);
     .            .          .              .           .          .              .            .            .           		arena_decay_tick(tsdn, arena);
    68 ( 0.00%)   0          0              0           0          0             68 ( 0.00%)   0            0           		ret = false;
     .            .          .              .           .          .              .            .            .           	} else if (oldsize >= SC_LARGE_MINCLASS
     .            .          .              .           .          .              .            .            .           	    && usize_max >= SC_LARGE_MINCLASS) {
     .            .          .              .           .          .              .            .            .           		ret = large_ralloc_no_move(tsdn, edata, usize_min, usize_max,
     .            .          .              .           .          .              .            .            .           		    zero);
     .            .          .              .           .          .              .            .            .           	} else {
     .            .          .              .           .          .              .            .            .           		ret = true;
     .            .          .              .           .          .              .            .            .           	}
     .            .          .              .           .          .              .            .            .           done:
   392 ( 0.00%)  58 ( 0.04%) 2 ( 0.03%)     0           0          0              0            0            0           	assert(edata == emap_edata_lookup(tsdn, &arena_emap_global, ptr));
   490 ( 0.01%)  42 ( 0.03%) 2 ( 0.03%)   196 ( 0.01%)  0          0            196 ( 0.01%)   0            0           	*newsize = edata_usize_get(edata);
     .            .          .              .           .          .              .            .            .           
    98 ( 0.00%)   0          0             98 ( 0.00%)  0          0              0            0            0           	return ret;
   588 ( 0.01%)   0          0            490 ( 0.02%)  0          0              0            0            0           }
     .            .          .              .           .          .              .            .            .           
     .            .          .              .           .          .              .            .            .           static void *
     .            .          .              .           .          .              .            .            .           arena_ralloc_move_helper(tsdn_t *tsdn, arena_t *arena, size_t usize,
   450 ( 0.00%)  28 ( 0.02%) 1 ( 0.01%)    30 ( 0.00%)  0          0            270 ( 0.01%)   3 ( 0.06%)   2 ( 0.05%)      size_t alignment, bool zero, tcache_t *tcache) {
    60 ( 0.00%)  28 ( 0.02%) 1 ( 0.01%)    30 ( 0.00%)  0          0              0            0            0           	if (alignment == 0) {
   120 ( 0.00%)  30 ( 0.02%) 1 ( 0.01%)    60 ( 0.00%)  0          0             30 ( 0.00%)   0            0           		return arena_malloc(tsdn, arena, usize, sz_size2index(usize),
     .            .          .              .           .          .              .            .            .           		    zero, tcache, true);
     .            .          .              .           .          .              .            .            .           	}
     .            .          .              .           .          .              .            .            .           	usize = sz_sa2u(usize, alignment);
     .            .          .              .           .          .              .            .            .           	if (unlikely(usize == 0 || usize > SC_LARGE_MAXCLASS)) {
     .            .          .              .           .          .              .            .            .           		return NULL;
     .            .          .              .           .          .              .            .            .           	}
     .            .          .              .           .          .              .            .            .           	return ipalloct(tsdn, usize, alignment, zero, tcache, arena);
   180 ( 0.00%)   5 ( 0.00%) 0            150 ( 0.01%)  0          0              0            0            0           }
     .            .          .              .           .          .              .            .            .           
     .            .          .              .           .          .              .            .            .           void *
     .            .          .              .           .          .              .            .            .           arena_ralloc(tsdn_t *tsdn, arena_t *arena, void *ptr, size_t oldsize,
     .            .          .              .           .          .              .            .            .               size_t size, size_t alignment, bool zero, tcache_t *tcache,
 1,960 ( 0.02%) 160 ( 0.11%) 3 ( 0.04%)   392 ( 0.02%)  0          0          1,176 ( 0.04%)   6 ( 0.11%)   5 ( 0.12%)      hook_ralloc_args_t *hook_args) {
   490 ( 0.01%)  31 ( 0.02%) 1 ( 0.01%)   196 ( 0.01%)  0          0            196 ( 0.01%)   6 ( 0.11%)   5 ( 0.12%)  	size_t usize = alignment == 0 ? sz_s2u(size) : sz_sa2u(size, alignment);
 1,078 ( 0.01%)  97 ( 0.07%) 1 ( 0.01%)   196 ( 0.01%)  0          0              0            0            0           	if (unlikely(usize == 0 || size > SC_LARGE_MAXCLASS)) {
     .            .          .              .           .          .              .            .            .           		return NULL;
     .            .          .              .           .          .              .            .            .           	}
     .            .          .              .           .          .              .            .            .           
   490 ( 0.01%)  28 ( 0.02%) 1 ( 0.01%)    98 ( 0.00%)  0          0              0            0            0           	if (likely(usize <= SC_SMALL_MAXCLASS)) {
     .            .          .              .           .          .              .            .            .           		/* Try to avoid moving the allocation. */
     .            .          .              .           .          .              .            .            .           		UNUSED size_t newsize;
 1,568 ( 0.02%)  15 ( 0.01%) 1 ( 0.01%)   490 ( 0.02%)  0          0            196 ( 0.01%)   2 ( 0.04%)   1 ( 0.02%)  		if (!arena_ralloc_no_move(tsdn, ptr, oldsize, usize, 0, zero,
     .            .          .              .           .          .              .            .            .           		    &newsize)) {
   748 ( 0.01%)   3 ( 0.00%) 0            408 ( 0.02%)  0          0             68 ( 0.00%)   0            0           			hook_invoke_expand(hook_args->is_realloc
    68 ( 0.00%)   0          0              0           0          0              0            0            0           			    ? hook_expand_realloc : hook_expand_rallocx,
     .            .          .              .           .          .              .            .            .           			    ptr, oldsize, usize, (uintptr_t)ptr,
   136 ( 0.00%)   0          0             68 ( 0.00%)  0          0              0            0            0           			    hook_args->args);
   136 ( 0.00%)   0          0             68 ( 0.00%)  0          0              0            0            0           			return ptr;
     .            .          .              .           .          .              .            .            .           		}
     .            .          .              .           .          .              .            .            .           	}
     .            .          .              .           .          .              .            .            .           
    60 ( 0.00%)  25 ( 0.02%) 1 ( 0.01%)    30 ( 0.00%)  0          0              0            0            0           	if (oldsize >= SC_LARGE_MINCLASS
     .            .          .              .           .          .              .            .            .           	    && usize >= SC_LARGE_MINCLASS) {
     .            .          .              .           .          .              .            .            .           		return large_ralloc(tsdn, arena, ptr, usize,
     .            .          .              .           .          .              .            .            .           		    alignment, zero, tcache, hook_args);
     .            .          .              .           .          .              .            .            .           	}
     .            .          .              .           .          .              .            .            .           
     .            .          .              .           .          .              .            .            .           	/*
     .            .          .              .           .          .              .            .            .           	 * size and oldsize are different enough that we need to move the
     .            .          .              .           .          .              .            .            .           	 * object.  In that case, fall back to allocating new space and copying.
     .            .          .              .           .          .              .            .            .           	 */
   330 ( 0.00%)  59 ( 0.04%) 2 ( 0.03%)   180 ( 0.01%)  0          0             60 ( 0.00%)   0            0           	void *ret = arena_ralloc_move_helper(tsdn, arena, usize, alignment,
     .            .          .              .           .          .              .            .            .           	    zero, tcache);
    60 ( 0.00%)   0          0             30 ( 0.00%)  0          0              0            0            0           	if (ret == NULL) {
     .            .          .              .           .          .              .            .            .           		return NULL;
     .            .          .              .           .          .              .            .            .           	}
     .            .          .              .           .          .              .            .            .           
   300 ( 0.00%)  28 ( 0.02%) 1 ( 0.01%)   120 ( 0.00%)  0          0             30 ( 0.00%)   0            0           	hook_invoke_alloc(hook_args->is_realloc
     .            .          .              .           .          .              .            .            .           	    ? hook_alloc_realloc : hook_alloc_rallocx, ret, (uintptr_t)ret,
    60 ( 0.00%)   0          0             30 ( 0.00%)  0          0              0            0            0           	    hook_args->args);
   300 ( 0.00%)  28 ( 0.02%) 1 ( 0.01%)    90 ( 0.00%)  0          0             30 ( 0.00%)   0            0           	hook_invoke_dalloc(hook_args->is_realloc
    60 ( 0.00%)   0          0             30 ( 0.00%)  0          0              0            0            0           	    ? hook_dalloc_realloc : hook_dalloc_rallocx, ptr, hook_args->args);
     .            .          .              .           .          .              .            .            .           
     .            .          .              .           .          .              .            .            .           	/*
     .            .          .              .           .          .              .            .            .           	 * Junk/zero-filling were already done by
     .            .          .              .           .          .              .            .            .           	 * ipalloc()/arena_malloc().
     .            .          .              .           .          .              .            .            .           	 */
   150 ( 0.00%)   0          0             60 ( 0.00%)  0          0             30 ( 0.00%)   0            0           	size_t copysize = (usize < oldsize) ? usize : oldsize;
   600 ( 0.01%)  56 ( 0.04%) 2 ( 0.03%)   270 ( 0.01%)  0          0            270 ( 0.01%)   9 ( 0.17%)   3 ( 0.07%)  	memcpy(ret, ptr, copysize);
     .            .          .              .           .          .              .            .            .           	isdalloct(tsdn, ptr, oldsize, tcache, NULL, true);
    30 ( 0.00%)   0          0             30 ( 0.00%)  0          0              0            0            0           	return ret;
   588 ( 0.01%)   3 ( 0.00%) 0            490 ( 0.02%)  0          0              0            0            0           }
     .            .          .              .           .          .              .            .            .           
     .            .          .              .           .          .              .            .            .           ehooks_t *
   160 ( 0.00%)  31 ( 0.02%) 1 ( 0.01%)     0           0          0             64 ( 0.00%)   0            0           arena_get_ehooks(arena_t *arena) {
   128 ( 0.00%)  32 ( 0.02%) 1 ( 0.01%)    64 ( 0.00%)  0          0             32 ( 0.00%)   0            0           	return base_ehooks_get(arena->base);
    64 ( 0.00%)   0          0             64 ( 0.00%)  0          0              0            0            0           }
     .            .          .              .           .          .              .            .            .           
     .            .          .              .           .          .              .            .            .           extent_hooks_t *
     .            .          .              .           .          .              .            .            .           arena_set_extent_hooks(tsd_t *tsd, arena_t *arena,
     .            .          .              .           .          .              .            .            .               extent_hooks_t *extent_hooks) {
     .            .          .              .           .          .              .            .            .           	background_thread_info_t *info;
     .            .          .              .           .          .              .            .            .           	if (have_background_thread) {
     .            .          .              .           .          .              .            .            .           		info = arena_background_thread_info_get(arena);
     .            .          .              .           .          .              .            .            .           		malloc_mutex_lock(tsd_tsdn(tsd), &info->mtx);
-- line 1521 ----------------------------------------
-- line 1540 ----------------------------------------
     .            .          .              .           .          .              .            .            .           	if (!have_dss) {
     .            .          .              .           .          .              .            .            .           		return (dss_prec != dss_prec_disabled);
     .            .          .              .           .          .              .            .            .           	}
     .            .          .              .           .          .              .            .            .           	atomic_store_u(&arena->dss_prec, (unsigned)dss_prec, ATOMIC_RELEASE);
     .            .          .              .           .          .              .            .            .           	return false;
     .            .          .              .           .          .              .            .            .           }
     .            .          .              .           .          .              .            .            .           
     .            .          .              .           .          .              .            .            .           ssize_t
    12 ( 0.00%)   2 ( 0.00%) 2 ( 0.03%)     2 ( 0.00%)  0          0              5 ( 0.00%)   0            0           arena_dirty_decay_ms_default_get(void) {
     .            .          .              .           .          .              .            .            .           	return atomic_load_zd(&dirty_decay_ms_default, ATOMIC_RELAXED);
     5 ( 0.00%)   0          0              4 ( 0.00%)  0          0              0            0            0           }
     .            .          .              .           .          .              .            .            .           
     .            .          .              .           .          .              .            .            .           bool
     8 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)     1 ( 0.00%)  0          0              3 ( 0.00%)   0            0           arena_dirty_decay_ms_default_set(ssize_t decay_ms) {
     6 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)     1 ( 0.00%)  0          0              1 ( 0.00%)   0            0           	if (!decay_ms_valid(decay_ms)) {
     7 ( 0.00%)   0          0              2 ( 0.00%)  0          0              4 ( 0.00%)   0            0           		return true;
     .            .          .              .           .          .              .            .            .           	}
     .            .          .              .           .          .              .            .            .           	atomic_store_zd(&dirty_decay_ms_default, decay_ms, ATOMIC_RELAXED);
     1 ( 0.00%)   0          0              0           0          0              0            0            0           	return false;
     5 ( 0.00%)   0          0              4 ( 0.00%)  0          0              0            0            0           }
     .            .          .              .           .          .              .            .            .           
     .            .          .              .           .          .              .            .            .           ssize_t
    12 ( 0.00%)   2 ( 0.00%) 1 ( 0.01%)     2 ( 0.00%)  0          0              5 ( 0.00%)   0            0           arena_muzzy_decay_ms_default_get(void) {
     .            .          .              .           .          .              .            .            .           	return atomic_load_zd(&muzzy_decay_ms_default, ATOMIC_RELAXED);
     5 ( 0.00%)   0          0              4 ( 0.00%)  0          0              0            0            0           }
     .            .          .              .           .          .              .            .            .           
     .            .          .              .           .          .              .            .            .           bool
     8 ( 0.00%)   2 ( 0.00%) 2 ( 0.03%)     1 ( 0.00%)  0          0              3 ( 0.00%)   0            0           arena_muzzy_decay_ms_default_set(ssize_t decay_ms) {
     6 ( 0.00%)   0          0              1 ( 0.00%)  0          0              1 ( 0.00%)   0            0           	if (!decay_ms_valid(decay_ms)) {
     7 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)     2 ( 0.00%)  0          0              4 ( 0.00%)   0            0           		return true;
     .            .          .              .           .          .              .            .            .           	}
     .            .          .              .           .          .              .            .            .           	atomic_store_zd(&muzzy_decay_ms_default, decay_ms, ATOMIC_RELAXED);
     1 ( 0.00%)   0          0              0           0          0              0            0            0           	return false;
     5 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)     4 ( 0.00%)  0          0              0            0            0           }
     .            .          .              .           .          .              .            .            .           
     .            .          .              .           .          .              .            .            .           bool
     .            .          .              .           .          .              .            .            .           arena_retain_grow_limit_get_set(tsd_t *tsd, arena_t *arena, size_t *old_limit,
     .            .          .              .           .          .              .            .            .               size_t *new_limit) {
     .            .          .              .           .          .              .            .            .           	assert(opt_retain);
     .            .          .              .           .          .              .            .            .           	return pac_retain_grow_limit_get_set(tsd_tsdn(tsd),
     .            .          .              .           .          .              .            .            .           	    &arena->pa_shard.pac, old_limit, new_limit);
     .            .          .              .           .          .              .            .            .           }
     .            .          .              .           .          .              .            .            .           
     .            .          .              .           .          .              .            .            .           unsigned
    20 ( 0.00%)   2 ( 0.00%) 2 ( 0.03%)     2 ( 0.00%)  0          0              8 ( 0.00%)   0            0           arena_nthreads_get(arena_t *arena, bool internal) {
    18 ( 0.00%)   0          0              6 ( 0.00%)  0          0              6 ( 0.00%)   0            0           	return atomic_load_u(&arena->nthreads[internal], ATOMIC_RELAXED);
    10 ( 0.00%)   0          0              8 ( 0.00%)  0          0              0            0            0           }
     .            .          .              .           .          .              .            .            .           
     .            .          .              .           .          .              .            .            .           void
    14 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)     0           0          0              6 ( 0.00%)   0            0           arena_nthreads_inc(arena_t *arena, bool internal) {
    20 ( 0.00%)   0          0              6 ( 0.00%)  0          0              8 ( 0.00%)   0            0           	atomic_fetch_add_u(&arena->nthreads[internal], 1, ATOMIC_RELAXED);
     6 ( 0.00%)   0          0              4 ( 0.00%)  0          0              0            0            0           }
     .            .          .              .           .          .              .            .            .           
     .            .          .              .           .          .              .            .            .           void
     .            .          .              .           .          .              .            .            .           arena_nthreads_dec(arena_t *arena, bool internal) {
     .            .          .              .           .          .              .            .            .           	atomic_fetch_sub_u(&arena->nthreads[internal], 1, ATOMIC_RELAXED);
     .            .          .              .           .          .              .            .            .           }
     .            .          .              .           .          .              .            .            .           
     .            .          .              .           .          .              .            .            .           arena_t *
    11 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)     1 ( 0.00%)  0          0              6 ( 0.00%)   0            0           arena_new(tsdn_t *tsdn, unsigned ind, const arena_config_t *config) {
     .            .          .              .           .          .              .            .            .           	arena_t *arena;
     .            .          .              .           .          .              .            .            .           	base_t *base;
     .            .          .              .           .          .              .            .            .           	unsigned i;
     .            .          .              .           .          .              .            .            .           
     2 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)     1 ( 0.00%)  0          0              0            0            0           	if (ind == 0) {
     3 ( 0.00%)   0          0              0           0          0              2 ( 0.00%)   0            0           		base = b0get();
     .            .          .              .           .          .              .            .            .           	} else {
     .            .          .              .           .          .              .            .            .           		base = base_new(tsdn, ind, config->extent_hooks,
     .            .          .              .           .          .              .            .            .           		    config->metadata_use_hooks);
     .            .          .              .           .          .              .            .            .           		if (base == NULL) {
     .            .          .              .           .          .              .            .            .           			return NULL;
     .            .          .              .           .          .              .            .            .           		}
     .            .          .              .           .          .              .            .            .           	}
     .            .          .              .           .          .              .            .            .           
     8 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)     1 ( 0.00%)  0          0              1 ( 0.00%)   0            0           	size_t arena_size = sizeof(arena_t) + sizeof(bin_t) * nbins_total;
     7 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)     3 ( 0.00%)  0          0              2 ( 0.00%)   0            0           	arena = (arena_t *)base_alloc(tsdn, base, arena_size, CACHELINE);
     2 ( 0.00%)   0          0              1 ( 0.00%)  0          0              0            0            0           	if (arena == NULL) {
     .            .          .              .           .          .              .            .            .           		goto label_error;
     .            .          .              .           .          .              .            .            .           	}
     .            .          .              .           .          .              .            .            .           
     6 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)     2 ( 0.00%)  0          0              4 ( 0.00%)   0            0           	atomic_store_u(&arena->nthreads[0], 0, ATOMIC_RELAXED);
     7 ( 0.00%)   0          0              2 ( 0.00%)  0          0              4 ( 0.00%)   0            0           	atomic_store_u(&arena->nthreads[1], 0, ATOMIC_RELAXED);
     2 ( 0.00%)   0          0              1 ( 0.00%)  0          0              1 ( 0.00%)   0            0           	arena->last_thd = NULL;
     .            .          .              .           .          .              .            .            .           
     3 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)     0           0          0              0            0            0           	if (config_stats) {
     .            .          .              .           .          .              .            .            .           		if (arena_stats_init(tsdn, &arena->stats)) {
     .            .          .              .           .          .              .            .            .           			goto label_error;
     .            .          .              .           .          .              .            .            .           		}
     .            .          .              .           .          .              .            .            .           
     .            .          .              .           .          .              .            .            .           		ql_new(&arena->tcache_ql);
     .            .          .              .           .          .              .            .            .           		ql_new(&arena->cache_bin_array_descriptor_ql);
     .            .          .              .           .          .              .            .            .           		if (malloc_mutex_init(&arena->tcache_ql_mtx, "tcache_ql",
     .            .          .              .           .          .              .            .            .           		    WITNESS_RANK_TCACHE_QL, malloc_mutex_rank_exclusive)) {
     .            .          .              .           .          .              .            .            .           			goto label_error;
     .            .          .              .           .          .              .            .            .           		}
     .            .          .              .           .          .              .            .            .           	}
     .            .          .              .           .          .              .            .            .           
     8 ( 0.00%)   2 ( 0.00%) 2 ( 0.03%)     2 ( 0.00%)  0          0              5 ( 0.00%)   0            0           	atomic_store_u(&arena->dss_prec, (unsigned)extent_dss_prec_get(),
     .            .          .              .           .          .              .            .            .           	    ATOMIC_RELAXED);
     .            .          .              .           .          .              .            .            .           
     4 ( 0.00%)   0          0              1 ( 0.00%)  0          0              1 ( 0.00%)   0            0           	edata_list_active_init(&arena->large);
     9 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)     1 ( 0.00%)  0          0              1 ( 0.00%)   0            0           	if (malloc_mutex_init(&arena->large_mtx, "arena_large",
     .            .          .              .           .          .              .            .            .           	    WITNESS_RANK_ARENA_LARGE, malloc_mutex_rank_exclusive)) {
     .            .          .              .           .          .              .            .            .           		goto label_error;
     .            .          .              .           .          .              .            .            .           	}
     .            .          .              .           .          .              .            .            .           
     .            .          .              .           .          .              .            .            .           	nstime_t cur_time;
     3 ( 0.00%)   0          0              0           0          0              1 ( 0.00%)   0            0           	nstime_init_update(&cur_time);
    27 ( 0.00%)   2 ( 0.00%) 2 ( 0.03%)     6 ( 0.00%)  0          0              9 ( 0.00%)   0            0           	if (pa_shard_init(tsdn, &arena->pa_shard, &arena_pa_central_global,
     .            .          .              .           .          .              .            .            .           	    &arena_emap_global, base, ind, &arena->stats.pa_shard_stats,
     .            .          .              .           .          .              .            .            .           	    LOCKEDINT_MTX(arena->stats.mtx), &cur_time, oversize_threshold,
     .            .          .              .           .          .              .            .            .           	    arena_dirty_decay_ms_default_get(),
     .            .          .              .           .          .              .            .            .           	    arena_muzzy_decay_ms_default_get())) {
     .            .          .              .           .          .              .            .            .           		goto label_error;
     .            .          .              .           .          .              .            .            .           	}
     .            .          .              .           .          .              .            .            .           
     .            .          .              .           .          .              .            .            .           	/* Initialize bins. */
     7 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)     2 ( 0.00%)  0          0              4 ( 0.00%)   2 ( 0.04%)   0           	atomic_store_u(&arena->binshard_next, 0, ATOMIC_RELEASE);
   149 ( 0.00%)   2 ( 0.00%) 2 ( 0.03%)   110 ( 0.00%)  1 ( 0.02%) 0              1 ( 0.00%)   0            0           	for (i = 0; i < nbins_total; i++) {
   432 ( 0.00%)   0          0             72 ( 0.00%)  0          0             72 ( 0.00%)   1 ( 0.02%)   0           		bool err = bin_init(&arena->bins[i]);
    72 ( 0.00%)   0          0             36 ( 0.00%)  0          0              0            0            0           		if (err) {
     .            .          .              .           .          .              .            .            .           			goto label_error;
     .            .          .              .           .          .              .            .            .           		}
     .            .          .              .           .          .              .            .            .           	}
     .            .          .              .           .          .              .            .            .           
     3 ( 0.00%)   0          0              2 ( 0.00%)  0          0              1 ( 0.00%)   0            0           	arena->base = base;
     .            .          .              .           .          .              .            .            .           	/* Set arena before creating background threads. */
     5 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)     2 ( 0.00%)  0          0              1 ( 0.00%)   0            0           	arena_set(ind, arena);
     3 ( 0.00%)   0          0              2 ( 0.00%)  0          0              1 ( 0.00%)   0            0           	arena->ind = ind;
     .            .          .              .           .          .              .            .            .           
     4 ( 0.00%)   0          0              1 ( 0.00%)  0          0              1 ( 0.00%)   0            0           	nstime_init_update(&arena->create_time);
     .            .          .              .           .          .              .            .            .           
     .            .          .              .           .          .              .            .            .           	/*
     .            .          .              .           .          .              .            .            .           	 * We turn on the HPA if set to.  There are two exceptions:
     .            .          .              .           .          .              .            .            .           	 * - Custom extent hooks (we should only return memory allocated from
     .            .          .              .           .          .              .            .            .           	 *   them in that case).
     .            .          .              .           .          .              .            .            .           	 * - Arena 0 initialization.  In this case, we're mid-bootstrapping, and
     .            .          .              .           .          .              .            .            .           	 *   so arena_hpa_global is not yet initialized.
     .            .          .              .           .          .              .            .            .           	 */
     4 ( 0.00%)   0          0              1 ( 0.00%)  1 ( 0.02%) 0              0            0            0           	if (opt_hpa && ehooks_are_default(base_ehooks_get(base)) && ind != 0) {
     .            .          .              .           .          .              .            .            .           		hpa_shard_opts_t hpa_shard_opts = opt_hpa_opts;
     .            .          .              .           .          .              .            .            .           		hpa_shard_opts.deferral_allowed = background_thread_enabled();
     .            .          .              .           .          .              .            .            .           		if (pa_shard_enable_hpa(tsdn, &arena->pa_shard,
     .            .          .              .           .          .              .            .            .           		    &hpa_shard_opts, &opt_hpa_sec_opts)) {
     .            .          .              .           .          .              .            .            .           			goto label_error;
     .            .          .              .           .          .              .            .            .           		}
     .            .          .              .           .          .              .            .            .           	}
     .            .          .              .           .          .              .            .            .           
     .            .          .              .           .          .              .            .            .           	/* We don't support reentrancy for arena 0 bootstrapping. */
     2 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)     1 ( 0.00%)  0          0              0            0            0           	if (ind != 0) {
     .            .          .              .           .          .              .            .            .           		/*
     .            .          .              .           .          .              .            .            .           		 * If we're here, then arena 0 already exists, so bootstrapping
     .            .          .              .           .          .              .            .            .           		 * is done enough that we should have tsd.
     .            .          .              .           .          .              .            .            .           		 */
     .            .          .              .           .          .              .            .            .           		assert(!tsdn_null(tsdn));
     .            .          .              .           .          .              .            .            .           		pre_reentrancy(tsdn_tsd(tsdn), arena);
     .            .          .              .           .          .              .            .            .           		if (test_hooks_arena_new_hook) {
     .            .          .              .           .          .              .            .            .           			test_hooks_arena_new_hook();
     .            .          .              .           .          .              .            .            .           		}
     .            .          .              .           .          .              .            .            .           		post_reentrancy(tsdn_tsd(tsdn));
     .            .          .              .           .          .              .            .            .           	}
     .            .          .              .           .          .              .            .            .           
     2 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)     1 ( 0.00%)  0          0              0            0            0           	return arena;
     .            .          .              .           .          .              .            .            .           label_error:
     .            .          .              .           .          .              .            .            .           	if (ind != 0) {
     .            .          .              .           .          .              .            .            .           		base_delete(tsdn, base);
     .            .          .              .           .          .              .            .            .           	}
     .            .          .              .           .          .              .            .            .           	return NULL;
     6 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)     5 ( 0.00%)  1 ( 0.02%) 0              0            0            0           }
     .            .          .              .           .          .              .            .            .           
     .            .          .              .           .          .              .            .            .           arena_t *
     .            .          .              .           .          .              .            .            .           arena_choose_huge(tsd_t *tsd) {
     .            .          .              .           .          .              .            .            .           	/* huge_arena_ind can be 0 during init (will use a0). */
     .            .          .              .           .          .              .            .            .           	if (huge_arena_ind == 0) {
     .            .          .              .           .          .              .            .            .           		assert(!malloc_initialized());
     .            .          .              .           .          .              .            .            .           	}
     .            .          .              .           .          .              .            .            .           
-- line 1716 ----------------------------------------
-- line 1737 ----------------------------------------
     .            .          .              .           .          .              .            .            .           			    extent_state_muzzy, 0);
     .            .          .              .           .          .              .            .            .           		}
     .            .          .              .           .          .              .            .            .           	}
     .            .          .              .           .          .              .            .            .           
     .            .          .              .           .          .              .            .            .           	return huge_arena;
     .            .          .              .           .          .              .            .            .           }
     .            .          .              .           .          .              .            .            .           
     .            .          .              .           .          .              .            .            .           bool
     4 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)     0           0          0              1 ( 0.00%)   0            0           arena_init_huge(void) {
     .            .          .              .           .          .              .            .            .           	bool huge_enabled;
     .            .          .              .           .          .              .            .            .           
     .            .          .              .           .          .              .            .            .           	/* The threshold should be large size class. */
     6 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)     1 ( 0.00%)  0          0              0            0            0           	if (opt_oversize_threshold > SC_LARGE_MAXCLASS ||
     1 ( 0.00%)   0          0              1 ( 0.00%)  0          0              0            0            0           	    opt_oversize_threshold < SC_LARGE_MINCLASS) {
     .            .          .              .           .          .              .            .            .           		opt_oversize_threshold = 0;
     .            .          .              .           .          .              .            .            .           		oversize_threshold = SC_LARGE_MAXCLASS + PAGE;
     .            .          .              .           .          .              .            .            .           		huge_enabled = false;
     .            .          .              .           .          .              .            .            .           	} else {
     .            .          .              .           .          .              .            .            .           		/* Reserve the index for the huge arena. */
     2 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)     0           0          0              2 ( 0.00%)   0            0           		huge_arena_ind = narenas_total_get();
     2 ( 0.00%)   0          0              1 ( 0.00%)  0          0              1 ( 0.00%)   0            0           		oversize_threshold = opt_oversize_threshold;
     1 ( 0.00%)   0          0              0           0          0              1 ( 0.00%)   0            0           		huge_enabled = true;
     .            .          .              .           .          .              .            .            .           	}
     .            .          .              .           .          .              .            .            .           
     1 ( 0.00%)   0          0              1 ( 0.00%)  0          0              0            0            0           	return huge_enabled;
     2 ( 0.00%)   0          0              2 ( 0.00%)  0          0              0            0            0           }
     .            .          .              .           .          .              .            .            .           
     .            .          .              .           .          .              .            .            .           bool
     .            .          .              .           .          .              .            .            .           arena_is_huge(unsigned arena_ind) {
     .            .          .              .           .          .              .            .            .           	if (huge_arena_ind == 0) {
     .            .          .              .           .          .              .            .            .           		return false;
     .            .          .              .           .          .              .            .            .           	}
     .            .          .              .           .          .              .            .            .           	return (arena_ind == huge_arena_ind);
     .            .          .              .           .          .              .            .            .           }
     .            .          .              .           .          .              .            .            .           
     .            .          .              .           .          .              .            .            .           bool
     8 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)     0           0          0              4 ( 0.00%)   0            0           arena_boot(sc_data_t *sc_data, base_t *base, bool hpa) {
     3 ( 0.00%)   0          0              1 ( 0.00%)  1 ( 0.02%) 0              1 ( 0.00%)   0            0           	arena_dirty_decay_ms_default_set(opt_dirty_decay_ms);
     3 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)     1 ( 0.00%)  0          0              1 ( 0.00%)   0            0           	arena_muzzy_decay_ms_default_set(opt_muzzy_decay_ms);
   112 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)    73 ( 0.00%)  0          0              1 ( 0.00%)   0            0           	for (unsigned i = 0; i < SC_NBINS; i++) {
   360 ( 0.00%)   0          0             72 ( 0.00%)  0          0             36 ( 0.00%)   0            0           		sc_t *sc = &sc_data->sc[i];
   288 ( 0.00%)   0          0             36 ( 0.00%)  0          0             36 ( 0.00%)   0            0           		div_init(&arena_binind_div_info[i],
   504 ( 0.01%)   1 ( 0.00%) 1 ( 0.01%)   216 ( 0.01%)  0          0              0            0            0           		    (1U << sc->lg_base) + (sc->ndelta << sc->lg_delta));
     .            .          .              .           .          .              .            .            .           	}
     .            .          .              .           .          .              .            .            .           
     1 ( 0.00%)   0          0              0           0          0              1 ( 0.00%)   0            0           	uint32_t cur_offset = (uint32_t)offsetof(arena_t, bins);
   112 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)    73 ( 0.00%)  0          0              1 ( 0.00%)   0            0           	for (szind_t i = 0; i < SC_NBINS; i++) {
   180 ( 0.00%)   0          0             72 ( 0.00%)  0          0             36 ( 0.00%)   1 ( 0.02%)   1 ( 0.02%)  		arena_bin_offsets[i] = cur_offset;
   432 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)   108 ( 0.00%)  1 ( 0.02%) 1 ( 0.03%)    36 ( 0.00%)   0            0           		nbins_total += bin_infos[i].n_shards;
   396 ( 0.00%)   0          0            108 ( 0.00%)  0          0              0            0            0           		cur_offset += (uint32_t)(bin_infos[i].n_shards * sizeof(bin_t));
     .            .          .              .           .          .              .            .            .           	}
     7 ( 0.00%)   0          0              2 ( 0.00%)  0          0              1 ( 0.00%)   0            0           	return pa_central_init(&arena_pa_central_global, base, hpa,
     .            .          .              .           .          .              .            .            .           	    &hpa_hooks_default);
     2 ( 0.00%)   0          0              2 ( 0.00%)  0          0              0            0            0           }
     .            .          .              .           .          .              .            .            .           
     .            .          .              .           .          .              .            .            .           void
     .            .          .              .           .          .              .            .            .           arena_prefork0(tsdn_t *tsdn, arena_t *arena) {
     .            .          .              .           .          .              .            .            .           	pa_shard_prefork0(tsdn, &arena->pa_shard);
     .            .          .              .           .          .              .            .            .           }
     .            .          .              .           .          .              .            .            .           
     .            .          .              .           .          .              .            .            .           void
     .            .          .              .           .          .              .            .            .           arena_prefork1(tsdn_t *tsdn, arena_t *arena) {
-- line 1798 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/ashy5000/dev/cryptocurrency/contracts/target/debug/build/tikv-jemalloc-sys-7365f40ecb99e085/out/build/src/base.c
--------------------------------------------------------------------------------
Ir              I1mr        ILmr       Dr             D1mr       DLmr       Dw             D1mw       DLmw       

-- line 26 ----------------------------------------
     .           .          .              .          .          .              .          .          .           	"disabled",
     .           .          .              .          .          .              .          .          .           	"auto",
     .           .          .              .          .          .              .          .          .           	"always"
     .           .          .              .          .          .              .          .          .           };
     .           .          .              .          .          .              .          .          .           
     .           .          .              .          .          .              .          .          .           /******************************************************************************/
     .           .          .              .          .          .              .          .          .           
     .           .          .              .          .          .              .          .          .           static inline bool
     4 ( 0.00%)  1 ( 0.00%) 1 ( 0.01%)     0          0          0              2 ( 0.00%) 0          0           metadata_thp_madvise(void) {
    10 ( 0.00%)  0          0              0          0          0              2 ( 0.00%) 0          0           	return (metadata_thp_enabled() &&
     .           .          .              .          .          .              .          .          .           	    (init_system_thp_mode == thp_mode_default));
     4 ( 0.00%)  0          0              4 ( 0.00%) 0          0              0          0          0           }
     .           .          .              .          .          .              .          .          .           
     .           .          .              .          .          .              .          .          .           static void *
    22 ( 0.00%)  4 ( 0.00%) 2 ( 0.03%)     2 ( 0.00%) 0          0             12 ( 0.00%) 0          0           base_map(tsdn_t *tsdn, ehooks_t *ehooks, unsigned ind, size_t size) {
     .           .          .              .          .          .              .          .          .           	void *addr;
     2 ( 0.00%)  0          0              0          0          0              2 ( 0.00%) 0          0           	bool zero = true;
     2 ( 0.00%)  0          0              0          0          0              2 ( 0.00%) 0          0           	bool commit = true;
     .           .          .              .          .          .              .          .          .           
     .           .          .              .          .          .              .          .          .           	/* Use huge page sizes and alignment regardless of opt_metadata_thp. */
     8 ( 0.00%)  0          0              0          0          0              0          0          0           	assert(size == HUGEPAGE_CEILING(size));
     2 ( 0.00%)  2 ( 0.00%) 1 ( 0.01%)     0          0          0              2 ( 0.00%) 0          0           	size_t alignment = HUGEPAGE;
    10 ( 0.00%)  2 ( 0.00%) 1 ( 0.01%)     2 ( 0.00%) 0          0              2 ( 0.00%) 0          0           	if (ehooks_are_default(ehooks)) {
    18 ( 0.00%)  0          0              4 ( 0.00%) 0          0              4 ( 0.00%) 0          0           		addr = extent_alloc_mmap(NULL, size, alignment, &zero, &commit);
    10 ( 0.00%)  0          0              2 ( 0.00%) 0          0              0          0          0           		if (have_madvise_huge && addr) {
    12 ( 0.00%)  2 ( 0.00%) 1 ( 0.01%)     4 ( 0.00%) 0          0              2 ( 0.00%) 0          0           			pages_set_thp_state(addr, size);
     .           .          .              .          .          .              .          .          .           		}
     .           .          .              .          .          .              .          .          .           	} else {
     .           .          .              .          .          .              .          .          .           		addr = ehooks_alloc(tsdn, ehooks, NULL, size, alignment, &zero,
     .           .          .              .          .          .              .          .          .           		    &commit);
     .           .          .              .          .          .              .          .          .           	}
     .           .          .              .          .          .              .          .          .           
     2 ( 0.00%)  2 ( 0.00%) 1 ( 0.01%)     2 ( 0.00%) 0          0              0          0          0           	return addr;
    10 ( 0.00%)  0          0              8 ( 0.00%) 0          0              0          0          0           }
     .           .          .              .          .          .              .          .          .           
     .           .          .              .          .          .              .          .          .           static void
     .           .          .              .          .          .              .          .          .           base_unmap(tsdn_t *tsdn, ehooks_t *ehooks, unsigned ind, void *addr,
     .           .          .              .          .          .              .          .          .               size_t size) {
     .           .          .              .          .          .              .          .          .           	/*
     .           .          .              .          .          .              .          .          .           	 * Cascade through dalloc, decommit, purge_forced, and purge_lazy,
     .           .          .              .          .          .              .          .          .           	 * stopping at first success.  This cascade is performed for consistency
     .           .          .              .          .          .              .          .          .           	 * with the cascade in extent_dalloc_wrapper() because an application's
-- line 67 ----------------------------------------
-- line 107 ----------------------------------------
     .           .          .              .          .          .              .          .          .           		assert(((uintptr_t)addr & HUGEPAGE_MASK) == 0 &&
     .           .          .              .          .          .              .          .          .           		    (size & HUGEPAGE_MASK) == 0);
     .           .          .              .          .          .              .          .          .           		pages_nohuge(addr, size);
     .           .          .              .          .          .              .          .          .           	}
     .           .          .              .          .          .              .          .          .           }
     .           .          .              .          .          .              .          .          .           
     .           .          .              .          .          .              .          .          .           static void
     .           .          .              .          .          .              .          .          .           base_edata_init(size_t *extent_sn_next, edata_t *edata, void *addr,
    16 ( 0.00%)  2 ( 0.00%) 1 ( 0.01%)     0          0          0             10 ( 0.00%) 0          0               size_t size) {
     .           .          .              .          .          .              .          .          .           	size_t sn;
     .           .          .              .          .          .              .          .          .           
     6 ( 0.00%)  2 ( 0.00%) 1 ( 0.01%)     4 ( 0.00%) 0          0              2 ( 0.00%) 0          0           	sn = *extent_sn_next;
    10 ( 0.00%)  0          0              6 ( 0.00%) 0          0              2 ( 0.00%) 0          0           	(*extent_sn_next)++;
     .           .          .              .          .          .              .          .          .           
    12 ( 0.00%)  0          0              8 ( 0.00%) 0          0              2 ( 0.00%) 0          0           	edata_binit(edata, addr, size, sn);
     6 ( 0.00%)  0          0              4 ( 0.00%) 0          0              0          0          0           }
     .           .          .              .          .          .              .          .          .           
     .           .          .              .          .          .              .          .          .           static size_t
     .           .          .              .          .          .              .          .          .           base_get_num_blocks(base_t *base, bool with_new_block) {
     .           .          .              .          .          .              .          .          .           	base_block_t *b = base->blocks;
     .           .          .              .          .          .              .          .          .           	assert(b != NULL);
     .           .          .              .          .          .              .          .          .           
     .           .          .              .          .          .              .          .          .           	size_t n_blocks = with_new_block ? 2 : 1;
     .           .          .              .          .          .              .          .          .           	while (b->next != NULL) {
-- line 130 ----------------------------------------
-- line 168 ----------------------------------------
     .           .          .              .          .          .              .          .          .           		}
     .           .          .              .          .          .              .          .          .           		block = block->next;
     .           .          .              .          .          .              .          .          .           		assert(block == NULL || (base_ind_get(base) == 0));
     .           .          .              .          .          .              .          .          .           	}
     .           .          .              .          .          .              .          .          .           }
     .           .          .              .          .          .              .          .          .           
     .           .          .              .          .          .              .          .          .           static void *
     .           .          .              .          .          .              .          .          .           base_extent_bump_alloc_helper(edata_t *edata, size_t *gap_size, size_t size,
   380 ( 0.00%) 33 ( 0.02%) 1 ( 0.01%)     0          0          0            266 ( 0.01%) 0          0               size_t alignment) {
     .           .          .              .          .          .              .          .          .           	void *ret;
     .           .          .              .          .          .              .          .          .           
   152 ( 0.00%)  0          0              0          0          0              0          0          0           	assert(alignment == ALIGNMENT_CEILING(alignment, QUANTUM));
   152 ( 0.00%) 34 ( 0.02%) 1 ( 0.01%)     0          0          0              0          0          0           	assert(size == ALIGNMENT_CEILING(size, alignment));
     .           .          .              .          .          .              .          .          .           
   494 ( 0.01%) 68 ( 0.05%) 2 ( 0.03%)   152 ( 0.01%) 0          0             76 ( 0.00%) 0          0           	*gap_size = ALIGNMENT_CEILING((uintptr_t)edata_addr_get(edata),
   190 ( 0.00%)  0          0             38 ( 0.00%) 0          0             38 ( 0.00%) 0          0           	    alignment) - (uintptr_t)edata_addr_get(edata);
   304 ( 0.00%) 34 ( 0.02%) 1 ( 0.01%)   114 ( 0.00%) 0          0             76 ( 0.00%) 0          0           	ret = (void *)((uintptr_t)edata_addr_get(edata) + *gap_size);
   152 ( 0.00%)  0          0              0          0          0              0          0          0           	assert(edata_bsize_get(edata) >= *gap_size + size);
   646 ( 0.01%) 67 ( 0.05%) 2 ( 0.03%)   152 ( 0.01%) 0          0            114 ( 0.00%) 0          0           	edata_binit(edata, (void *)((uintptr_t)edata_addr_get(edata) +
   418 ( 0.00%) 34 ( 0.02%) 1 ( 0.01%)   228 ( 0.01%) 0          0             38 ( 0.00%) 0          0           	    *gap_size + size), edata_bsize_get(edata) - *gap_size - size,
     .           .          .              .          .          .              .          .          .           	    edata_sn_get(edata));
    38 ( 0.00%)  0          0             38 ( 0.00%) 0          0              0          0          0           	return ret;
   190 ( 0.00%)  0          0            152 ( 0.01%) 0          0              0          0          0           }
     .           .          .              .          .          .              .          .          .           
     .           .          .              .          .          .              .          .          .           static void
     .           .          .              .          .          .              .          .          .           base_extent_bump_alloc_post(base_t *base, edata_t *edata, size_t gap_size,
   342 ( 0.00%)  0          0              0          0          0            228 ( 0.01%) 0          0               void *addr, size_t size) {
   190 ( 0.00%) 33 ( 0.02%) 1 ( 0.01%)    38 ( 0.00%) 0          0             38 ( 0.00%) 0          0           	if (edata_bsize_get(edata) > 0) {
     .           .          .              .          .          .              .          .          .           		/*
     .           .          .              .          .          .              .          .          .           		 * Compute the index for the largest size class that does not
     .           .          .              .          .          .              .          .          .           		 * exceed extent's size.
     .           .          .              .          .          .              .          .          .           		 */
    76 ( 0.00%)  0          0              0          0          0             38 ( 0.00%) 0          0           		szind_t index_floor =
   190 ( 0.00%)  0          0             38 ( 0.00%) 0          0             76 ( 0.00%) 0          0           		    sz_size2index(edata_bsize_get(edata) + 1) - 1;
   418 ( 0.00%) 34 ( 0.02%) 1 ( 0.01%)   114 ( 0.00%) 0          0             38 ( 0.00%) 0          0           		edata_heap_insert(&base->avail[index_floor], edata);
     .           .          .              .          .          .              .          .          .           	}
     .           .          .              .          .          .              .          .          .           
   114 ( 0.00%)  0          0              0          0          0              0          0          0           	if (config_stats) {
     .           .          .              .          .          .              .          .          .           		base->allocated += size;
     .           .          .              .          .          .              .          .          .           		/*
     .           .          .              .          .          .              .          .          .           		 * Add one PAGE to base_resident for every page boundary that is
     .           .          .              .          .          .              .          .          .           		 * crossed by the new allocation. Adjust n_thp similarly when
     .           .          .              .          .          .              .          .          .           		 * metadata_thp is enabled.
     .           .          .              .          .          .              .          .          .           		 */
     .           .          .              .          .          .              .          .          .           		base->resident += PAGE_CEILING((uintptr_t)addr + size) -
     .           .          .              .          .          .              .          .          .           		    PAGE_CEILING((uintptr_t)addr - gap_size);
-- line 213 ----------------------------------------
-- line 216 ----------------------------------------
     .           .          .              .          .          .              .          .          .           		if (metadata_thp_madvise() && (opt_metadata_thp ==
     .           .          .              .          .          .              .          .          .           		    metadata_thp_always || base->auto_thp_switched)) {
     .           .          .              .          .          .              .          .          .           			base->n_thp += (HUGEPAGE_CEILING((uintptr_t)addr + size)
     .           .          .              .          .          .              .          .          .           			    - HUGEPAGE_CEILING((uintptr_t)addr - gap_size)) >>
     .           .          .              .          .          .              .          .          .           			    LG_HUGEPAGE;
     .           .          .              .          .          .              .          .          .           			assert(base->mapped >= base->n_thp << LG_HUGEPAGE);
     .           .          .              .          .          .              .          .          .           		}
     .           .          .              .          .          .              .          .          .           	}
   114 ( 0.00%)  1 ( 0.00%) 1 ( 0.01%)    76 ( 0.00%) 0          0              0          0          0           }
     .           .          .              .          .          .              .          .          .           
     .           .          .              .          .          .              .          .          .           static void *
     .           .          .              .          .          .              .          .          .           base_extent_bump_alloc(base_t *base, edata_t *edata, size_t size,
   407 ( 0.00%) 67 ( 0.05%) 1 ( 0.01%)    37 ( 0.00%) 0          0            222 ( 0.01%) 0          0               size_t alignment) {
     .           .          .              .          .          .              .          .          .           	void *ret;
     .           .          .              .          .          .              .          .          .           	size_t gap_size;
     .           .          .              .          .          .              .          .          .           
   259 ( 0.00%)  0          0            111 ( 0.00%) 0          0             74 ( 0.00%) 0          0           	ret = base_extent_bump_alloc_helper(edata, &gap_size, size, alignment);
   296 ( 0.00%) 33 ( 0.02%) 0            185 ( 0.01%) 0          0             37 ( 0.00%) 0          0           	base_extent_bump_alloc_post(base, edata, gap_size, ret, size);
    37 ( 0.00%)  0          0             37 ( 0.00%) 0          0              0          0          0           	return ret;
   185 ( 0.00%)  0          0            148 ( 0.01%) 0          0              0          0          0           }
     .           .          .              .          .          .              .          .          .           
     .           .          .              .          .          .              .          .          .           /*
     .           .          .              .          .          .              .          .          .            * Allocate a block of virtual memory that is large enough to start with a
     .           .          .              .          .          .              .          .          .            * base_block_t header, followed by an object of specified size and alignment.
     .           .          .              .          .          .              .          .          .            * On success a pointer to the initialized base_block_t header is returned.
     .           .          .              .          .          .              .          .          .            */
     .           .          .              .          .          .              .          .          .           static base_block_t *
     .           .          .              .          .          .              .          .          .           base_block_alloc(tsdn_t *tsdn, base_t *base, ehooks_t *ehooks, unsigned ind,
     .           .          .              .          .          .              .          .          .               pszind_t *pind_last, size_t *extent_sn_next, size_t size,
    22 ( 0.00%)  3 ( 0.00%) 2 ( 0.03%)     0          0          0             16 ( 0.00%) 0          0               size_t alignment) {
     8 ( 0.00%)  0          0              2 ( 0.00%) 0          0              2 ( 0.00%) 0          0           	alignment = ALIGNMENT_CEILING(alignment, QUANTUM);
    16 ( 0.00%)  2 ( 0.00%) 1 ( 0.01%)     6 ( 0.00%) 0          0              2 ( 0.00%) 0          0           	size_t usize = ALIGNMENT_CEILING(size, alignment);
     2 ( 0.00%)  0          0              0          0          0              2 ( 0.00%) 0          0           	size_t header_size = sizeof(base_block_t);
    18 ( 0.00%)  2 ( 0.00%) 1 ( 0.01%)     8 ( 0.00%) 0          0              2 ( 0.00%) 0          0           	size_t gap_size = ALIGNMENT_CEILING(header_size, alignment) -
     .           .          .              .          .          .              .          .          .           	    header_size;
     .           .          .              .          .          .              .          .          .           	/*
     .           .          .              .          .          .              .          .          .           	 * Create increasingly larger blocks in order to limit the total number
     .           .          .              .          .          .              .          .          .           	 * of disjoint virtual memory ranges.  Choose the next size in the page
     .           .          .              .          .          .              .          .          .           	 * size class series (skipping size classes that are not a multiple of
     .           .          .              .          .          .              .          .          .           	 * HUGEPAGE), or a size large enough to satisfy the requested size and
     .           .          .              .          .          .              .          .          .           	 * alignment, whichever is larger.
     .           .          .              .          .          .              .          .          .           	 */
    20 ( 0.00%)  0          0              6 ( 0.00%) 0          0              4 ( 0.00%) 0          0           	size_t min_block_size = HUGEPAGE_CEILING(sz_psz2u(header_size + gap_size
     .           .          .              .          .          .              .          .          .           	    + usize));
    12 ( 0.00%)  2 ( 0.00%) 1 ( 0.01%)     4 ( 0.00%) 0          0              4 ( 0.00%) 0          0           	pszind_t pind_next = (*pind_last + 1 < sz_psz2ind(SC_LARGE_MAXCLASS)) ?
    12 ( 0.00%)  2 ( 0.00%) 1 ( 0.01%)     4 ( 0.00%) 0          0              0          0          0           	    *pind_last + 1 : *pind_last;
    12 ( 0.00%)  0          0              2 ( 0.00%) 0          0              4 ( 0.00%) 0          0           	size_t next_block_size = HUGEPAGE_CEILING(sz_pind2sz(pind_next));
    10 ( 0.00%)  2 ( 0.00%) 1 ( 0.01%)     4 ( 0.00%) 0          0              2 ( 0.00%) 0          0           	size_t block_size = (min_block_size > next_block_size) ? min_block_size
     .           .          .              .          .          .              .          .          .           	    : next_block_size;
    14 ( 0.00%)  0          0              8 ( 0.00%) 0          0              4 ( 0.00%) 0          0           	base_block_t *block = (base_block_t *)base_map(tsdn, ehooks, ind,
     .           .          .              .          .          .              .          .          .           	    block_size);
     4 ( 0.00%)  0          0              2 ( 0.00%) 0          0              0          0          0           	if (block == NULL) {
     .           .          .              .          .          .              .          .          .           		return NULL;
     .           .          .              .          .          .              .          .          .           	}
     .           .          .              .          .          .              .          .          .           
     6 ( 0.00%)  2 ( 0.00%) 1 ( 0.01%)     0          0          0              2 ( 0.00%) 0          0           	if (metadata_thp_madvise()) {
     .           .          .              .          .          .              .          .          .           		void *addr = (void *)block;
     .           .          .              .          .          .              .          .          .           		assert(((uintptr_t)addr & HUGEPAGE_MASK) == 0 &&
     .           .          .              .          .          .              .          .          .           		    (block_size & HUGEPAGE_MASK) == 0);
     .           .          .              .          .          .              .          .          .           		if (opt_metadata_thp == metadata_thp_always) {
     .           .          .              .          .          .              .          .          .           			pages_huge(addr, block_size);
     .           .          .              .          .          .              .          .          .           		} else if (opt_metadata_thp == metadata_thp_auto &&
     .           .          .              .          .          .              .          .          .           		    base != NULL) {
     .           .          .              .          .          .              .          .          .           			/* base != NULL indicates this is not a new base. */
     .           .          .              .          .          .              .          .          .           			malloc_mutex_lock(tsdn, &base->mtx);
     .           .          .              .          .          .              .          .          .           			base_auto_thp_switch(tsdn, base);
     .           .          .              .          .          .              .          .          .           			if (base->auto_thp_switched) {
     .           .          .              .          .          .              .          .          .           				pages_huge(addr, block_size);
     .           .          .              .          .          .              .          .          .           			}
     4 ( 0.00%)  2 ( 0.00%) 1 ( 0.01%)     2 ( 0.00%) 0          0              2 ( 0.00%) 0          0           			malloc_mutex_unlock(tsdn, &base->mtx);
     .           .          .              .          .          .              .          .          .           		}
     .           .          .              .          .          .              .          .          .           	}
     .           .          .              .          .          .              .          .          .           
     4 ( 0.00%)  0          0              2 ( 0.00%) 0          0              2 ( 0.00%) 0          0           	*pind_last = sz_psz2ind(block_size);
     6 ( 0.00%)  0          0              4 ( 0.00%) 0          0              2 ( 0.00%) 2 ( 0.04%) 2 ( 0.05%)  	block->size = block_size;
     4 ( 0.00%)  2 ( 0.00%) 1 ( 0.01%)     2 ( 0.00%) 0          0              2 ( 0.00%) 0          0           	block->next = NULL;
     8 ( 0.00%)  0          0              0          0          0              0          0          0           	assert(block_size >= header_size);
    22 ( 0.00%)  3 ( 0.00%) 2 ( 0.03%)     8 ( 0.00%) 0          0              2 ( 0.00%) 0          0           	base_edata_init(extent_sn_next, &block->edata,
     6 ( 0.00%)  0          0              4 ( 0.00%) 0          0              0          0          0           	    (void *)((uintptr_t)block + header_size), block_size - header_size);
     2 ( 0.00%)  0          0              2 ( 0.00%) 0          0              0          0          0           	return block;
     6 ( 0.00%)  0          0              6 ( 0.00%) 0          0              0          0          0           }
     .           .          .              .          .          .              .          .          .           
     .           .          .              .          .          .              .          .          .           /*
     .           .          .              .          .          .              .          .          .            * Allocate an extent that is at least as large as specified size, with
     .           .          .              .          .          .              .          .          .            * specified alignment.
     .           .          .              .          .          .              .          .          .            */
     .           .          .              .          .          .              .          .          .           static edata_t *
    10 ( 0.00%)  1 ( 0.00%) 0              0          0          0              7 ( 0.00%) 0          0           base_extent_alloc(tsdn_t *tsdn, base_t *base, size_t size, size_t alignment) {
     6 ( 0.00%)  1 ( 0.00%) 1 ( 0.01%)     2 ( 0.00%) 0          0              1 ( 0.00%) 0          0           	malloc_mutex_assert_owner(tsdn, &base->mtx);
     .           .          .              .          .          .              .          .          .           
     4 ( 0.00%)  0          0              1 ( 0.00%) 0          0              2 ( 0.00%) 0          0           	ehooks_t *ehooks = base_ehooks_get_for_metadata(base);
     .           .          .              .          .          .              .          .          .           	/*
     .           .          .              .          .          .              .          .          .           	 * Drop mutex during base_block_alloc(), because an extent hook will be
     .           .          .              .          .          .              .          .          .           	 * called.
     .           .          .              .          .          .              .          .          .           	 */
     6 ( 0.00%)  0          0              2 ( 0.00%) 0          0              1 ( 0.00%) 0          0           	malloc_mutex_unlock(tsdn, &base->mtx);
    19 ( 0.00%)  2 ( 0.00%) 2 ( 0.03%)     8 ( 0.00%) 0          0              5 ( 0.00%) 0          0           	base_block_t *block = base_block_alloc(tsdn, base, ehooks,
     .           .          .              .          .          .              .          .          .           	    base_ind_get(base), &base->pind_last, &base->extent_sn_next, size,
     .           .          .              .          .          .              .          .          .           	    alignment);
     6 ( 0.00%)  0          0              2 ( 0.00%) 0          0              1 ( 0.00%) 0          0           	malloc_mutex_lock(tsdn, &base->mtx);
     2 ( 0.00%)  0          0              1 ( 0.00%) 0          0              0          0          0           	if (block == NULL) {
     .           .          .              .          .          .              .          .          .           		return NULL;
     .           .          .              .          .          .              .          .          .           	}
     4 ( 0.00%)  0          0              3 ( 0.00%) 0          0              1 ( 0.00%) 0          0           	block->next = base->blocks;
     3 ( 0.00%)  1 ( 0.00%) 1 ( 0.01%)     2 ( 0.00%) 0          0              1 ( 0.00%) 0          0           	base->blocks = block;
     3 ( 0.00%)  0          0              0          0          0              0          0          0           	if (config_stats) {
     .           .          .              .          .          .              .          .          .           		base->allocated += sizeof(base_block_t);
     .           .          .              .          .          .              .          .          .           		base->resident += PAGE_CEILING(sizeof(base_block_t));
     .           .          .              .          .          .              .          .          .           		base->mapped += block->size;
     .           .          .              .          .          .              .          .          .           		if (metadata_thp_madvise() &&
     .           .          .              .          .          .              .          .          .           		    !(opt_metadata_thp == metadata_thp_auto
     .           .          .              .          .          .              .          .          .           		      && !base->auto_thp_switched)) {
     .           .          .              .          .          .              .          .          .           			assert(base->n_thp > 0);
     .           .          .              .          .          .              .          .          .           			base->n_thp += HUGEPAGE_CEILING(sizeof(base_block_t)) >>
     .           .          .              .          .          .              .          .          .           			    LG_HUGEPAGE;
     .           .          .              .          .          .              .          .          .           		}
     .           .          .              .          .          .              .          .          .           		assert(base->allocated <= base->resident);
     .           .          .              .          .          .              .          .          .           		assert(base->resident <= base->mapped);
     .           .          .              .          .          .              .          .          .           		assert(base->n_thp << LG_HUGEPAGE <= base->mapped);
     .           .          .              .          .          .              .          .          .           	}
     2 ( 0.00%)  1 ( 0.00%) 1 ( 0.01%)     1 ( 0.00%) 0          0              0          0          0           	return &block->edata;
     5 ( 0.00%)  0          0              4 ( 0.00%) 0          0              0          0          0           }
     .           .          .              .          .          .              .          .          .           
     .           .          .              .          .          .              .          .          .           base_t *
    15 ( 0.00%)  1 ( 0.00%) 0              0          0          0              5 ( 0.00%) 0          0           b0get(void) {
     5 ( 0.00%)  0          0              5 ( 0.00%) 0          0              0          0          0           	return b0;
    10 ( 0.00%)  0          0             10 ( 0.00%) 0          0              0          0          0           }
     .           .          .              .          .          .              .          .          .           
     .           .          .              .          .          .              .          .          .           base_t *
     .           .          .              .          .          .              .          .          .           base_new(tsdn_t *tsdn, unsigned ind, const extent_hooks_t *extent_hooks,
    12 ( 0.00%)  2 ( 0.00%) 2 ( 0.03%)     1 ( 0.00%) 0          0              6 ( 0.00%) 0          0               bool metadata_use_hooks) {
     1 ( 0.00%)  0          0              0          0          0              1 ( 0.00%) 0          0           	pszind_t pind_last = 0;
     1 ( 0.00%)  0          0              0          0          0              1 ( 0.00%) 0          0           	size_t extent_sn_next = 0;
     .           .          .              .          .          .              .          .          .           
     .           .          .              .          .          .              .          .          .           	/*
     .           .          .              .          .          .              .          .          .           	 * The base will contain the ehooks eventually, but it itself is
     .           .          .              .          .          .              .          .          .           	 * allocated using them.  So we use some stack ehooks to bootstrap its
     .           .          .              .          .          .              .          .          .           	 * memory, and then initialize the ehooks within the base_t.
     .           .          .              .          .          .              .          .          .           	 */
     .           .          .              .          .          .              .          .          .           	ehooks_t fake_ehooks;
     9 ( 0.00%)  0          0              3 ( 0.00%) 0          0              1 ( 0.00%) 0          0           	ehooks_init(&fake_ehooks, metadata_use_hooks ?
     .           .          .              .          .          .              .          .          .           	    (extent_hooks_t *)extent_hooks :
     .           .          .              .          .          .              .          .          .           	    (extent_hooks_t *)&ehooks_default_extent_hooks, ind);
     .           .          .              .          .          .              .          .          .           
    14 ( 0.00%)  1 ( 0.00%) 1 ( 0.01%)     2 ( 0.00%) 0          0              4 ( 0.00%) 0          0           	base_block_t *block = base_block_alloc(tsdn, NULL, &fake_ehooks, ind,
     .           .          .              .          .          .              .          .          .           	    &pind_last, &extent_sn_next, sizeof(base_t), QUANTUM);
     2 ( 0.00%)  0          0              1 ( 0.00%) 0          0              0          0          0           	if (block == NULL) {
     .           .          .              .          .          .              .          .          .           		return NULL;
     .           .          .              .          .          .              .          .          .           	}
     .           .          .              .          .          .              .          .          .           
     .           .          .              .          .          .              .          .          .           	size_t gap_size;
     1 ( 0.00%)  1 ( 0.00%) 1 ( 0.01%)     0          0          0              1 ( 0.00%) 0          0           	size_t base_alignment = CACHELINE;
     6 ( 0.00%)  0          0              2 ( 0.00%) 0          0              1 ( 0.00%) 0          0           	size_t base_size = ALIGNMENT_CEILING(sizeof(base_t), base_alignment);
     8 ( 0.00%)  1 ( 0.00%) 1 ( 0.01%)     3 ( 0.00%) 0          0              2 ( 0.00%) 0          0           	base_t *base = (base_t *)base_extent_bump_alloc_helper(&block->edata,
     .           .          .              .          .          .              .          .          .           	    &gap_size, base_size, base_alignment);
     6 ( 0.00%)  0          0              3 ( 0.00%) 0          0              1 ( 0.00%) 0          0           	ehooks_init(&base->ehooks, (extent_hooks_t *)extent_hooks, ind);
    10 ( 0.00%)  1 ( 0.00%) 1 ( 0.01%)     4 ( 0.00%) 0          0              1 ( 0.00%) 0          0           	ehooks_init(&base->ehooks_base, metadata_use_hooks ?
     .           .          .              .          .          .              .          .          .           	    (extent_hooks_t *)extent_hooks :
     .           .          .              .          .          .              .          .          .           	    (extent_hooks_t *)&ehooks_default_extent_hooks, ind);
     9 ( 0.00%)  0          0              1 ( 0.00%) 0          0              1 ( 0.00%) 0          0           	if (malloc_mutex_init(&base->mtx, "base", WITNESS_RANK_BASE,
     .           .          .              .          .          .              .          .          .           	    malloc_mutex_rank_exclusive)) {
     .           .          .              .          .          .              .          .          .           		base_unmap(tsdn, &fake_ehooks, ind, block, block->size);
     .           .          .              .          .          .              .          .          .           		return NULL;
     .           .          .              .          .          .              .          .          .           	}
     3 ( 0.00%)  1 ( 0.00%) 1 ( 0.01%)     2 ( 0.00%) 0          0              1 ( 0.00%) 0          0           	base->pind_last = pind_last;
     3 ( 0.00%)  0          0              2 ( 0.00%) 0          0              1 ( 0.00%) 0          0           	base->extent_sn_next = extent_sn_next;
     3 ( 0.00%)  0          0              2 ( 0.00%) 0          0              1 ( 0.00%) 0          0           	base->blocks = block;
     2 ( 0.00%)  1 ( 0.00%) 1 ( 0.01%)     1 ( 0.00%) 0          0              1 ( 0.00%) 0          0           	base->auto_thp_switched = false;
   700 ( 0.01%)  1 ( 0.00%) 1 ( 0.01%)   465 ( 0.02%) 0          0              1 ( 0.00%) 0          0           	for (szind_t i = 0; i < SC_NSIZES; i++) {
 2,088 ( 0.02%)  0          0            464 ( 0.02%) 0          0            232 ( 0.01%) 0          0           		edata_heap_new(&base->avail[i]);
     .           .          .              .          .          .              .          .          .           	}
     3 ( 0.00%)  0          0              0          0          0              0          0          0           	if (config_stats) {
     .           .          .              .          .          .              .          .          .           		base->allocated = sizeof(base_block_t);
     .           .          .              .          .          .              .          .          .           		base->resident = PAGE_CEILING(sizeof(base_block_t));
     .           .          .              .          .          .              .          .          .           		base->mapped = block->size;
     .           .          .              .          .          .              .          .          .           		base->n_thp = (opt_metadata_thp == metadata_thp_always) &&
     .           .          .              .          .          .              .          .          .           		    metadata_thp_madvise() ? HUGEPAGE_CEILING(sizeof(base_block_t))
     .           .          .              .          .          .              .          .          .           		    >> LG_HUGEPAGE : 0;
     .           .          .              .          .          .              .          .          .           		assert(base->allocated <= base->resident);
     .           .          .              .          .          .              .          .          .           		assert(base->resident <= base->mapped);
     .           .          .              .          .          .              .          .          .           		assert(base->n_thp << LG_HUGEPAGE <= base->mapped);
     .           .          .              .          .          .              .          .          .           	}
     9 ( 0.00%)  1 ( 0.00%) 1 ( 0.01%)     5 ( 0.00%) 0          0              1 ( 0.00%) 0          0           	base_extent_bump_alloc_post(base, &block->edata, gap_size, base,
     .           .          .              .          .          .              .          .          .           	    base_size);
     .           .          .              .          .          .              .          .          .           
     1 ( 0.00%)  1 ( 0.00%) 1 ( 0.01%)     1 ( 0.00%) 0          0              0          0          0           	return base;
     5 ( 0.00%)  0          0              4 ( 0.00%) 0          0              0          0          0           }
     .           .          .              .          .          .              .          .          .           
     .           .          .              .          .          .              .          .          .           void
     .           .          .              .          .          .              .          .          .           base_delete(tsdn_t *tsdn, base_t *base) {
     .           .          .              .          .          .              .          .          .           	ehooks_t *ehooks = base_ehooks_get_for_metadata(base);
     .           .          .              .          .          .              .          .          .           	base_block_t *next = base->blocks;
     .           .          .              .          .          .              .          .          .           	do {
     .           .          .              .          .          .              .          .          .           		base_block_t *block = next;
     .           .          .              .          .          .              .          .          .           		next = block->next;
     .           .          .              .          .          .              .          .          .           		base_unmap(tsdn, ehooks, base_ind_get(base), block,
     .           .          .              .          .          .              .          .          .           		    block->size);
     .           .          .              .          .          .              .          .          .           	} while (next != NULL);
     .           .          .              .          .          .              .          .          .           }
     .           .          .              .          .          .              .          .          .           
     .           .          .              .          .          .              .          .          .           ehooks_t *
   256 ( 0.00%) 32 ( 0.02%) 1 ( 0.01%)     0          0          0            128 ( 0.00%) 1 ( 0.02%) 0           base_ehooks_get(base_t *base) {
    64 ( 0.00%)  0          0             64 ( 0.00%) 0          0              0          0          0           	return &base->ehooks;
   128 ( 0.00%)  0          0            128 ( 0.01%) 0          0              0          0          0           }
     .           .          .              .          .          .              .          .          .           
     .           .          .              .          .          .              .          .          .           ehooks_t *
     4 ( 0.00%)  0          0              0          0          0              2 ( 0.00%) 0          0           base_ehooks_get_for_metadata(base_t *base) {
     2 ( 0.00%)  1 ( 0.00%) 1 ( 0.01%)     1 ( 0.00%) 0          0              0          0          0           	return &base->ehooks_base;
     2 ( 0.00%)  0          0              2 ( 0.00%) 0          0              0          0          0           }
     .           .          .              .          .          .              .          .          .           
     .           .          .              .          .          .              .          .          .           extent_hooks_t *
     .           .          .              .          .          .              .          .          .           base_extent_hooks_set(base_t *base, extent_hooks_t *extent_hooks) {
     .           .          .              .          .          .              .          .          .           	extent_hooks_t *old_extent_hooks =
     .           .          .              .          .          .              .          .          .           	    ehooks_get_extent_hooks_ptr(&base->ehooks);
     .           .          .              .          .          .              .          .          .           	ehooks_init(&base->ehooks, extent_hooks, ehooks_ind_get(&base->ehooks));
     .           .          .              .          .          .              .          .          .           	return old_extent_hooks;
     .           .          .              .          .          .              .          .          .           }
     .           .          .              .          .          .              .          .          .           
     .           .          .              .          .          .              .          .          .           static void *
     .           .          .              .          .          .              .          .          .           base_alloc_impl(tsdn_t *tsdn, base_t *base, size_t size, size_t alignment,
   333 ( 0.00%) 34 ( 0.02%) 1 ( 0.01%)     0          0          0            222 ( 0.01%) 0          0               size_t *esn) {
   148 ( 0.00%) 34 ( 0.02%) 1 ( 0.01%)    37 ( 0.00%) 0          0             37 ( 0.00%) 0          0           	alignment = QUANTUM_CEILING(alignment);
   296 ( 0.00%)  0          0            111 ( 0.00%) 0          0             37 ( 0.00%) 0          0           	size_t usize = ALIGNMENT_CEILING(size, alignment);
   185 ( 0.00%)  0          0             74 ( 0.00%) 0          0             37 ( 0.00%) 0          0           	size_t asize = usize + alignment - QUANTUM;
     .           .          .              .          .          .              .          .          .           
    37 ( 0.00%)  0          0              0          0          0             37 ( 0.00%) 0          0           	edata_t *edata = NULL;
   296 ( 0.00%) 34 ( 0.02%) 1 ( 0.01%)   111 ( 0.00%) 0          0             74 ( 0.00%) 0          0           	malloc_mutex_lock(tsdn, &base->mtx);
 6,041 ( 0.06%) 34 ( 0.02%) 1 ( 0.01%) 3,965 ( 0.16%) 0          0             37 ( 0.00%) 0          0           	for (szind_t i = sz_size2index(asize); i < SC_NSIZES; i++) {
20,000 ( 0.21%)  0          0          4,000 ( 0.16%) 0          0          4,000 ( 0.13%) 0          0           		edata = edata_heap_remove_first(&base->avail[i]);
 4,000 ( 0.04%)  0          0          2,000 ( 0.08%) 0          0              0          0          0           		if (edata != NULL) {
     .           .          .              .          .          .              .          .          .           			/* Use existing space. */
    36 ( 0.00%)  0          0              0          0          0              0          0          0           			break;
     .           .          .              .          .          .              .          .          .           		}
     .           .          .              .          .          .              .          .          .           	}
    74 ( 0.00%)  0          0             37 ( 0.00%) 0          0              0          0          0           	if (edata == NULL) {
     .           .          .              .          .          .              .          .          .           		/* Try to allocate more space. */
     7 ( 0.00%)  0          0              4 ( 0.00%) 0          0              2 ( 0.00%) 0          0           		edata = base_extent_alloc(tsdn, base, usize, alignment);
     .           .          .              .          .          .              .          .          .           	}
     .           .          .              .          .          .              .          .          .           	void *ret;
    74 ( 0.00%) 34 ( 0.02%) 1 ( 0.01%)    37 ( 0.00%) 0          0              0          0          0           	if (edata == NULL) {
     .           .          .              .          .          .              .          .          .           		ret = NULL;
     .           .          .              .          .          .              .          .          .           		goto label_return;
     .           .          .              .          .          .              .          .          .           	}
     .           .          .              .          .          .              .          .          .           
   259 ( 0.00%)  0          0            148 ( 0.01%) 0          0             74 ( 0.00%) 0          0           	ret = base_extent_bump_alloc(base, edata, usize, alignment);
    74 ( 0.00%)  0          0             37 ( 0.00%) 0          0              0          0          0           	if (esn != NULL) {
   198 ( 0.00%) 32 ( 0.02%) 0             66 ( 0.00%) 0          0             66 ( 0.00%) 0          0           		*esn = (size_t)edata_sn_get(edata);
     .           .          .              .          .          .              .          .          .           	}
     4 ( 0.00%)  0          0              0          0          0              0          0          0           label_return:
   222 ( 0.00%)  0          0             74 ( 0.00%) 0          0             37 ( 0.00%) 0          0           	malloc_mutex_unlock(tsdn, &base->mtx);
    37 ( 0.00%)  0          0             37 ( 0.00%) 0          0              0          0          0           	return ret;
    74 ( 0.00%)  0          0             74 ( 0.00%) 0          0              0          0          0           }
     .           .          .              .          .          .              .          .          .           
     .           .          .              .          .          .              .          .          .           /*
     .           .          .              .          .          .              .          .          .            * base_alloc() returns zeroed memory, which is always demand-zeroed for the
     .           .          .              .          .          .              .          .          .            * auto arenas, in order to make multi-page sparse data structures such as radix
     .           .          .              .          .          .              .          .          .            * tree nodes efficient with respect to physical memory usage.  Upon success a
     .           .          .              .          .          .              .          .          .            * pointer to at least size bytes with specified alignment is returned.  Note
     .           .          .              .          .          .              .          .          .            * that size is rounded up to the nearest multiple of alignment to avoid false
     .           .          .              .          .          .              .          .          .            * sharing.
     .           .          .              .          .          .              .          .          .            */
     .           .          .              .          .          .              .          .          .           void *
    32 ( 0.00%)  4 ( 0.00%) 2 ( 0.03%)     0          0          0             20 ( 0.00%) 0          0           base_alloc(tsdn_t *tsdn, base_t *base, size_t size, size_t alignment) {
    28 ( 0.00%)  0          0             16 ( 0.00%) 0          0              4 ( 0.00%) 0          0           	return base_alloc_impl(tsdn, base, size, alignment, NULL);
     8 ( 0.00%)  0          0              8 ( 0.00%) 0          0              0          0          0           }
     .           .          .              .          .          .              .          .          .           
     .           .          .              .          .          .              .          .          .           edata_t *
   297 ( 0.00%) 63 ( 0.04%) 1 ( 0.01%)    33 ( 0.00%) 0          0            132 ( 0.00%) 0          0           base_alloc_edata(tsdn_t *tsdn, base_t *base) {
     .           .          .              .          .          .              .          .          .           	size_t esn;
   297 ( 0.00%)  0          0             66 ( 0.00%) 0          0             66 ( 0.00%) 0          0           	edata_t *edata = base_alloc_impl(tsdn, base, sizeof(edata_t),
     .           .          .              .          .          .              .          .          .           	    EDATA_ALIGNMENT, &esn);
    66 ( 0.00%)  0          0             33 ( 0.00%) 0          0              0          0          0           	if (edata == NULL) {
     .           .          .              .          .          .              .          .          .           		return NULL;
     .           .          .              .          .          .              .          .          .           	}
   165 ( 0.00%) 32 ( 0.02%) 1 ( 0.01%)    66 ( 0.00%) 0          0             33 ( 0.00%) 0          0           	edata_esn_set(edata, esn);
    33 ( 0.00%)  0          0             33 ( 0.00%) 0          0              0          0          0           	return edata;
   165 ( 0.00%)  0          0            132 ( 0.01%) 0          0              0          0          0           }
     .           .          .              .          .          .              .          .          .           
     .           .          .              .          .          .              .          .          .           void
     .           .          .              .          .          .              .          .          .           base_stats_get(tsdn_t *tsdn, base_t *base, size_t *allocated, size_t *resident,
     .           .          .              .          .          .              .          .          .               size_t *mapped, size_t *n_thp) {
     .           .          .              .          .          .              .          .          .           	cassert(config_stats);
     .           .          .              .          .          .              .          .          .           
     .           .          .              .          .          .              .          .          .           	malloc_mutex_lock(tsdn, &base->mtx);
     .           .          .              .          .          .              .          .          .           	assert(base->allocated <= base->resident);
-- line 500 ----------------------------------------
-- line 517 ----------------------------------------
     .           .          .              .          .          .              .          .          .           }
     .           .          .              .          .          .              .          .          .           
     .           .          .              .          .          .              .          .          .           void
     .           .          .              .          .          .              .          .          .           base_postfork_child(tsdn_t *tsdn, base_t *base) {
     .           .          .              .          .          .              .          .          .           	malloc_mutex_postfork_child(tsdn, &base->mtx);
     .           .          .              .          .          .              .          .          .           }
     .           .          .              .          .          .              .          .          .           
     .           .          .              .          .          .              .          .          .           bool
     5 ( 0.00%)  1 ( 0.00%) 1 ( 0.01%)     0          0          0              2 ( 0.00%) 0          0           base_boot(tsdn_t *tsdn) {
     7 ( 0.00%)  1 ( 0.00%) 1 ( 0.01%)     1 ( 0.00%) 0          0              2 ( 0.00%) 0          0           	b0 = base_new(tsdn, 0, (extent_hooks_t *)&ehooks_default_extent_hooks,
     .           .          .              .          .          .              .          .          .           	    /* metadata_use_hooks */ true);
     3 ( 0.00%)  0          0              1 ( 0.00%) 0          0              0          0          0           	return (b0 == NULL);
     2 ( 0.00%)  0          0              2 ( 0.00%) 0          0              0          0          0           }

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/ashy5000/dev/cryptocurrency/contracts/target/debug/build/tikv-jemalloc-sys-7365f40ecb99e085/out/build/include/jemalloc/internal/bit_util.h
--------------------------------------------------------------------------------
Ir              I1mr         ILmr       Dr             D1mr       DLmr       Dw             D1mw        DLmw       

-- line 18 ----------------------------------------
     .            .          .              .          .          .              .           .          .            */
     .            .          .              .          .          .              .           .          .           static inline unsigned
     .            .          .              .          .          .              .           .          .           ffs_llu(unsigned long long x) {
     .            .          .              .          .          .              .           .          .           	util_assume(x != 0);
     .            .          .              .          .          .              .           .          .           	return JEMALLOC_INTERNAL_FFSLL(x) - 1;
     .            .          .              .          .          .              .           .          .           }
     .            .          .              .          .          .              .           .          .           
     .            .          .              .          .          .              .           .          .           static inline unsigned
 3,306 ( 0.03%)  63 ( 0.04%) 3 ( 0.04%)     0          0          0          2,204 ( 0.07%)  0          0           ffs_lu(unsigned long x) {
 5,510 ( 0.06%)   0          0          2,204 ( 0.09%) 0          0          1,102 ( 0.03%)  0          0           	util_assume(x != 0);
 6,612 ( 0.07%)   0          0          1,102 ( 0.05%) 0          0              0           0          0           	return JEMALLOC_INTERNAL_FFSL(x) - 1;
 2,204 ( 0.02%)   0          0          2,204 ( 0.09%) 0          0              0           0          0           }
     .            .          .              .          .          .              .           .          .           
     .            .          .              .          .          .              .           .          .           static inline unsigned
     .            .          .              .          .          .              .           .          .           ffs_u(unsigned x) {
     .            .          .              .          .          .              .           .          .           	util_assume(x != 0);
     .            .          .              .          .          .              .           .          .           	return JEMALLOC_INTERNAL_FFS(x) - 1;
     .            .          .              .          .          .              .           .          .           }
     .            .          .              .          .          .              .           .          .           
     .            .          .              .          .          .              .           .          .           #define DO_FLS_SLOW(x, suffix) do {					\
-- line 37 ----------------------------------------
-- line 90 ----------------------------------------
     .            .          .              .          .          .              .           .          .           	 * If we write it as xor instead, then we get
     .            .          .              .          .          .              .           .          .           	 *    bsr     eax, edi
     .            .          .              .          .          .              .           .          .           	 * as desired.
     .            .          .              .          .          .              .           .          .           	 */
     .            .          .              .          .          .              .           .          .           	return (8 * sizeof(x) - 1) ^ __builtin_clzll(x);
     .            .          .              .          .          .              .           .          .           }
     .            .          .              .          .          .              .           .          .           
     .            .          .              .          .          .              .           .          .           static inline unsigned
   990 ( 0.01%) 119 ( 0.08%) 8 ( 0.11%)     0          0          0            660 ( 0.02%) 12 ( 0.23%) 7 ( 0.17%)  fls_lu(unsigned long x) {
 1,650 ( 0.02%)   0          0            660 ( 0.03%) 0          0            330 ( 0.01%)  0          0           	util_assume(x != 0);
   990 ( 0.01%)   0          0            330 ( 0.01%) 0          0              0           0          0           	return (8 * sizeof(x) - 1) ^ __builtin_clzl(x);
   660 ( 0.01%)   0          0            660 ( 0.03%) 0          0              0           0          0           }
     .            .          .              .          .          .              .           .          .           
     .            .          .              .          .          .              .           .          .           static inline unsigned
     .            .          .              .          .          .              .           .          .           fls_u(unsigned x) {
     .            .          .              .          .          .              .           .          .           	util_assume(x != 0);
     .            .          .              .          .          .              .           .          .           	return (8 * sizeof(x) - 1) ^ __builtin_clz(x);
     .            .          .              .          .          .              .           .          .           }
     .            .          .              .          .          .              .           .          .           #elif defined(_MSC_VER)
     .            .          .              .          .          .              .           .          .           
-- line 109 ----------------------------------------
-- line 249 ----------------------------------------
     .            .          .              .          .          .              .           .          .           #ifdef JEMALLOC_INTERNAL_POPCOUNT
     .            .          .              .          .          .              .           .          .           	return JEMALLOC_INTERNAL_POPCOUNT(bitmap);
     .            .          .              .          .          .              .           .          .           #else
     .            .          .              .          .          .              .           .          .           	return popcount_u_slow(bitmap);
     .            .          .              .          .          .              .           .          .           #endif
     .            .          .              .          .          .              .           .          .           }
     .            .          .              .          .          .              .           .          .           
     .            .          .              .          .          .              .           .          .           static inline unsigned
   152 ( 0.00%)  62 ( 0.04%) 1 ( 0.01%)     0          0          0             76 ( 0.00%)  0          0           popcount_lu(unsigned long bitmap) {
     .            .          .              .          .          .              .           .          .           #ifdef JEMALLOC_INTERNAL_POPCOUNTL
    76 ( 0.00%)   0          0             38 ( 0.00%) 0          0             38 ( 0.00%)  0          0           	return JEMALLOC_INTERNAL_POPCOUNTL(bitmap);
     .            .          .              .          .          .              .           .          .           #else
     .            .          .              .          .          .              .           .          .           	return popcount_lu_slow(bitmap);
     .            .          .              .          .          .              .           .          .           #endif
    76 ( 0.00%)   0          0             76 ( 0.00%) 0          0              0           0          0           }
     .            .          .              .          .          .              .           .          .           
     .            .          .              .          .          .              .           .          .           static inline unsigned
     .            .          .              .          .          .              .           .          .           popcount_llu(unsigned long long bitmap) {
     .            .          .              .          .          .              .           .          .           #ifdef JEMALLOC_INTERNAL_POPCOUNTLL
     .            .          .              .          .          .              .           .          .           	return JEMALLOC_INTERNAL_POPCOUNTLL(bitmap);
     .            .          .              .          .          .              .           .          .           #else
     .            .          .              .          .          .              .           .          .           	return popcount_llu_slow(bitmap);
     .            .          .              .          .          .              .           .          .           #endif
-- line 271 ----------------------------------------
-- line 272 ----------------------------------------
     .            .          .              .          .          .              .           .          .           }
     .            .          .              .          .          .              .           .          .           
     .            .          .              .          .          .              .           .          .           /*
     .            .          .              .          .          .              .           .          .            * Clears first unset bit in bitmap, and returns
     .            .          .              .          .          .              .           .          .            * place of bit.  bitmap *must not* be 0.
     .            .          .              .          .          .              .           .          .            */
     .            .          .              .          .          .              .           .          .           
     .            .          .              .          .          .              .           .          .           static inline size_t
 4,280 ( 0.05%)   0          0              0          0          0          2,140 ( 0.07%)  0          0           cfs_lu(unsigned long* bitmap) {
 7,490 ( 0.08%)   0          0          3,210 ( 0.13%) 0          0          1,070 ( 0.03%)  0          0           	util_assume(*bitmap != 0);
 6,420 ( 0.07%)  31 ( 0.02%) 0          2,140 ( 0.09%) 0          0          2,140 ( 0.07%)  0          0           	size_t bit = ffs_lu(*bitmap);
10,700 ( 0.11%)   0          0          4,280 ( 0.18%) 0          0          1,070 ( 0.03%)  0          0           	*bitmap ^= ZU(1) << bit;
 1,070 ( 0.01%)   0          0          1,070 ( 0.04%) 0          0              0           0          0           	return bit;
 2,140 ( 0.02%)   0          0          2,140 ( 0.09%) 0          0              0           0          0           }
     .            .          .              .          .          .              .           .          .           
     .            .          .              .          .          .              .           .          .           static inline unsigned
     .            .          .              .          .          .              .           .          .           ffs_zu(size_t x) {
     .            .          .              .          .          .              .           .          .           #if LG_SIZEOF_PTR == LG_SIZEOF_INT
     .            .          .              .          .          .              .           .          .           	return ffs_u(x);
     .            .          .              .          .          .              .           .          .           #elif LG_SIZEOF_PTR == LG_SIZEOF_LONG
     .            .          .              .          .          .              .           .          .           	return ffs_lu(x);
     .            .          .              .          .          .              .           .          .           #elif LG_SIZEOF_PTR == LG_SIZEOF_LONG_LONG
-- line 293 ----------------------------------------
-- line 307 ----------------------------------------
     .            .          .              .          .          .              .           .          .           	return fls_llu(x);
     .            .          .              .          .          .              .           .          .           #else
     .            .          .              .          .          .              .           .          .           #error No implementation for size_t fls()
     .            .          .              .          .          .              .           .          .           #endif
     .            .          .              .          .          .              .           .          .           }
     .            .          .              .          .          .              .           .          .           
     .            .          .              .          .          .              .           .          .           
     .            .          .              .          .          .              .           .          .           static inline unsigned
     4 ( 0.00%)   0          0              0          0          0              2 ( 0.00%)  0          0           ffs_u64(uint64_t x) {
     .            .          .              .          .          .              .           .          .           #if LG_SIZEOF_LONG == 3
     3 ( 0.00%)   0          0              1 ( 0.00%) 0          0              1 ( 0.00%)  0          0           	return ffs_lu(x);
     .            .          .              .          .          .              .           .          .           #elif LG_SIZEOF_LONG_LONG == 3
     .            .          .              .          .          .              .           .          .           	return ffs_llu(x);
     .            .          .              .          .          .              .           .          .           #else
     .            .          .              .          .          .              .           .          .           #error No implementation for 64-bit ffs()
     .            .          .              .          .          .              .           .          .           #endif
     2 ( 0.00%)   0          0              2 ( 0.00%) 0          0              0           0          0           }
     .            .          .              .          .          .              .           .          .           
     .            .          .              .          .          .              .           .          .           static inline unsigned
 1,320 ( 0.01%) 112 ( 0.08%) 9 ( 0.13%)     0          0          0            660 ( 0.02%)  9 ( 0.17%) 8 ( 0.19%)  fls_u64(uint64_t x) {
     .            .          .              .          .          .              .           .          .           #if LG_SIZEOF_LONG == 3
   990 ( 0.01%)   0          0            330 ( 0.01%) 0          0            330 ( 0.01%)  4 ( 0.08%) 2 ( 0.05%)  	return fls_lu(x);
     .            .          .              .          .          .              .           .          .           #elif LG_SIZEOF_LONG_LONG == 3
     .            .          .              .          .          .              .           .          .           	return fls_llu(x);
     .            .          .              .          .          .              .           .          .           #else
     .            .          .              .          .          .              .           .          .           #error No implementation for 64-bit fls()
     .            .          .              .          .          .              .           .          .           #endif
   660 ( 0.01%)   0          0            660 ( 0.03%) 0          0              0           0          0           }
     .            .          .              .          .          .              .           .          .           
     .            .          .              .          .          .              .           .          .           static inline unsigned
     .            .          .              .          .          .              .           .          .           ffs_u32(uint32_t x) {
     .            .          .              .          .          .              .           .          .           #if LG_SIZEOF_INT == 2
     .            .          .              .          .          .              .           .          .           	return ffs_u(x);
     .            .          .              .          .          .              .           .          .           #else
     .            .          .              .          .          .              .           .          .           #error No implementation for 32-bit ffs()
     .            .          .              .          .          .              .           .          .           #endif
-- line 342 ----------------------------------------
-- line 349 ----------------------------------------
     .            .          .              .          .          .              .           .          .           	return fls_u(x);
     .            .          .              .          .          .              .           .          .           #else
     .            .          .              .          .          .              .           .          .           #error No implementation for 32-bit fls()
     .            .          .              .          .          .              .           .          .           #endif
     .            .          .              .          .          .              .           .          .           	return fls_u(x);
     .            .          .              .          .          .              .           .          .           }
     .            .          .              .          .          .              .           .          .           
     .            .          .              .          .          .              .           .          .           static inline uint64_t
     4 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)     0          0          0              2 ( 0.00%)  0          0           pow2_ceil_u64(uint64_t x) {
     5 ( 0.00%)   0          0              1 ( 0.00%) 0          0              0           0          0           	if (unlikely(x <= 1)) {
     .            .          .              .          .          .              .           .          .           		return x;
     .            .          .              .          .          .              .           .          .           	}
     6 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)     1 ( 0.00%) 0          0              2 ( 0.00%)  0          0           	size_t msb_on_index = fls_u64(x - 1);
     .            .          .              .          .          .              .           .          .           	/*
     .            .          .              .          .          .              .           .          .           	 * Range-check; it's on the callers to ensure that the result of this
     .            .          .              .          .          .              .           .          .           	 * call won't overflow.
     .            .          .              .          .          .              .           .          .           	 */
     4 ( 0.00%)   0          0              0          0          0              0           0          0           	assert(msb_on_index < 63);
     6 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)     1 ( 0.00%) 0          0              0           0          0           	return 1ULL << (msb_on_index + 1);
     2 ( 0.00%)   0          0              2 ( 0.00%) 0          0              0           0          0           }
     .            .          .              .          .          .              .           .          .           
     .            .          .              .          .          .              .           .          .           static inline uint32_t
     .            .          .              .          .          .              .           .          .           pow2_ceil_u32(uint32_t x) {
     .            .          .              .          .          .              .           .          .           	if (unlikely(x <= 1)) {
     .            .          .              .          .          .              .           .          .           	    return x;
     .            .          .              .          .          .              .           .          .           	}
     .            .          .              .          .          .              .           .          .           	size_t msb_on_index = fls_u32(x - 1);
     .            .          .              .          .          .              .           .          .           	/* As above. */
-- line 376 ----------------------------------------
-- line 384 ----------------------------------------
     .            .          .              .          .          .              .           .          .           #if (LG_SIZEOF_PTR == 3)
     .            .          .              .          .          .              .           .          .           	return pow2_ceil_u64(x);
     .            .          .              .          .          .              .           .          .           #else
     .            .          .              .          .          .              .           .          .           	return pow2_ceil_u32(x);
     .            .          .              .          .          .              .           .          .           #endif
     .            .          .              .          .          .              .           .          .           }
     .            .          .              .          .          .              .           .          .           
     .            .          .              .          .          .              .           .          .           static inline unsigned
 1,316 ( 0.01%) 106 ( 0.07%) 7 ( 0.10%)     0          0          0            658 ( 0.02%) 13 ( 0.24%) 5 ( 0.12%)  lg_floor(size_t x) {
 1,645 ( 0.02%)   2 ( 0.00%) 1 ( 0.01%)   658 ( 0.03%) 0          0            329 ( 0.01%)  0          0           	util_assume(x != 0);
     .            .          .              .          .          .              .           .          .           #if (LG_SIZEOF_PTR == 3)
   987 ( 0.01%)   0          0            329 ( 0.01%) 0          0            329 ( 0.01%)  2 ( 0.04%) 2 ( 0.05%)  	return fls_u64(x);
     .            .          .              .          .          .              .           .          .           #else
     .            .          .              .          .          .              .           .          .           	return fls_u32(x);
     .            .          .              .          .          .              .           .          .           #endif
   658 ( 0.01%)   0          0            658 ( 0.03%) 0          0              0           0          0           }
     .            .          .              .          .          .              .           .          .           
     .            .          .              .          .          .              .           .          .           static inline unsigned
 1,044 ( 0.01%) 106 ( 0.07%) 4 ( 0.06%)     0          0          0            522 ( 0.02%)  4 ( 0.08%) 4 ( 0.10%)  lg_ceil(size_t x) {
 2,610 ( 0.03%)  55 ( 0.04%) 2 ( 0.03%)   783 ( 0.03%) 0          0            261 ( 0.01%)  0          0           	return lg_floor(x) + ((x & (x - 1)) == 0 ? 0 : 1);
   522 ( 0.01%)   0          0            522 ( 0.02%) 0          0              0           0          0           }
     .            .          .              .          .          .              .           .          .           
     .            .          .              .          .          .              .           .          .           /* A compile-time version of lg_floor and lg_ceil. */
     .            .          .              .          .          .              .           .          .           #define LG_FLOOR_1(x) 0
     .            .          .              .          .          .              .           .          .           #define LG_FLOOR_2(x) (x < (1ULL << 1) ? LG_FLOOR_1(x) : 1 + LG_FLOOR_1(x >> 1))
     .            .          .              .          .          .              .           .          .           #define LG_FLOOR_4(x) (x < (1ULL << 2) ? LG_FLOOR_2(x) : 2 + LG_FLOOR_2(x >> 2))
     .            .          .              .          .          .              .           .          .           #define LG_FLOOR_8(x) (x < (1ULL << 4) ? LG_FLOOR_4(x) : 4 + LG_FLOOR_4(x >> 4))
     .            .          .              .          .          .              .           .          .           #define LG_FLOOR_16(x) (x < (1ULL << 8) ? LG_FLOOR_8(x) : 8 + LG_FLOOR_8(x >> 8))
     .            .          .              .          .          .              .           .          .           #define LG_FLOOR_32(x) (x < (1ULL << 16) ? LG_FLOOR_16(x) : 16 + LG_FLOOR_16(x >> 16))
-- line 412 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/ashy5000/dev/cryptocurrency/contracts/target/debug/build/tikv-jemalloc-sys-7365f40ecb99e085/out/build/include/jemalloc/internal/atomic_gcc_atomic.h
--------------------------------------------------------------------------------
Ir              I1mr         ILmr        Dr              D1mr         DLmr        Dw           D1mw       DLmw       

-- line 10 ----------------------------------------
     .            .           .               .            .           .            .          .          .           	atomic_memory_order_acquire,
     .            .           .               .            .           .            .          .          .           	atomic_memory_order_release,
     .            .           .               .            .           .            .          .          .           	atomic_memory_order_acq_rel,
     .            .           .               .            .           .            .          .          .           	atomic_memory_order_seq_cst
     .            .           .               .            .           .            .          .          .           } atomic_memory_order_t;
     .            .           .               .            .           .            .          .          .           
     .            .           .               .            .           .            .          .          .           ATOMIC_INLINE int
     .            .           .               .            .           .            .          .          .           atomic_enum_to_builtin(atomic_memory_order_t mo) {
38,888 ( 0.41%) 451 ( 0.31%) 46 ( 0.65%) 11,660 ( 0.48%) 106 ( 1.84%) 49 ( 1.37%)  32 ( 0.00%) 0          0           	switch (mo) {
     .            .           .               .            .           .            .          .          .           	case atomic_memory_order_relaxed:
     .            .           .               .            .           .            .          .          .           		return __ATOMIC_RELAXED;
     .            .           .               .            .           .            .          .          .           	case atomic_memory_order_acquire:
     .            .           .               .            .           .            .          .          .           		return __ATOMIC_ACQUIRE;
     .            .           .               .            .           .            .          .          .           	case atomic_memory_order_release:
     .            .           .               .            .           .            .          .          .           		return __ATOMIC_RELEASE;
     .            .           .               .            .           .            .          .          .           	case atomic_memory_order_acq_rel:
     .            .           .               .            .           .            .          .          .           		return __ATOMIC_ACQ_REL;
     .            .           .               .            .           .            .          .          .           	case atomic_memory_order_seq_cst:
 4,860 ( 0.05%) 832 ( 0.58%) 58 ( 0.82%)      0            0           0          119 ( 0.00%) 0          0           		return __ATOMIC_SEQ_CST;
     .            .           .               .            .           .            .          .          .           	}
     .            .           .               .            .           .            .          .          .           	/* Can't happen; the switch is exhaustive. */
 1,066 ( 0.01%)   9 ( 0.01%)  1 ( 0.01%)    133 ( 0.01%)   0           0          265 ( 0.01%) 0          0           	not_reached();
     .            .           .               .            .           .            .          .          .           }
     .            .           .               .            .           .            .          .          .           
     .            .           .               .            .           .            .          .          .           ATOMIC_INLINE void
     .            .           .               .            .           .            .          .          .           atomic_fence(atomic_memory_order_t mo) {
     5 ( 0.00%)   0           0              10 ( 0.00%)   0           0            0          0          0           	__atomic_thread_fence(atomic_enum_to_builtin(mo));
    15 ( 0.00%)   0           0               5 ( 0.00%)   0           0            5 ( 0.00%) 0          0           }
     .            .           .               .            .           .            .          .          .           
     .            .           .               .            .           .            .          .          .           #define JEMALLOC_GENERATE_ATOMICS(type, short_type,			\
     .            .           .               .            .           .            .          .          .               /* unused */ lg_size)						\
     .            .           .               .            .           .            .          .          .           typedef struct {							\
     .            .           .               .            .           .            .          .          .           	type repr;							\
     .            .           .               .            .           .            .          .          .           } atomic_##short_type##_t;						\
     .            .           .               .            .           .            .          .          .           									\
     .            .           .               .            .           .            .          .          .           ATOMIC_INLINE type							\
-- line 45 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/ashy5000/.cargo/registry/src/index.crates.io-6f17d22bba15001f/smartstring-1.0.1/src/ops.rs
--------------------------------------------------------------------------------
Ir              I1mr         ILmr       Dr              D1mr       DLmr       Dw              D1mw       DLmw       

-- line 19 ----------------------------------------
     .            .          .               .          .          .               .          .          .           
     .            .          .               .          .          .               .          .          .           pub(crate) trait GenericString: Deref<Target = str> + DerefMut<Target = str> {
     .            .          .               .          .          .               .          .          .               fn set_size(&mut self, size: usize);
     .            .          .               .          .          .               .          .          .               fn as_mut_capacity_slice(&mut self) -> &mut [u8];
     .            .          .               .          .          .               .          .          .           }
     .            .          .               .          .          .               .          .          .           
     .            .          .               .          .          .               .          .          .           macro_rules! string_op_grow {
     .            .          .               .          .          .               .          .          .               ($action:ty, $target:ident, $($arg:expr),*) => {
 2,817 ( 0.03%)   0          0               0          0          0           2,817 ( 0.09%) 0          0                   match $target.cast_mut() {
    70 ( 0.00%)   0          0              70 ( 0.00%) 0          0               0          0          0                       StringCastMut::Boxed(this) => {
   140 ( 0.00%)   0          0              70 ( 0.00%) 0          0              70 ( 0.00%) 0          0                           this.ensure_capacity(<$action>::cap(this, $($arg),*));
   140 ( 0.00%)   0          0               0          0          0              70 ( 0.00%) 0          0                           <$action>::op(this, $($arg),*)
     .            .          .               .          .          .               .          .          .                       }
 8,241 ( 0.09%)   0          0           2,747 ( 0.11%) 0          0           5,494 ( 0.17%) 0          0                       StringCastMut::Inline(this) => {
 8,241 ( 0.09%) 103 ( 0.07%) 1 ( 0.01%)      0          0          0           8,241 ( 0.26%) 0          0                           let new_size = <$action>::cap(this,$($arg),*);
 8,241 ( 0.09%)   0          0               0          0          0               0          0          0                           if new_size > MAX_INLINE {
     3 ( 0.00%)   0          0               0          0          0               0          0          0                               let mut new_str = BoxedString::from_str(new_size, this);
 2,823 ( 0.03%)  29 ( 0.02%) 1 ( 0.01%)      0          0          0           2,820 ( 0.09%) 0          0                               let result = <$action>::op(&mut new_str, $($arg),*);
     3 ( 0.00%)   0          0               0          0          0               3 ( 0.00%) 0          0                               $target.promote_from(new_str);
     .            .          .               .          .          .               .          .          .                               result
     3 ( 0.00%)   0          0               0          0          0               3 ( 0.00%) 0          0                           } else {
 2,744 ( 0.03%)   0          0               0          0          0           2,744 ( 0.09%) 0          0                               <$action>::op(this, $($arg),*)
     .            .          .               .          .          .               .          .          .                           }
     .            .          .               .          .          .               .          .          .                       }
     .            .          .               .          .          .               .          .          .                   }
     .            .          .               .          .          .               .          .          .               };
     .            .          .               .          .          .               .          .          .           }
     .            .          .               .          .          .               .          .          .           pub(crate) use string_op_grow;
     .            .          .               .          .          .               .          .          .           
     .            .          .               .          .          .               .          .          .           macro_rules! string_op_shrink {
-- line 48 ----------------------------------------
-- line 107 ----------------------------------------
     .            .          .               .          .          .               .          .          .                   let new_len = len + string.len();
     .            .          .               .          .          .               .          .          .                   this.as_mut_capacity_slice()[len..new_len].copy_from_slice(string.as_bytes());
     .            .          .               .          .          .               .          .          .                   this.set_size(new_len);
     .            .          .               .          .          .               .          .          .               }
     .            .          .               .          .          .               .          .          .           }
     .            .          .               .          .          .               .          .          .           
     .            .          .               .          .          .               .          .          .           pub(crate) struct Push;
     .            .          .               .          .          .               .          .          .           impl Push {
 3,027 ( 0.03%) 108 ( 0.07%) 2 ( 0.03%)      0          0          0             210 ( 0.01%) 0          0               pub(crate) fn cap<S: GenericString>(this: &S, ch: char) -> usize {
 3,167 ( 0.03%)   0          0           2,887 ( 0.12%) 0          0           2,957 ( 0.09%) 0          0                   this.len() + ch.len_utf8()
 2,887 ( 0.03%)   0          0              70 ( 0.00%) 0          0               0          0          0               }
     .            .          .               .          .          .               .          .          .           
 2,963 ( 0.03%) 106 ( 0.07%) 2 ( 0.03%)      0          0          0             146 ( 0.00%) 0          0               pub(crate) fn op<S: GenericString>(this: &mut S, ch: char) {
19,281 ( 0.20%)   0          0           5,561 ( 0.23%) 3 ( 0.05%) 0          11,049 ( 0.35%) 0          0                   let len = this.len();
 3,255 ( 0.03%)   0          0              73 ( 0.00%) 0          0           2,963 ( 0.09%) 0          0                   let written = ch
 5,561 ( 0.06%)   0          0           5,561 ( 0.23%) 0          0           2,817 ( 0.09%) 0          0                       .encode_utf8(&mut this.as_mut_capacity_slice()[len..])
     .            .          .               .          .          .               .          .          .                       .len();
13,866 ( 0.15%)   0          0           2,744 ( 0.11%) 1 ( 0.02%) 0           5,561 ( 0.18%) 0          0                   this.set_size(len + written);
 5,561 ( 0.06%)   0          0           2,744 ( 0.11%) 0          0               0          0          0               }
     .            .          .               .          .          .               .          .          .           }
     .            .          .               .          .          .               .          .          .           
     .            .          .               .          .          .               .          .          .           pub(crate) struct Truncate;
     .            .          .               .          .          .               .          .          .           impl Truncate {
     .            .          .               .          .          .               .          .          .               pub(crate) fn op<S: GenericString>(this: &mut S, new_len: usize) {
     .            .          .               .          .          .               .          .          .                   if new_len < this.len() {
     .            .          .               .          .          .               .          .          .                       assert!(this.deref().is_char_boundary(new_len));
     .            .          .               .          .          .               .          .          .                       this.set_size(new_len)
-- line 133 ----------------------------------------

11,271 ( 0.12%)  42 ( 0.03%) 1 ( 0.01%) 11,271 ( 0.46%) 0          0               0          0          0           <counts for unidentified lines in /home/ashy5000/.cargo/registry/src/index.crates.io-6f17d22bba15001f/smartstring-1.0.1/src/ops.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/ashy5000/dev/cryptocurrency/contracts/target/debug/build/tikv-jemalloc-sys-7365f40ecb99e085/out/build/include/jemalloc/internal/jemalloc_internal_inlines_c.h
--------------------------------------------------------------------------------
Ir              I1mr         ILmr       Dr             D1mr       DLmr       Dw             D1mw        DLmw        

-- line 23 ----------------------------------------
     .            .          .              .          .          .              .           .           .            *   alloc/dalloc) describe the arguments it takes
     .            .          .              .          .          .              .           .           .            *     z: whether to return zeroed memory
     .            .          .              .          .          .              .           .           .            *     t: accepts a tcache_t * parameter
     .            .          .              .          .          .              .           .           .            *     m: accepts an arena_t * parameter
     .            .          .              .          .          .              .           .           .            */
     .            .          .              .          .          .              .           .           .           
     .            .          .              .          .          .              .           .           .           JEMALLOC_ALWAYS_INLINE arena_t *
     .            .          .              .          .          .              .           .           .           iaalloc(tsdn_t *tsdn, const void *ptr) {
 2,503 ( 0.03%) 312 ( 0.22%) 3 ( 0.04%)     2 ( 0.00%) 0          0          2,499 ( 0.08%)  0           0           	assert(ptr != NULL);
     .            .          .              .          .          .              .           .           .           
   694 ( 0.01%) 108 ( 0.07%) 2 ( 0.03%)   689 ( 0.03%) 0          0              0           0           0           	return arena_aalloc(tsdn, ptr);
     .            .          .              .          .          .              .           .           .           }
     .            .          .              .          .          .              .           .           .           
     .            .          .              .          .          .              .           .           .           JEMALLOC_ALWAYS_INLINE size_t
     .            .          .              .          .          .              .           .           .           isalloc(tsdn_t *tsdn, const void *ptr) {
 4,812 ( 0.05%) 119 ( 0.08%) 3 ( 0.04%)   430 ( 0.02%) 0          0          1,651 ( 0.05%)  0           0           	assert(ptr != NULL);
     .            .          .              .          .          .              .           .           .           
   484 ( 0.01%)   0          0            203 ( 0.01%) 0          0             74 ( 0.00%)  0           0           	return arena_salloc(tsdn, ptr);
     .            .          .              .          .          .              .           .           .           }
     .            .          .              .          .          .              .           .           .           
     .            .          .              .          .          .              .           .           .           JEMALLOC_ALWAYS_INLINE void *
     .            .          .              .          .          .              .           .           .           iallocztm(tsdn_t *tsdn, size_t size, szind_t ind, bool zero, tcache_t *tcache,
     .            .          .              .          .          .              .           .           .               bool is_internal, arena_t *arena, bool slow_path) {
     .            .          .              .          .          .              .           .           .           	void *ret;
     .            .          .              .          .          .              .           .           .           
    68 ( 0.00%)   0          0              0          0          0              0           0           0           	assert(!is_internal || tcache == NULL);
   102 ( 0.00%)  32 ( 0.02%) 2 ( 0.03%)    17 ( 0.00%) 0          0             17 ( 0.00%)  0           0           	assert(!is_internal || arena == NULL || arena_is_auto(arena));
 2,167 ( 0.02%)  41 ( 0.03%) 2 ( 0.03%)    53 ( 0.00%) 0          0          2,029 ( 0.06%)  5 ( 0.09%)  4 ( 0.10%)  	if (!tsdn_null(tsdn) && tsd_reentrancy_level_get(tsdn_tsd(tsdn)) == 0) {
    74 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)     1 ( 0.00%) 0          0             20 ( 0.00%)  1 ( 0.02%)  1 ( 0.02%)  		witness_assert_depth_to_rank(tsdn_witness_tsdp_get(tsdn),
     .            .          .              .          .          .              .           .           .           		    WITNESS_RANK_CORE, 0);
     .            .          .              .          .          .              .           .           .           	}
     .            .          .              .          .          .              .           .           .           
 1,579 ( 0.02%)  47 ( 0.03%) 3 ( 0.04%) 1,244 ( 0.05%) 0          0            333 ( 0.01%) 14 ( 0.26%) 10 ( 0.24%)  	ret = arena_malloc(tsdn, arena, size, ind, zero, tcache, slow_path);
 1,450 ( 0.02%)  15 ( 0.01%) 1 ( 0.01%)   192 ( 0.01%) 0          0            700 ( 0.02%)  0           0           	if (config_stats && is_internal && likely(ret != NULL)) {
   124 ( 0.00%)   0          0            119 ( 0.00%) 0          0              5 ( 0.00%)  0           0           		arena_internal_add(iaalloc(tsdn, ret), isalloc(tsdn, ret));
     .            .          .              .          .          .              .           .           .           	}
   151 ( 0.00%)  15 ( 0.01%) 1 ( 0.01%)    27 ( 0.00%) 0          0            119 ( 0.00%)  0           0           	return ret;
     .            .          .              .          .          .              .           .           .           }
     .            .          .              .          .          .              .           .           .           
     .            .          .              .          .          .              .           .           .           JEMALLOC_ALWAYS_INLINE void *
     .            .          .              .          .          .              .           .           .           ialloc(tsd_t *tsd, size_t size, szind_t ind, bool zero, bool slow_path) {
     .            .          .              .          .          .              .           .           .           	return iallocztm(tsd_tsdn(tsd), size, ind, zero, tcache_get(tsd), false,
     .            .          .              .          .          .              .           .           .           	    NULL, slow_path);
     .            .          .              .          .          .              .           .           .           }
     .            .          .              .          .          .              .           .           .           
     .            .          .              .          .          .              .           .           .           JEMALLOC_ALWAYS_INLINE void *
     .            .          .              .          .          .              .           .           .           ipallocztm(tsdn_t *tsdn, size_t usize, size_t alignment, bool zero,
     .            .          .              .          .          .              .           .           .               tcache_t *tcache, bool is_internal, arena_t *arena) {
     .            .          .              .          .          .              .           .           .           	void *ret;
     .            .          .              .          .          .              .           .           .           
 3,174 ( 0.03%)  40 ( 0.03%) 2 ( 0.03%)    12 ( 0.00%) 0          0            405 ( 0.01%)  0           0           	assert(usize != 0);
 2,926 ( 0.03%)  69 ( 0.05%) 3 ( 0.04%)   436 ( 0.02%) 0          0          1,411 ( 0.04%)  0           0           	assert(usize == sz_sa2u(usize, alignment));
 3,823 ( 0.04%)  17 ( 0.01%) 3 ( 0.04%)   396 ( 0.02%) 0          0          1,228 ( 0.04%)  0           0           	assert(!is_internal || tcache == NULL);
   242 ( 0.00%)   4 ( 0.00%) 3 ( 0.04%)   109 ( 0.00%) 0          0            117 ( 0.00%)  0           0           	assert(!is_internal || arena == NULL || arena_is_auto(arena));
 2,156 ( 0.02%)  65 ( 0.05%) 1 ( 0.01%)   913 ( 0.04%) 0          0          1,240 ( 0.04%)  0           0           	witness_assert_depth_to_rank(tsdn_witness_tsdp_get(tsdn),
     .            .          .              .          .          .              .           .           .           	    WITNESS_RANK_CORE, 0);
     .            .          .              .          .          .              .           .           .           
 2,529 ( 0.03%)  11 ( 0.01%) 2 ( 0.03%)   109 ( 0.00%) 0          0            917 ( 0.03%)  0           0           	ret = arena_palloc(tsdn, arena, usize, alignment, zero, tcache);
 1,666 ( 0.02%)   2 ( 0.00%) 0            417 ( 0.02%) 0          0              6 ( 0.00%)  0           0           	assert(ALIGNMENT_ADDR2BASE(ret, alignment) == ret);
 6,287 ( 0.07%)  24 ( 0.02%) 2 ( 0.03%) 2,714 ( 0.11%) 0          0          2,195 ( 0.07%)  0           0           	if (config_stats && is_internal && likely(ret != NULL)) {
     .            .          .              .          .          .              .           .           .           		arena_internal_add(iaalloc(tsdn, ret), isalloc(tsdn, ret));
     .            .          .              .          .          .              .           .           .           	}
     1 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)     1 ( 0.00%) 0          0              0           0           0           	return ret;
     .            .          .              .          .          .              .           .           .           }
     .            .          .              .          .          .              .           .           .           
     .            .          .              .          .          .              .           .           .           JEMALLOC_ALWAYS_INLINE void *
     .            .          .              .          .          .              .           .           .           ipalloct(tsdn_t *tsdn, size_t usize, size_t alignment, bool zero,
     .            .          .              .          .          .              .           .           .               tcache_t *tcache, arena_t *arena) {
 2,432 ( 0.03%)   0          0          1,259 ( 0.05%) 1 ( 0.02%) 0            244 ( 0.01%)  0           0           	return ipallocztm(tsdn, usize, alignment, zero, tcache, false, arena);
     .            .          .              .          .          .              .           .           .           }
     .            .          .              .          .          .              .           .           .           
     .            .          .              .          .          .              .           .           .           JEMALLOC_ALWAYS_INLINE void *
     .            .          .              .          .          .              .           .           .           ipalloc(tsd_t *tsd, size_t usize, size_t alignment, bool zero) {
     .            .          .              .          .          .              .           .           .           	return ipallocztm(tsd_tsdn(tsd), usize, alignment, zero,
     .            .          .              .          .          .              .           .           .           	    tcache_get(tsd), false, NULL);
     .            .          .              .          .          .              .           .           .           }
     .            .          .              .          .          .              .           .           .           
-- line 99 ----------------------------------------
-- line 123 ----------------------------------------
     .            .          .              .          .          .              .           .           .           JEMALLOC_ALWAYS_INLINE void
     .            .          .              .          .          .              .           .           .           idalloc(tsd_t *tsd, void *ptr) {
     .            .          .              .          .          .              .           .           .           	idalloctm(tsd_tsdn(tsd), ptr, tcache_get(tsd), NULL, false, true);
     .            .          .              .          .          .              .           .           .           }
     .            .          .              .          .          .              .           .           .           
     .            .          .              .          .          .              .           .           .           JEMALLOC_ALWAYS_INLINE void
     .            .          .              .          .          .              .           .           .           isdalloct(tsdn_t *tsdn, void *ptr, size_t size, tcache_t *tcache,
     .            .          .              .          .          .              .           .           .               emap_alloc_ctx_t *alloc_ctx, bool slow_path) {
   140 ( 0.00%)  28 ( 0.02%) 1 ( 0.01%)     0          0          0             35 ( 0.00%)  0           0           	witness_assert_depth_to_rank(tsdn_witness_tsdp_get(tsdn),
     .            .          .              .          .          .              .           .           .           	    WITNESS_RANK_CORE, 0);
   455 ( 0.00%)  19 ( 0.01%) 3 ( 0.04%)   245 ( 0.01%) 0          0            210 ( 0.01%)  4 ( 0.08%)  2 ( 0.05%)  	arena_sdalloc(tsdn, ptr, size, tcache, alloc_ctx, slow_path);
    95 ( 0.00%)  32 ( 0.02%) 2 ( 0.03%)    25 ( 0.00%) 0          0             30 ( 0.00%)  7 ( 0.13%)  2 ( 0.05%)  }
     .            .          .              .          .          .              .           .           .           
     .            .          .              .          .          .              .           .           .           JEMALLOC_ALWAYS_INLINE void *
     .            .          .              .          .          .              .           .           .           iralloct_realign(tsdn_t *tsdn, void *ptr, size_t oldsize, size_t size,
     .            .          .              .          .          .              .           .           .               size_t alignment, bool zero, tcache_t *tcache, arena_t *arena,
     .            .          .              .          .          .              .           .           .               hook_ralloc_args_t *hook_args) {
     .            .          .              .          .          .              .           .           .           	witness_assert_depth_to_rank(tsdn_witness_tsdp_get(tsdn),
     .            .          .              .          .          .              .           .           .           	    WITNESS_RANK_CORE, 0);
     .            .          .              .          .          .              .           .           .           	void *p;
-- line 142 ----------------------------------------
-- line 171 ----------------------------------------
     .            .          .              .          .          .              .           .           .            * correct entry point into any hooks.
     .            .          .              .          .          .              .           .           .            * Note that these functions are all force-inlined, so no actual bool gets
     .            .          .              .          .          .              .           .           .            * passed-around anywhere.
     .            .          .              .          .          .              .           .           .            */
     .            .          .              .          .          .              .           .           .           JEMALLOC_ALWAYS_INLINE void *
     .            .          .              .          .          .              .           .           .           iralloct(tsdn_t *tsdn, void *ptr, size_t oldsize, size_t size, size_t alignment,
     .            .          .              .          .          .              .           .           .               bool zero, tcache_t *tcache, arena_t *arena, hook_ralloc_args_t *hook_args)
     .            .          .              .          .          .              .           .           .           {
   392 ( 0.00%)   0          0              0          0          0              0           0           0           	assert(ptr != NULL);
   784 ( 0.01%) 196 ( 0.14%) 2 ( 0.03%)   196 ( 0.01%) 0          0            196 ( 0.01%)  1 ( 0.02%)  1 ( 0.02%)  	assert(size != 0);
   392 ( 0.00%)   0          0              0          0          0             98 ( 0.00%)  0           0           	witness_assert_depth_to_rank(tsdn_witness_tsdp_get(tsdn),
     .            .          .              .          .          .              .           .           .           	    WITNESS_RANK_CORE, 0);
     .            .          .              .          .          .              .           .           .           
   196 ( 0.00%)   0          0             98 ( 0.00%) 0          0              0           0           0           	if (alignment != 0 && ((uintptr_t)ptr & ((uintptr_t)alignment-1))
     .            .          .              .          .          .              .           .           .           	    != 0) {
     .            .          .              .          .          .              .           .           .           		/*
     .            .          .              .          .          .              .           .           .           		 * Existing object alignment is inadequate; allocate new space
     .            .          .              .          .          .              .           .           .           		 * and copy.
     .            .          .              .          .          .              .           .           .           		 */
     .            .          .              .          .          .              .           .           .           		return iralloct_realign(tsdn, ptr, oldsize, size, alignment,
     .            .          .              .          .          .              .           .           .           		    zero, tcache, arena, hook_args);
     .            .          .              .          .          .              .           .           .           	}
     .            .          .              .          .          .              .           .           .           
 1,372 ( 0.01%)  60 ( 0.04%) 2 ( 0.03%)   882 ( 0.04%) 0          0            392 ( 0.01%)  0           0           	return arena_ralloc(tsdn, arena, ptr, oldsize, size, alignment, zero,
     .            .          .              .          .          .              .           .           .           	    tcache, hook_args);
     .            .          .              .          .          .              .           .           .           }
     .            .          .              .          .          .              .           .           .           
     .            .          .              .          .          .              .           .           .           JEMALLOC_ALWAYS_INLINE void *
     .            .          .              .          .          .              .           .           .           iralloc(tsd_t *tsd, void *ptr, size_t oldsize, size_t size, size_t alignment,
     .            .          .              .          .          .              .           .           .               bool zero, hook_ralloc_args_t *hook_args) {
     .            .          .              .          .          .              .           .           .           	return iralloct(tsd_tsdn(tsd), ptr, oldsize, size, alignment, zero,
     .            .          .              .          .          .              .           .           .           	    tcache_get(tsd), NULL, hook_args);
-- line 202 ----------------------------------------
-- line 220 ----------------------------------------
     .            .          .              .          .          .              .           .           .           	return arena_ralloc_no_move(tsdn, ptr, oldsize, size, extra, zero,
     .            .          .              .          .          .              .           .           .           	    newsize);
     .            .          .              .          .          .              .           .           .           }
     .            .          .              .          .          .              .           .           .           
     .            .          .              .          .          .              .           .           .           JEMALLOC_ALWAYS_INLINE void
     .            .          .              .          .          .              .           .           .           fastpath_success_finish(tsd_t *tsd, uint64_t allocated_after,
     .            .          .              .          .          .              .           .           .               cache_bin_t *bin, void *ret) {
     .            .          .              .          .          .              .           .           .           	thread_allocated_set(tsd, allocated_after);
 2,736 ( 0.03%)   0          0              0          0          0              0           0           0           	if (config_stats) {
     .            .          .              .          .          .              .           .           .           		bin->tstats.nrequests++;
     .            .          .              .          .          .              .           .           .           	}
     .            .          .              .          .          .              .           .           .           
 2,736 ( 0.03%)  87 ( 0.06%) 1 ( 0.01%)     0          0          0              0           0           0           	LOG("core.malloc.exit", "result: %p", ret);
   912 ( 0.01%)  80 ( 0.06%) 0              0          0          0              0           0           0           }
     .            .          .              .          .          .              .           .           .           
     .            .          .              .          .          .              .           .           .           JEMALLOC_ALWAYS_INLINE bool
     .            .          .              .          .          .              .           .           .           malloc_initialized(void) {
 2,788 ( 0.03%)   0          0            929 ( 0.04%) 1 ( 0.02%) 0              0           0           0           	return (malloc_init_state == malloc_init_initialized);
     .            .          .              .          .          .              .           .           .           }
     .            .          .              .          .          .              .           .           .           
     .            .          .              .          .          .              .           .           .           /*
     .            .          .              .          .          .              .           .           .            * malloc() fastpath.  Included here so that we can inline it into operator new;
     .            .          .              .          .          .              .           .           .            * function call overhead there is non-negligible as a fraction of total CPU in
     .            .          .              .          .          .              .           .           .            * allocation-heavy C++ programs.  We take the fallback alloc to allow malloc
     .            .          .              .          .          .              .           .           .            * (which can return NULL) to differ in its behavior from operator new (which
     .            .          .              .          .          .              .           .           .            * can't).  It matches the signature of malloc / operator new so that we can
-- line 245 ----------------------------------------
-- line 251 ----------------------------------------
     .            .          .              .          .          .              .           .           .            * malloc_default().  Tail-calling is used to avoid any caller-saved
     .            .          .              .          .          .              .           .           .            * registers.
     .            .          .              .          .          .              .           .           .            *
     .            .          .              .          .          .              .           .           .            * fastpath supports ticker and profiling, both of which will also
     .            .          .              .          .          .              .           .           .            * tail-call to the slowpath if they fire.
     .            .          .              .          .          .              .           .           .            */
     .            .          .              .          .          .              .           .           .           JEMALLOC_ALWAYS_INLINE void *
     .            .          .              .          .          .              .           .           .           imalloc_fastpath(size_t size, void *(fallback_alloc)(size_t)) {
 2,787 ( 0.03%)  43 ( 0.03%) 1 ( 0.01%)     0          0          0              0           0           0           	LOG("core.malloc.entry", "size: %zu", size);
 1,858 ( 0.02%)   0          0              0          0          0              0           0           0           	if (tsd_get_allocates() && unlikely(!malloc_initialized())) {
   929 ( 0.01%) 432 ( 0.30%) 1 ( 0.01%)     0          0          0            929 ( 0.03%)  0           0           		return fallback_alloc(size);
     .            .          .              .          .          .              .           .           .           	}
     .            .          .              .          .          .              .           .           .           
   929 ( 0.01%)   0          0              0          0          0            929 ( 0.03%)  2 ( 0.04%)  0           	tsd_t *tsd = tsd_get(false);
 9,275 ( 0.10%) 430 ( 0.30%) 1 ( 0.01%) 1,855 ( 0.08%) 0          0              0           0           0           	if (unlikely((size > SC_LOOKUP_MAXCLASS) || tsd == NULL)) {
 7,423 ( 0.08%) 343 ( 0.24%) 1 ( 0.01%) 1,858 ( 0.08%) 0          0          3,707 ( 0.12%)  3 ( 0.06%)  0           		return fallback_alloc(size);
     .            .          .              .          .          .              .           .           .           	}
     .            .          .              .          .          .              .           .           .           	/*
     .            .          .              .          .          .              .           .           .           	 * The code below till the branch checking the next_event threshold may
     .            .          .              .          .          .              .           .           .           	 * execute before malloc_init(), in which case the threshold is 0 to
     .            .          .              .          .          .              .           .           .           	 * trigger slow path and initialization.
     .            .          .              .          .          .              .           .           .           	 *
     .            .          .              .          .          .              .           .           .           	 * Note that when uninitialized, only the fast-path variants of the sz /
     .            .          .              .          .          .              .           .           .           	 * tsd facilities may be called.
-- line 274 ----------------------------------------
-- line 278 ----------------------------------------
     .            .          .              .          .          .              .           .           .           	 * The thread_allocated counter in tsd serves as a general purpose
     .            .          .              .          .          .              .           .           .           	 * accumulator for bytes of allocation to trigger different types of
     .            .          .              .          .          .              .           .           .           	 * events.  usize is always needed to advance thread_allocated, though
     .            .          .              .          .          .              .           .           .           	 * it's not always needed in the core allocation logic.
     .            .          .              .          .          .              .           .           .           	 */
     .            .          .              .          .          .              .           .           .           	size_t usize;
     .            .          .              .          .          .              .           .           .           	sz_size2index_usize_fastpath(size, &ind, &usize);
     .            .          .              .          .          .              .           .           .           	/* Fast path relies on size being a bin. */
 3,704 ( 0.04%)   0          0              0          0          0              0           0           0           	assert(ind < SC_NBINS);
11,112 ( 0.12%) 260 ( 0.18%) 3 ( 0.04%) 1,852 ( 0.08%) 0          0          3,704 ( 0.12%)  2 ( 0.04%)  0           	assert((SC_LOOKUP_MAXCLASS < SC_SMALL_MAXCLASS) &&
     .            .          .              .          .          .              .           .           .           	    (size <= SC_SMALL_MAXCLASS));
     .            .          .              .          .          .              .           .           .           
     .            .          .              .          .          .              .           .           .           	uint64_t allocated, threshold;
     .            .          .              .          .          .              .           .           .           	te_malloc_fastpath_ctx(tsd, &allocated, &threshold);
 3,704 ( 0.04%)   0          0          1,852 ( 0.08%) 0          0            926 ( 0.03%)  0           0           	uint64_t allocated_after = allocated + usize;
     .            .          .              .          .          .              .           .           .           	/*
     .            .          .              .          .          .              .           .           .           	 * The ind and usize might be uninitialized (or partially) before
     .            .          .              .          .          .              .           .           .           	 * malloc_init().  The assertions check for: 1) full correctness (usize
     .            .          .              .          .          .              .           .           .           	 * & ind) when initialized; and 2) guaranteed slow-path (threshold == 0)
     .            .          .              .          .          .              .           .           .           	 * when !initialized.
     .            .          .              .          .          .              .           .           .           	 */
 2,778 ( 0.03%)   0          0              0          0          0              0           0           0           	if (!malloc_initialized()) {
     .            .          .              .          .          .              .           .           .           		assert(threshold == 0);
     .            .          .              .          .          .              .           .           .           	} else {
 3,704 ( 0.04%) 251 ( 0.17%) 1 ( 0.01%)     0          0          0              0           0           0           		assert(ind == sz_size2index(size));
 3,704 ( 0.04%)  39 ( 0.03%) 1 ( 0.01%)     0          0          0              0           0           0           		assert(usize > 0 && usize == sz_index2size(ind));
     .            .          .              .          .          .              .           .           .           	}
     .            .          .              .          .          .              .           .           .           	/*
     .            .          .              .          .          .              .           .           .           	 * Check for events and tsd non-nominal (fast_threshold will be set to
     .            .          .              .          .          .              .           .           .           	 * 0) in a single branch.
     .            .          .              .          .          .              .           .           .           	 */
 5,556 ( 0.06%)  75 ( 0.05%) 1 ( 0.01%) 1,852 ( 0.08%) 0          0              0           0           0           	if (unlikely(allocated_after >= threshold)) {
     5 ( 0.00%)   1 ( 0.00%) 0              2 ( 0.00%) 0          0              1 ( 0.00%)  1 ( 0.02%)  0           		return fallback_alloc(size);
     .            .          .              .          .          .              .           .           .           	}
 7,400 ( 0.08%) 339 ( 0.24%) 3 ( 0.04%) 1,850 ( 0.08%) 0          0          1,850 ( 0.06%)  6 ( 0.11%)  0           	assert(tsd_fast(tsd));
     .            .          .              .          .          .              .           .           .           
   925 ( 0.01%)   0          0              0          0          0            925 ( 0.03%)  0           0           	tcache_t *tcache = tsd_tcachep_get(tsd);
 3,700 ( 0.04%)   0          0              0          0          0              0           0           0           	assert(tcache == tcache_get(tsd));
17,575 ( 0.19%) 308 ( 0.21%) 2 ( 0.03%) 4,625 ( 0.19%) 0          0          5,550 ( 0.18%)  2 ( 0.04%)  0           	cache_bin_t *bin = &tcache->bins[ind];
     .            .          .              .          .          .              .           .           .           	bool tcache_success;
     .            .          .              .          .          .              .           .           .           	void *ret;
     .            .          .              .          .          .              .           .           .           
     .            .          .              .          .          .              .           .           .           	/*
     .            .          .              .          .          .              .           .           .           	 * We split up the code this way so that redundant low-water
     .            .          .              .          .          .              .           .           .           	 * computation doesn't happen on the (more common) case in which we
     .            .          .              .          .          .              .           .           .           	 * don't touch the low water mark.  The compiler won't do this
     .            .          .              .          .          .              .           .           .           	 * duplication on its own.
     .            .          .              .          .          .              .           .           .           	 */
   925 ( 0.01%)   0          0              0          0          0            925 ( 0.03%)  0           0           	ret = cache_bin_alloc_easy(bin, &tcache_success);
16,807 ( 0.18%) 372 ( 0.26%) 2 ( 0.03%) 7,941 ( 0.33%) 0          0          7,016 ( 0.22%)  0           0           	if (tcache_success) {
     .            .          .              .          .          .              .           .           .           		fastpath_success_finish(tsd, allocated_after, bin, ret);
 2,186 ( 0.02%)  39 ( 0.03%) 2 ( 0.03%) 1,021 ( 0.04%) 0          0            240 ( 0.01%)  0           0           		return ret;
     .            .          .              .          .          .              .           .           .           	}
    48 ( 0.00%)   0          0              0          0          0             48 ( 0.00%)  0           0           	ret = cache_bin_alloc(bin, &tcache_success);
   704 ( 0.01%)  12 ( 0.01%) 1 ( 0.01%)   328 ( 0.01%) 0          0            280 ( 0.01%)  0           0           	if (tcache_success) {
     .            .          .              .          .          .              .           .           .           		fastpath_success_finish(tsd, allocated_after, bin, ret);
    70 ( 0.00%)   0          0             35 ( 0.00%) 0          0              0           0           0           		return ret;
     .            .          .              .          .          .              .           .           .           	}
     .            .          .              .          .          .              .           .           .           
    52 ( 0.00%)  15 ( 0.01%) 2 ( 0.03%)    26 ( 0.00%) 0          0             13 ( 0.00%)  3 ( 0.06%)  0           	return fallback_alloc(size);
     .            .          .              .          .          .              .           .           .           }
     .            .          .              .          .          .              .           .           .           
     .            .          .              .          .          .              .           .           .           #endif /* JEMALLOC_INTERNAL_INLINES_C_H */

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/ashy5000/dev/cryptocurrency/contracts/target/debug/build/tikv-jemalloc-sys-7365f40ecb99e085/out/build/include/jemalloc/internal/cache_bin.h
--------------------------------------------------------------------------------
Ir             I1mr         ILmr       Dr             D1mr        DLmr        Dw             D1mw        DLmw       

-- line 145 ----------------------------------------
    .            .          .              .           .           .              .           .          .           cache_bin_array_descriptor_init(cache_bin_array_descriptor_t *descriptor,
    .            .          .              .           .           .              .           .          .               cache_bin_t *bins) {
    .            .          .              .           .           .              .           .          .           	ql_elm_new(descriptor, link);
    .            .          .              .           .           .              .           .          .           	descriptor->bins = bins;
    .            .          .              .           .           .              .           .          .           }
    .            .          .              .           .           .              .           .          .           
    .            .          .              .           .           .              .           .          .           JEMALLOC_ALWAYS_INLINE bool
    .            .          .              .           .           .              .           .          .           cache_bin_nonfast_aligned(const void *ptr) {
  228 ( 0.00%)  28 ( 0.02%) 1 ( 0.01%)     0           0           0              0           0          0           	if (!config_uaf_detection) {
  114 ( 0.00%)   0          0              0           0           0              0           0          0           		return false;
    .            .          .              .           .           .              .           .          .           	}
    .            .          .              .           .           .              .           .          .           	/*
    .            .          .              .           .           .              .           .          .           	 * Currently we use alignment to decide which pointer to junk & stash on
    .            .          .              .           .           .              .           .          .           	 * dealloc (for catching use-after-free).  In some common cases a
    .            .          .              .           .           .              .           .          .           	 * page-aligned check is needed already (sdalloc w/ config_prof), so we
    .            .          .              .           .           .              .           .          .           	 * are getting it more or less for free -- no added instructions on
    .            .          .              .           .           .              .           .          .           	 * free_fastpath.
    .            .          .              .           .           .              .           .          .           	 *
-- line 162 ----------------------------------------
-- line 165 ----------------------------------------
    .            .          .              .           .           .              .           .          .           	 * the fastpath, however it will tend to pick large allocations which is
    .            .          .              .           .           .              .           .          .           	 * not the desired behavior.
    .            .          .              .           .           .              .           .          .           	 */
    .            .          .              .           .           .              .           .          .           	return ((uintptr_t)ptr & san_cache_bin_nonfast_mask) == 0;
    .            .          .              .           .           .              .           .          .           }
    .            .          .              .           .           .              .           .          .           
    .            .          .              .           .           .              .           .          .           /* Returns ncached_max: Upper limit on ncached. */
    .            .          .              .           .           .              .           .          .           static inline cache_bin_sz_t
  252 ( 0.00%)  37 ( 0.03%) 2 ( 0.03%)     0           0           0            168 ( 0.01%)  0          0           cache_bin_info_ncached_max(cache_bin_info_t *info) {
  168 ( 0.00%)   0          0            168 ( 0.01%)  9 ( 0.16%)  0              0           0          0           	return info->ncached_max;
  168 ( 0.00%)   0          0            168 ( 0.01%)  0           0              0           0          0           }
    .            .          .              .           .           .              .           .          .           
    .            .          .              .           .           .              .           .          .           /*
    .            .          .              .           .           .              .           .          .            * Internal.
    .            .          .              .           .           .              .           .          .            *
    .            .          .              .           .           .              .           .          .            * Asserts that the pointer associated with earlier is <= the one associated
    .            .          .              .           .           .              .           .          .            * with later.
    .            .          .              .           .           .              .           .          .            */
    .            .          .              .           .           .              .           .          .           static inline void
9,990 ( 0.11%) 366 ( 0.25%) 5 ( 0.07%)     0           0           0          4,440 ( 0.14%)  6 ( 0.11%) 2 ( 0.05%)  cache_bin_assert_earlier(cache_bin_t *bin, uint16_t earlier, uint16_t later) {
3,330 ( 0.04%)   0          0          2,220 ( 0.09%)  0           0              0           0          0           	if (earlier > later) {
    .            .          .              .           .           .              .           .          .           		assert(bin->low_bits_full > bin->low_bits_empty);
    .            .          .              .           .           .              .           .          .           	}
3,330 ( 0.04%) 235 ( 0.16%) 2 ( 0.03%) 2,220 ( 0.09%)  0           0              0           0          0           }
    .            .          .              .           .           .              .           .          .           
    .            .          .              .           .           .              .           .          .           /*
    .            .          .              .           .           .              .           .          .            * Internal.
    .            .          .              .           .           .              .           .          .            *
    .            .          .              .           .           .              .           .          .            * Does difference calculations that handle wraparound correctly.  Earlier must
    .            .          .              .           .           .              .           .          .            * be associated with the position earlier in memory.
    .            .          .              .           .           .              .           .          .            */
    .            .          .              .           .           .              .           .          .           static inline uint16_t
1,341 ( 0.01%)  58 ( 0.04%) 4 ( 0.06%)     0           0           0            745 ( 0.02%)  7 ( 0.13%) 3 ( 0.07%)  cache_bin_diff(cache_bin_t *bin, uint16_t earlier, uint16_t later, bool racy) {
    .            .          .              .           .           .              .           .          .           	/*
    .            .          .              .           .           .              .           .          .           	 * When it's racy, bin->low_bits_full can be modified concurrently. It
    .            .          .              .           .           .              .           .          .           	 * can cross the uint16_t max value and become less than
    .            .          .              .           .           .              .           .          .           	 * bin->low_bits_empty at the time of the check.
    .            .          .              .           .           .              .           .          .           	 */
  596 ( 0.01%)  35 ( 0.02%) 1 ( 0.01%)   149 ( 0.01%)  0           0              0           0          0           	if (!racy) {
  894 ( 0.01%)   0          0            447 ( 0.02%)  0           0            149 ( 0.00%)  2 ( 0.04%) 1 ( 0.02%)  		cache_bin_assert_earlier(bin, earlier, later);
    .            .          .              .           .           .              .           .          .           	}
  298 ( 0.00%)   0          0            298 ( 0.01%)  0           0              0           0          0           	return later - earlier;
  298 ( 0.00%)   0          0            298 ( 0.01%)  0           0              0           0          0           }
    .            .          .              .           .           .              .           .          .           
    .            .          .              .           .           .              .           .          .           /*
    .            .          .              .           .           .              .           .          .            * Number of items currently cached in the bin, without checking ncached_max.
    .            .          .              .           .           .              .           .          .            * We require specifying whether or not the request is racy or not (i.e. whether
    .            .          .              .           .           .              .           .          .            * or not concurrent modifications are possible).
    .            .          .              .           .           .              .           .          .            */
    .            .          .              .           .           .              .           .          .           static inline cache_bin_sz_t
  132 ( 0.00%)  22 ( 0.02%) 1 ( 0.01%)     0           0           0             66 ( 0.00%)  2 ( 0.04%) 2 ( 0.05%)  cache_bin_ncached_get_internal(cache_bin_t *bin, bool racy) {
  154 ( 0.00%)  22 ( 0.02%) 1 ( 0.01%)    44 ( 0.00%)  0           0             44 ( 0.00%)  1 ( 0.02%) 1 ( 0.02%)  	cache_bin_sz_t diff = cache_bin_diff(bin,
   88 ( 0.00%)   0          0             88 ( 0.00%)  0           0              0           0          0           	    (uint16_t)(uintptr_t)bin->stack_head, bin->low_bits_empty, racy);
   66 ( 0.00%)   0          0             22 ( 0.00%)  0           0             22 ( 0.00%)  0          0           	cache_bin_sz_t n = diff / sizeof(void *);
    .            .          .              .           .           .              .           .          .           	/*
    .            .          .              .           .           .              .           .          .           	 * We have undefined behavior here; if this function is called from the
    .            .          .              .           .           .              .           .          .           	 * arena stats updating code, then stack_head could change from the
    .            .          .              .           .           .              .           .          .           	 * first line to the next one.  Morally, these loads should be atomic,
    .            .          .              .           .           .              .           .          .           	 * but compilers won't currently generate comparisons with in-memory
    .            .          .              .           .           .              .           .          .           	 * operands against atomics, and these variables get accessed on the
    .            .          .              .           .           .              .           .          .           	 * fast paths.  This should still be "safe" in the sense of generating
    .            .          .              .           .           .              .           .          .           	 * the correct assembly for the foreseeable future, though.
    .            .          .              .           .           .              .           .          .           	 */
   88 ( 0.00%)   0          0              0           0           0              0           0          0           	assert(n == 0 || *(bin->stack_head) != NULL || racy);
   22 ( 0.00%)   0          0             22 ( 0.00%)  0           0              0           0          0           	return n;
   44 ( 0.00%)   0          0             44 ( 0.00%)  0           0              0           0          0           }
    .            .          .              .           .           .              .           .          .           
    .            .          .              .           .           .              .           .          .           /*
    .            .          .              .           .           .              .           .          .            * Number of items currently cached in the bin, with checking ncached_max.  The
    .            .          .              .           .           .              .           .          .            * caller must know that no concurrent modification of the cache_bin is
    .            .          .              .           .           .              .           .          .            * possible.
    .            .          .              .           .           .              .           .          .            */
    .            .          .              .           .           .              .           .          .           static inline cache_bin_sz_t
  110 ( 0.00%)  44 ( 0.03%) 2 ( 0.03%)     0           0           0             66 ( 0.00%)  3 ( 0.06%) 1 ( 0.02%)  cache_bin_ncached_get_local(cache_bin_t *bin, cache_bin_info_t *info) {
  110 ( 0.00%)   0          0             22 ( 0.00%)  0           0             44 ( 0.00%)  1 ( 0.02%) 1 ( 0.02%)  	cache_bin_sz_t n = cache_bin_ncached_get_internal(bin,
    .            .          .              .           .           .              .           .          .           	    /* racy */ false);
   88 ( 0.00%)   0          0              0           0           0              0           0          0           	assert(n <= cache_bin_info_ncached_max(info));
   22 ( 0.00%)  22 ( 0.02%) 1 ( 0.01%)    22 ( 0.00%)  0           0              0           0          0           	return n;
   44 ( 0.00%)   0          0             44 ( 0.00%)  0           0              0           0          0           }
    .            .          .              .           .           .              .           .          .           
    .            .          .              .           .           .              .           .          .           /*
    .            .          .              .           .           .              .           .          .            * Internal.
    .            .          .              .           .           .              .           .          .            *
    .            .          .              .           .           .              .           .          .            * A pointer to the position one past the end of the backing array.
    .            .          .              .           .           .              .           .          .            *
    .            .          .              .           .           .              .           .          .            * Do not call if racy, because both 'bin->stack_head' and 'bin->low_bits_full'
    .            .          .              .           .           .              .           .          .            * are subject to concurrent modifications.
    .            .          .              .           .           .              .           .          .            */
    .            .          .              .           .           .              .           .          .           static inline void **
  248 ( 0.00%)  57 ( 0.04%) 2 ( 0.03%)     0           0           0            124 ( 0.00%)  7 ( 0.13%) 2 ( 0.05%)  cache_bin_empty_position_get(cache_bin_t *bin) {
  434 ( 0.00%)  35 ( 0.02%) 1 ( 0.01%)    62 ( 0.00%)  0           0            124 ( 0.00%)  1 ( 0.02%) 1 ( 0.02%)  	cache_bin_sz_t diff = cache_bin_diff(bin,
  248 ( 0.00%)   0          0            248 ( 0.01%)  0           0              0           0          0           	    (uint16_t)(uintptr_t)bin->stack_head, bin->low_bits_empty,
    .            .          .              .           .           .              .           .          .           	    /* racy */ false);
  372 ( 0.00%)  22 ( 0.02%) 1 ( 0.01%)   186 ( 0.01%)  0           0             62 ( 0.00%)  0          0           	uintptr_t empty_bits = (uintptr_t)bin->stack_head + diff;
  124 ( 0.00%)   0          0             62 ( 0.00%)  0           0             62 ( 0.00%)  0          0           	void **ret = (void **)empty_bits;
    .            .          .              .           .           .              .           .          .           
  248 ( 0.00%)   0          0              0           0           0              0           0          0           	assert(ret >= bin->stack_head);
    .            .          .              .           .           .              .           .          .           
   62 ( 0.00%)  34 ( 0.02%) 1 ( 0.01%)    62 ( 0.00%)  0           0              0           0          0           	return ret;
  124 ( 0.00%)   0          0            124 ( 0.01%)  0           0              0           0          0           }
    .            .          .              .           .           .              .           .          .           
    .            .          .              .           .           .              .           .          .           /*
    .            .          .              .           .           .              .           .          .            * Internal.
    .            .          .              .           .           .              .           .          .            *
    .            .          .              .           .           .              .           .          .            * Calculates low bits of the lower bound of the usable cache bin's range (see
    .            .          .              .           .           .              .           .          .            * cache_bin_t visual representation above).
    .            .          .              .           .           .              .           .          .            *
    .            .          .              .           .           .              .           .          .            * No values are concurrently modified, so should be safe to read in a
    .            .          .              .           .           .              .           .          .            * multithreaded environment. Currently concurrent access happens only during
    .            .          .              .           .           .              .           .          .            * arena statistics collection.
    .            .          .              .           .           .              .           .          .            */
    .            .          .              .           .           .              .           .          .           static inline uint16_t
   88 ( 0.00%)  22 ( 0.02%) 1 ( 0.01%)     0           0           0             66 ( 0.00%)  0          0           cache_bin_low_bits_low_bound_get(cache_bin_t *bin, cache_bin_info_t *info) {
   88 ( 0.00%)   0          0             44 ( 0.00%)  0           0              0           0          0           	return (uint16_t)bin->low_bits_empty -
   66 ( 0.00%)  22 ( 0.02%) 1 ( 0.01%)    44 ( 0.00%)  0           0              0           0          0           	    info->ncached_max * sizeof(void *);
   44 ( 0.00%)   0          0             44 ( 0.00%)  0           0              0           0          0           }
    .            .          .              .           .           .              .           .          .           
    .            .          .              .           .           .              .           .          .           /*
    .            .          .              .           .           .              .           .          .            * Internal.
    .            .          .              .           .           .              .           .          .            *
    .            .          .              .           .           .              .           .          .            * A pointer to the position with the lowest address of the backing array.
    .            .          .              .           .           .              .           .          .            */
    .            .          .              .           .           .              .           .          .           static inline void **
  110 ( 0.00%)   0          0              0           0           0             66 ( 0.00%)  0          0           cache_bin_low_bound_get(cache_bin_t *bin, cache_bin_info_t *info) {
   88 ( 0.00%)   0          0             22 ( 0.00%)  0           0             44 ( 0.00%)  0          0           	cache_bin_sz_t ncached_max = cache_bin_info_ncached_max(info);
  176 ( 0.00%)  22 ( 0.02%) 1 ( 0.01%)    44 ( 0.00%)  0           0             44 ( 0.00%)  0          0           	void **ret = cache_bin_empty_position_get(bin) - ncached_max;
   88 ( 0.00%)   0          0              0           0           0              0           0          0           	assert(ret <= bin->stack_head);
    .            .          .              .           .           .              .           .          .           
   22 ( 0.00%)  22 ( 0.02%) 1 ( 0.01%)    22 ( 0.00%)  0           0              0           0          0           	return ret;
   44 ( 0.00%)   0          0             44 ( 0.00%)  0           0              0           0          0           }
    .            .          .              .           .           .              .           .          .           
    .            .          .              .           .           .              .           .          .           /*
    .            .          .              .           .           .              .           .          .            * As the name implies.  This is important since it's not correct to try to
    .            .          .              .           .           .              .           .          .            * batch fill a nonempty cache bin.
    .            .          .              .           .           .              .           .          .            */
    .            .          .              .           .           .              .           .          .           static inline void
  200 ( 0.00%)  68 ( 0.05%) 2 ( 0.03%)     0           0           0            120 ( 0.00%)  1 ( 0.02%) 0           cache_bin_assert_empty(cache_bin_t *bin, cache_bin_info_t *info) {
  160 ( 0.00%)   0          0              0           0           0              0           0          0           	assert(cache_bin_ncached_get_local(bin, info) == 0);
  160 ( 0.00%)  34 ( 0.02%) 1 ( 0.01%)     0           0           0              0           0          0           	assert(cache_bin_empty_position_get(bin) == bin->stack_head);
  120 ( 0.00%)  34 ( 0.02%) 1 ( 0.01%)    80 ( 0.00%)  0           0              0           0          0           }
    .            .          .              .           .           .              .           .          .           
    .            .          .              .           .           .              .           .          .           /*
    .            .          .              .           .           .              .           .          .            * Get low water, but without any of the correctness checking we do for the
    .            .          .              .           .           .              .           .          .            * caller-usable version, if we are temporarily breaking invariants (like
    .            .          .              .           .           .              .           .          .            * ncached >= low_water during flush).
    .            .          .              .           .           .              .           .          .            */
    .            .          .              .           .           .              .           .          .           static inline cache_bin_sz_t
    8 ( 0.00%)   2 ( 0.00%) 1 ( 0.01%)     0           0           0              4 ( 0.00%)  0          0           cache_bin_low_water_get_internal(cache_bin_t *bin) {
   16 ( 0.00%)   0          0              6 ( 0.00%)  0           0              2 ( 0.00%)  0          0           	return cache_bin_diff(bin, bin->low_bits_low_water,
    6 ( 0.00%)   0          0              4 ( 0.00%)  0           0              0           0          0           	    bin->low_bits_empty, /* racy */ false) / sizeof(void *);
    4 ( 0.00%)   0          0              4 ( 0.00%)  0           0              0           0          0           }
    .            .          .              .           .           .              .           .          .           
    .            .          .              .           .           .              .           .          .           /* Returns the numeric value of low water in [0, ncached]. */
    .            .          .              .           .           .              .           .          .           static inline cache_bin_sz_t
   10 ( 0.00%)   4 ( 0.00%) 2 ( 0.03%)     0           0           0              6 ( 0.00%)  0          0           cache_bin_low_water_get(cache_bin_t *bin, cache_bin_info_t *info) {
    8 ( 0.00%)   0          0              2 ( 0.00%)  0           0              4 ( 0.00%)  0          0           	cache_bin_sz_t low_water = cache_bin_low_water_get_internal(bin);
    8 ( 0.00%)   0          0              0           0           0              0           0          0           	assert(low_water <= cache_bin_info_ncached_max(info));
    8 ( 0.00%)   2 ( 0.00%) 1 ( 0.01%)     0           0           0              0           0          0           	assert(low_water <= cache_bin_ncached_get_local(bin, info));
    .            .          .              .           .           .              .           .          .           
   16 ( 0.00%)   0          0              6 ( 0.00%)  0           0              2 ( 0.00%)  0          0           	cache_bin_assert_earlier(bin, (uint16_t)(uintptr_t)bin->stack_head,
    4 ( 0.00%)   2 ( 0.00%) 1 ( 0.01%)     4 ( 0.00%)  0           0              0           0          0           	    bin->low_bits_low_water);
    .            .          .              .           .           .              .           .          .           
    2 ( 0.00%)   0          0              2 ( 0.00%)  0           0              0           0          0           	return low_water;
    4 ( 0.00%)   0          0              4 ( 0.00%)  0           0              0           0          0           }
    .            .          .              .           .           .              .           .          .           
    .            .          .              .           .           .              .           .          .           /*
    .            .          .              .           .           .              .           .          .            * Indicates that the current cache bin position should be the low water mark
    .            .          .              .           .           .              .           .          .            * going forward.
    .            .          .              .           .           .              .           .          .            */
    .            .          .              .           .           .              .           .          .           static inline void
    6 ( 0.00%)   2 ( 0.00%) 1 ( 0.01%)     0           0           0              4 ( 0.00%)  0          0           cache_bin_low_water_set(cache_bin_t *bin) {
   10 ( 0.00%)   0          0              6 ( 0.00%)  0           0              2 ( 0.00%)  0          0           	bin->low_bits_low_water = (uint16_t)(uintptr_t)bin->stack_head;
    6 ( 0.00%)   0          0              4 ( 0.00%)  0           0              0           0          0           }
    .            .          .              .           .           .              .           .          .           
    .            .          .              .           .           .              .           .          .           static inline void
    .            .          .              .           .           .              .           .          .           cache_bin_low_water_adjust(cache_bin_t *bin) {
    .            .          .              .           .           .              .           .          .           	if (cache_bin_ncached_get_internal(bin, /* racy */ false)
    .            .          .              .           .           .              .           .          .           	    < cache_bin_low_water_get_internal(bin)) {
    .            .          .              .           .           .              .           .          .           		cache_bin_low_water_set(bin);
    .            .          .              .           .           .              .           .          .           	}
    .            .          .              .           .           .              .           .          .           }
-- line 345 ----------------------------------------
-- line 353 ----------------------------------------
    .            .          .              .           .           .              .           .          .           	 * and eagerly checking ret would cause pipeline stall (waiting for the
    .            .          .              .           .           .              .           .          .           	 * cacheline).
    .            .          .              .           .           .              .           .          .           	 */
    .            .          .              .           .           .              .           .          .           
    .            .          .              .           .           .              .           .          .           	/*
    .            .          .              .           .           .              .           .          .           	 * This may read from the empty position; however the loaded value won't
    .            .          .              .           .           .              .           .          .           	 * be used.  It's safe because the stack has one more slot reserved.
    .            .          .              .           .           .              .           .          .           	 */
4,688 ( 0.05%) 235 ( 0.16%) 1 ( 0.01%) 3,383 ( 0.14%) 52 ( 0.90%) 17 ( 0.47%) 1,305 ( 0.04%)  0          0           	void *ret = *bin->stack_head;
3,844 ( 0.04%)  43 ( 0.03%) 2 ( 0.03%) 2,607 ( 0.11%)  0           0          1,138 ( 0.04%)  2 ( 0.04%) 2 ( 0.05%)  	uint16_t low_bits = (uint16_t)(uintptr_t)bin->stack_head;
5,607 ( 0.06%)  28 ( 0.02%) 2 ( 0.03%) 2,804 ( 0.12%)  0           0          1,763 ( 0.06%)  0          0           	void **new_head = bin->stack_head + 1;
    .            .          .              .           .           .              .           .          .           
    .            .          .              .           .           .              .           .          .           	/*
    .            .          .              .           .           .              .           .          .           	 * Note that the low water mark is at most empty; if we pass this check,
    .            .          .              .           .           .              .           .          .           	 * we know we're non-empty.
    .            .          .              .           .           .              .           .          .           	 */
8,268 ( 0.09%) 231 ( 0.16%) 5 ( 0.07%) 3,481 ( 0.14%)  3 ( 0.05%)  0            626 ( 0.02%)  0          0           	if (likely(low_bits != bin->low_bits_low_water)) {
3,133 ( 0.03%)  24 ( 0.02%) 0          1,848 ( 0.08%)  0           0          1,187 ( 0.04%)  0          0           		bin->stack_head = new_head;
2,382 ( 0.03%)  39 ( 0.03%) 1 ( 0.01%)   927 ( 0.04%)  0           0          1,191 ( 0.04%)  1 ( 0.02%) 1 ( 0.02%)  		*success = true;
3,818 ( 0.04%)   0          0          1,187 ( 0.05%)  0           0            722 ( 0.02%)  0          0           		return ret;
    .            .          .              .           .           .              .           .          .           	}
  468 ( 0.00%)  41 ( 0.03%) 3 ( 0.04%)   119 ( 0.00%)  0           0              1 ( 0.00%)  0          0           	if (!adjust_low_water) {
   97 ( 0.00%)   0          0             48 ( 0.00%)  0           0             48 ( 0.00%)  0          0           		*success = false;
1,216 ( 0.01%)  22 ( 0.02%) 2 ( 0.03%)   493 ( 0.02%)  0           0            626 ( 0.02%)  0          0           		return NULL;
    .            .          .              .           .           .              .           .          .           	}
    .            .          .              .           .           .              .           .          .           	/*
    .            .          .              .           .           .              .           .          .           	 * In the fast-path case where we call alloc_easy and then alloc, the
    .            .          .              .           .           .              .           .          .           	 * previous checking and computation is optimized away -- we didn't
    .            .          .              .           .           .              .           .          .           	 * actually commit any of our operations.
    .            .          .              .           .           .              .           .          .           	 */
1,148 ( 0.01%)  68 ( 0.05%) 4 ( 0.06%)   467 ( 0.02%)  0           0            362 ( 0.01%)  0          0           	if (likely(low_bits != bin->low_bits_empty)) {
  415 ( 0.00%)   0          0             70 ( 0.00%)  0           0            345 ( 0.01%)  0          0           		bin->stack_head = new_head;
1,023 ( 0.01%)   0          0            333 ( 0.01%)  0           0            608 ( 0.02%)  0          0           		bin->low_bits_low_water = (uint16_t)(uintptr_t)new_head;
  597 ( 0.01%)  16 ( 0.01%) 1 ( 0.01%)   299 ( 0.01%)  0           0            298 ( 0.01%)  0          0           		*success = true;
  380 ( 0.00%)   0          0             82 ( 0.00%)  0           0            263 ( 0.01%)  0          0           		return ret;
    .            .          .              .           .           .              .           .          .           	}
  418 ( 0.00%)  31 ( 0.02%) 3 ( 0.04%)   297 ( 0.01%)  0           0            121 ( 0.00%)  1 ( 0.02%) 0           	*success = false;
  301 ( 0.00%)   0          0              2 ( 0.00%)  0           0            263 ( 0.01%)  0          0           	return NULL;
    .            .          .              .           .           .              .           .          .           }
    .            .          .              .           .           .              .           .          .           
    .            .          .              .           .           .              .           .          .           /*
    .            .          .              .           .           .              .           .          .            * Allocate an item out of the bin, failing if we're at the low-water mark.
    .            .          .              .           .           .              .           .          .            */
    .            .          .              .           .           .              .           .          .           JEMALLOC_ALWAYS_INLINE void *
    .            .          .              .           .           .              .           .          .           cache_bin_alloc_easy(cache_bin_t *bin, bool *success) {
    .            .          .              .           .           .              .           .          .           	/* We don't look at info if we're not adjusting low-water. */
  925 ( 0.01%)  69 ( 0.05%) 1 ( 0.01%)     0           0           0              0           0          0           	return cache_bin_alloc_impl(bin, success, false);
    .            .          .              .           .           .              .           .          .           }
    .            .          .              .           .           .              .           .          .           
    .            .          .              .           .           .              .           .          .           /*
    .            .          .              .           .           .              .           .          .            * Allocate an item out of the bin, even if we're currently at the low-water
    .            .          .              .           .           .              .           .          .            * mark (and failing only if the bin is empty).
    .            .          .              .           .           .              .           .          .            */
    .            .          .              .           .           .              .           .          .           JEMALLOC_ALWAYS_INLINE void *
    .            .          .              .           .           .              .           .          .           cache_bin_alloc(cache_bin_t *bin, bool *success) {
  641 ( 0.01%)  44 ( 0.03%) 1 ( 0.01%)     0           0           0            526 ( 0.02%)  0          0           	return cache_bin_alloc_impl(bin, success, true);
    .            .          .              .           .           .              .           .          .           }
    .            .          .              .           .           .              .           .          .           
    .            .          .              .           .           .              .           .          .           JEMALLOC_ALWAYS_INLINE cache_bin_sz_t
    .            .          .              .           .           .              .           .          .           cache_bin_alloc_batch(cache_bin_t *bin, size_t num, void **out) {
    .            .          .              .           .           .              .           .          .           	cache_bin_sz_t n = cache_bin_ncached_get_internal(bin,
    .            .          .              .           .           .              .           .          .           	    /* racy */ false);
    .            .          .              .           .           .              .           .          .           	if (n > num) {
    .            .          .              .           .           .              .           .          .           		n = (cache_bin_sz_t)num;
-- line 416 ----------------------------------------
-- line 419 ----------------------------------------
    .            .          .              .           .           .              .           .          .           	bin->stack_head += n;
    .            .          .              .           .           .              .           .          .           	cache_bin_low_water_adjust(bin);
    .            .          .              .           .           .              .           .          .           
    .            .          .              .           .           .              .           .          .           	return n;
    .            .          .              .           .           .              .           .          .           }
    .            .          .              .           .           .              .           .          .           
    .            .          .              .           .           .              .           .          .           JEMALLOC_ALWAYS_INLINE bool
    .            .          .              .           .           .              .           .          .           cache_bin_full(cache_bin_t *bin) {
6,713 ( 0.07%)   3 ( 0.00%) 1 ( 0.01%) 3,836 ( 0.16%)  5 ( 0.09%)  0              0           0          0           	return ((uint16_t)(uintptr_t)bin->stack_head == bin->low_bits_full);
    .            .          .              .           .           .              .           .          .           }
    .            .          .              .           .           .              .           .          .           
    .            .          .              .           .           .              .           .          .           /*
    .            .          .              .           .           .              .           .          .            * Free an object into the given bin.  Fails only if the bin is full.
    .            .          .              .           .           .              .           .          .            */
    .            .          .              .           .           .              .           .          .           JEMALLOC_ALWAYS_INLINE bool
    .            .          .              .           .           .              .           .          .           cache_bin_dalloc_easy(cache_bin_t *bin, void *ptr) {
2,877 ( 0.03%) 188 ( 0.13%) 1 ( 0.01%)     0           0           0              0           0          0           	if (unlikely(cache_bin_full(bin))) {
    .            .          .              .           .           .              .           .          .           		return false;
    .            .          .              .           .           .              .           .          .           	}
    .            .          .              .           .           .              .           .          .           
4,795 ( 0.05%)  28 ( 0.02%) 1 ( 0.01%) 2,877 ( 0.12%)  0           0            959 ( 0.03%)  0          0           	bin->stack_head--;
3,836 ( 0.04%)   4 ( 0.00%) 1 ( 0.01%) 2,877 ( 0.12%)  0           0            959 ( 0.03%) 29 ( 0.55%) 0           	*bin->stack_head = ptr;
7,672 ( 0.08%)  28 ( 0.02%) 1 ( 0.01%) 2,877 ( 0.12%)  0           0            959 ( 0.03%)  1 ( 0.02%) 0           	cache_bin_assert_earlier(bin, bin->low_bits_full,
1,918 ( 0.02%) 183 ( 0.13%) 1 ( 0.01%) 1,918 ( 0.08%)  0           0              0           0          0           	    (uint16_t)(uintptr_t)bin->stack_head);
    .            .          .              .           .           .              .           .          .           
  959 ( 0.01%)   3 ( 0.00%) 1 ( 0.01%)     0           0           0              0           0          0           	return true;
    .            .          .              .           .           .              .           .          .           }
    .            .          .              .           .           .              .           .          .           
    .            .          .              .           .           .              .           .          .           /* Returns false if failed to stash (i.e. bin is full). */
    .            .          .              .           .           .              .           .          .           JEMALLOC_ALWAYS_INLINE bool
    .            .          .              .           .           .              .           .          .           cache_bin_stash(cache_bin_t *bin, void *ptr) {
    .            .          .              .           .           .              .           .          .           	if (cache_bin_full(bin)) {
    .            .          .              .           .           .              .           .          .           		return false;
    .            .          .              .           .           .              .           .          .           	}
-- line 452 ----------------------------------------
-- line 471 ----------------------------------------
    .            .          .              .           .           .              .           .          .            * When called from a thread not owning the TLS (i.e. racy = true), it's
    .            .          .              .           .           .              .           .          .            * important to keep in mind that 'bin->stack_head' and 'bin->low_bits_full' can
    .            .          .              .           .           .              .           .          .            * be modified concurrently and almost none assertions about their values can be
    .            .          .              .           .           .              .           .          .            * made.
    .            .          .              .           .           .              .           .          .            */
    .            .          .              .           .           .              .           .          .           JEMALLOC_ALWAYS_INLINE cache_bin_sz_t
    .            .          .              .           .           .              .           .          .           cache_bin_nstashed_get_internal(cache_bin_t *bin, cache_bin_info_t *info,
    .            .          .              .           .           .              .           .          .               bool racy) {
   88 ( 0.00%)  22 ( 0.02%) 1 ( 0.01%)    22 ( 0.00%)  0           0             44 ( 0.00%)  0          0           	cache_bin_sz_t ncached_max = cache_bin_info_ncached_max(info);
  132 ( 0.00%)   0          0             44 ( 0.00%)  0           0             44 ( 0.00%)  0          0           	uint16_t low_bits_low_bound = cache_bin_low_bits_low_bound_get(bin,
    .            .          .              .           .           .              .           .          .           	    info);
    .            .          .              .           .           .              .           .          .           
  176 ( 0.00%)  22 ( 0.02%) 1 ( 0.01%)    66 ( 0.00%)  0           0             44 ( 0.00%)  0          0           	cache_bin_sz_t n = cache_bin_diff(bin, low_bits_low_bound,
   44 ( 0.00%)   0          0             44 ( 0.00%)  0           0              0           0          0           	    bin->low_bits_full, racy) / sizeof(void *);
   88 ( 0.00%)   0          0              0           0           0              0           0          0           	assert(n <= ncached_max);
    .            .          .              .           .           .              .           .          .           
   88 ( 0.00%)  44 ( 0.03%) 2 ( 0.03%)    22 ( 0.00%)  0           0              0           0          0           	if (!racy) {
    .            .          .              .           .           .              .           .          .           		/* Below are for assertions only. */
  132 ( 0.00%)   0          0             44 ( 0.00%)  0           0             44 ( 0.00%)  0          0           		void **low_bound = cache_bin_low_bound_get(bin, info);
    .            .          .              .           .           .              .           .          .           
   88 ( 0.00%)   0          0              0           0           0              0           0          0           		assert((uint16_t)(uintptr_t)low_bound == low_bits_low_bound);
  198 ( 0.00%)  44 ( 0.03%) 2 ( 0.03%)    88 ( 0.00%) 19 ( 0.33%) 10 ( 0.28%)    44 ( 0.00%)  1 ( 0.02%) 1 ( 0.02%)  		void *stashed = *(low_bound + n - 1);
   22 ( 0.00%)  22 ( 0.02%) 1 ( 0.01%)     0           0           0             22 ( 0.00%)  0          0           		bool aligned = cache_bin_nonfast_aligned(stashed);
    .            .          .              .           .           .              .           .          .           #ifdef JEMALLOC_JET
    .            .          .              .           .           .              .           .          .           		/* Allow arbitrary pointers to be stashed in tests. */
    .            .          .              .           .           .              .           .          .           		aligned = true;
    .            .          .              .           .           .              .           .          .           #endif
   88 ( 0.00%)   0          0              0           0           0              0           0          0           		assert(n == 0 || (stashed != NULL && aligned));
    .            .          .              .           .           .              .           .          .           	}
    .            .          .              .           .           .              .           .          .           
   22 ( 0.00%)  22 ( 0.02%) 1 ( 0.01%)    22 ( 0.00%)  0           0              0           0          0           	return n;
    .            .          .              .           .           .              .           .          .           }
    .            .          .              .           .           .              .           .          .           
    .            .          .              .           .           .              .           .          .           JEMALLOC_ALWAYS_INLINE cache_bin_sz_t
    .            .          .              .           .           .              .           .          .           cache_bin_nstashed_get_local(cache_bin_t *bin, cache_bin_info_t *info) {
   22 ( 0.00%)  22 ( 0.02%) 1 ( 0.01%)     0           0           0             22 ( 0.00%)  0          0           	cache_bin_sz_t n = cache_bin_nstashed_get_internal(bin, info,
    .            .          .              .           .           .              .           .          .           	    /* racy */ false);
   88 ( 0.00%)   0          0              0           0           0              0           0          0           	assert(n <= cache_bin_info_ncached_max(info));
   22 ( 0.00%)  22 ( 0.02%) 1 ( 0.01%)    22 ( 0.00%)  0           0              0           0          0           	return n;
    .            .          .              .           .           .              .           .          .           }
    .            .          .              .           .           .              .           .          .           
    .            .          .              .           .           .              .           .          .           /*
    .            .          .              .           .           .              .           .          .            * Obtain a racy view of the number of items currently in the cache bin, in the
    .            .          .              .           .           .              .           .          .            * presence of possible concurrent modifications.
    .            .          .              .           .           .              .           .          .            */
    .            .          .              .           .           .              .           .          .           static inline void
    .            .          .              .           .           .              .           .          .           cache_bin_nitems_get_remote(cache_bin_t *bin, cache_bin_info_t *info,
-- line 517 ----------------------------------------
-- line 563 ----------------------------------------
    .            .          .              .           .           .              .           .          .               name.n = (nval)
    .            .          .              .           .           .              .           .          .           
    .            .          .              .           .           .              .           .          .           /*
    .            .          .              .           .           .              .           .          .            * Start a fill.  The bin must be empty, and This must be followed by a
    .            .          .              .           .           .              .           .          .            * finish_fill call before doing any alloc/dalloc operations on the bin.
    .            .          .              .           .           .              .           .          .            */
    .            .          .              .           .           .              .           .          .           static inline void
    .            .          .              .           .           .              .           .          .           cache_bin_init_ptr_array_for_fill(cache_bin_t *bin, cache_bin_info_t *info,
  160 ( 0.00%)  20 ( 0.01%) 1 ( 0.01%)     0           0           0            100 ( 0.00%)  2 ( 0.04%) 1 ( 0.02%)      cache_bin_ptr_array_t *arr, cache_bin_sz_t nfill) {
  100 ( 0.00%)  15 ( 0.01%) 1 ( 0.01%)    40 ( 0.00%)  0           0             20 ( 0.00%)  1 ( 0.02%) 1 ( 0.02%)  	cache_bin_assert_empty(bin, info);
  180 ( 0.00%)   0          0             60 ( 0.00%)  0           0             40 ( 0.00%)  0          0           	arr->ptr = cache_bin_empty_position_get(bin) - nfill;
   60 ( 0.00%)   0          0             40 ( 0.00%)  0           0              0           0          0           }
    .            .          .              .           .           .              .           .          .           
    .            .          .              .           .           .              .           .          .           /*
    .            .          .              .           .           .              .           .          .            * While nfill in cache_bin_init_ptr_array_for_fill is the number we *intend* to
    .            .          .              .           .           .              .           .          .            * fill, nfilled here is the number we actually filled (which may be less, in
    .            .          .              .           .           .              .           .          .            * case of OOM.
    .            .          .              .           .           .              .           .          .            */
    .            .          .              .           .           .              .           .          .           static inline void
    .            .          .              .           .           .              .           .          .           cache_bin_finish_fill(cache_bin_t *bin, cache_bin_info_t *info,
  160 ( 0.00%)  40 ( 0.03%) 1 ( 0.01%)     0           0           0            100 ( 0.00%)  0          0               cache_bin_ptr_array_t *arr, cache_bin_sz_t nfilled) {
  100 ( 0.00%)   0          0             40 ( 0.00%)  0           0             20 ( 0.00%)  0          0           	cache_bin_assert_empty(bin, info);
   80 ( 0.00%)   0          0             20 ( 0.00%)  0           0             40 ( 0.00%)  0          0           	void **empty_position = cache_bin_empty_position_get(bin);
   80 ( 0.00%)   0          0             60 ( 0.00%)  0           0              0           0          0           	if (nfilled < arr->n) {
    .            .          .              .           .           .              .           .          .           		memmove(empty_position - nfilled, empty_position - arr->n,
    .            .          .              .           .           .              .           .          .           		    nfilled * sizeof(void *));
    .            .          .              .           .           .              .           .          .           	}
  160 ( 0.00%)  20 ( 0.01%) 1 ( 0.01%)    60 ( 0.00%)  0           0             20 ( 0.00%)  0          0           	bin->stack_head = empty_position - nfilled;
   60 ( 0.00%)   0          0             40 ( 0.00%)  0           0              0           0          0           }
    .            .          .              .           .           .              .           .          .           
    .            .          .              .           .           .              .           .          .           /*
    .            .          .              .           .           .              .           .          .            * Same deal, but with flush.  Unlike fill (which can fail), the user must flush
    .            .          .              .           .           .              .           .          .            * everything we give them.
    .            .          .              .           .           .              .           .          .            */
    .            .          .              .           .           .              .           .          .           static inline void
    .            .          .              .           .           .              .           .          .           cache_bin_init_ptr_array_for_flush(cache_bin_t *bin, cache_bin_info_t *info,
    .            .          .              .           .           .              .           .          .               cache_bin_ptr_array_t *arr, cache_bin_sz_t nflush) {
-- line 599 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/ashy5000/.cargo/registry/src/index.crates.io-6f17d22bba15001f/smartstring-1.0.1/src/inline.rs
--------------------------------------------------------------------------------
Ir              I1mr         ILmr       Dr              D1mr       DLmr       Dw              D1mw       DLmw       

-- line 32 ----------------------------------------
     .            .          .               .          .          .               .          .          .               }
     .            .          .               .          .          .               .          .          .           }
     .            .          .               .          .          .               .          .          .           
     .            .          .               .          .          .               .          .          .           impl Copy for InlineString {}
     .            .          .               .          .          .               .          .          .           
     .            .          .               .          .          .               .          .          .           impl Deref for InlineString {
     .            .          .               .          .          .               .          .          .               type Target = str;
     .            .          .               .          .          .               .          .          .           
15,272 ( 0.16%)  11 ( 0.01%) 0               0          0          0           7,636 ( 0.24%) 0          0               fn deref(&self) -> &Self::Target {
     .            .          .               .          .          .               .          .          .                   #[allow(unsafe_code)]
     .            .          .               .          .          .               .          .          .                   unsafe {
99,268 ( 1.05%) 156 ( 0.11%) 1 ( 0.01%)  7,636 ( 0.31%) 0          0          30,544 ( 0.97%) 0          0                       from_utf8_unchecked(&self.data[..self.len()])
     .            .          .               .          .          .               .          .          .                   }
15,272 ( 0.16%)   0          0           7,636 ( 0.31%) 0          0               0          0          0               }
     .            .          .               .          .          .               .          .          .           }
     .            .          .               .          .          .               .          .          .           
     .            .          .               .          .          .               .          .          .           impl DerefMut for InlineString {
     .            .          .               .          .          .               .          .          .               fn deref_mut(&mut self) -> &mut Self::Target {
     .            .          .               .          .          .               .          .          .                   let len = self.len();
     .            .          .               .          .          .               .          .          .                   #[allow(unsafe_code)]
     .            .          .               .          .          .               .          .          .                   unsafe {
     .            .          .               .          .          .               .          .          .                       from_utf8_unchecked_mut(&mut self.data[..len])
     .            .          .               .          .          .               .          .          .                   }
     .            .          .               .          .          .               .          .          .               }
     .            .          .               .          .          .               .          .          .           }
     .            .          .               .          .          .               .          .          .           
     .            .          .               .          .          .               .          .          .           impl GenericString for InlineString {
10,976 ( 0.12%)   0          0               0          0          0           8,232 ( 0.26%) 0          0               fn set_size(&mut self, size: usize) {
10,976 ( 0.12%)  26 ( 0.02%) 1 ( 0.01%)      0          0          0           8,232 ( 0.26%) 0          0                   self.marker.set_data(size as u8);
 5,488 ( 0.06%)   0          0           2,744 ( 0.11%) 0          0               0          0          0               }
     .            .          .               .          .          .               .          .          .           
 5,488 ( 0.06%) 106 ( 0.07%) 1 ( 0.01%)      0          0          0           5,488 ( 0.17%) 0          0               fn as_mut_capacity_slice(&mut self) -> &mut [u8] {
 8,232 ( 0.09%)   0          0               0          0          0           2,744 ( 0.09%) 0          0                   self.data.as_mut()
 5,488 ( 0.06%)   0          0           5,488 ( 0.23%) 0          0               0          0          0               }
     .            .          .               .          .          .               .          .          .           }
     .            .          .               .          .          .               .          .          .           
     .            .          .               .          .          .               .          .          .           impl InlineString {
 3,234 ( 0.03%)  61 ( 0.04%) 1 ( 0.01%)      0          0          0           2,156 ( 0.07%) 0          0               pub(crate) const fn new() -> Self {
11,858 ( 0.13%)  29 ( 0.02%) 1 ( 0.01%)  5,390 ( 0.22%) 0          0           6,468 ( 0.21%) 0          0                   Self {
     .            .          .               .          .          .               .          .          .                       marker: Marker::empty(),
 7,546 ( 0.08%)   0          0           3,234 ( 0.13%) 0          0           1,078 ( 0.03%) 0          0                       data: [0; MAX_INLINE],
     .            .          .               .          .          .               .          .          .                   }
 2,156 ( 0.02%)   0          0           1,078 ( 0.04%) 0          0               0          0          0               }
     .            .          .               .          .          .               .          .          .           
15,346 ( 0.16%)   8 ( 0.01%) 0               0          0          0           7,673 ( 0.24%) 0          0               pub(crate) fn len(&self) -> usize {
38,365 ( 0.40%)   0          0           7,673 ( 0.32%) 0          0          23,019 ( 0.73%) 0          0                   let len = self.marker.data() as usize;
15,346 ( 0.16%)   0          0               0          0          0               0          0          0                   debug_assert!(len <= MAX_INLINE);
     .            .          .               .          .          .               .          .          .                   len
15,346 ( 0.16%)   0          0           7,673 ( 0.32%) 0          0               0          0          0               }
     .            .          .               .          .          .               .          .          .           }
     .            .          .               .          .          .               .          .          .           
     .            .          .               .          .          .               .          .          .           impl From<&str> for InlineString {
 5,324 ( 0.06%) 128 ( 0.09%) 1 ( 0.01%)    968 ( 0.04%) 0          0           2,904 ( 0.09%) 0          0               fn from(string: &str) -> Self {
 1,452 ( 0.02%)   0          0               0          0          0           1,452 ( 0.05%) 0          0                   let len = string.len();
   968 ( 0.01%)   0          0               0          0          0               0          0          0                   debug_assert!(len <= MAX_INLINE);
 2,420 ( 0.03%) 114 ( 0.08%) 1 ( 0.01%)    968 ( 0.04%) 0          0           1,452 ( 0.05%) 0          0                   let mut out = Self::new();
   484 ( 0.01%)   0          0               0          0          0             484 ( 0.02%) 0          0                   out.marker = Marker::new_inline(len as u8);
 5,808 ( 0.06%)  41 ( 0.03%) 1 ( 0.01%)  1,936 ( 0.08%) 0          0           2,420 ( 0.08%) 0          0                   out.data.as_mut()[..len].copy_from_slice(string.as_bytes());
 2,904 ( 0.03%)   2 ( 0.00%) 0           1,452 ( 0.06%) 0          0           1,452 ( 0.05%) 0          0                   out
   968 ( 0.01%)   0          0             484 ( 0.02%) 0          0               0          0          0               }
     .            .          .               .          .          .               .          .          .           }

15,830 ( 0.17%)  20 ( 0.01%) 1 ( 0.01%) 15,830 ( 0.65%) 0          0               0          0          0           <counts for unidentified lines in /home/ashy5000/.cargo/registry/src/index.crates.io-6f17d22bba15001f/smartstring-1.0.1/src/inline.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/ashy5000/.cargo/registry/src/index.crates.io-6f17d22bba15001f/rustc-hash-2.0.0/src/lib.rs
--------------------------------------------------------------------------------
Ir             I1mr        ILmr       Dr             D1mr       DLmr       Dw             D1mw       DLmw       

-- line 78 ----------------------------------------
    .           .          .              .          .          .              .          .          .               /// Creates a `fx` hasher with a given seed.
    .           .          .              .          .          .              .          .          .               pub const fn with_seed(seed: usize) -> FxHasher {
    .           .          .              .          .          .              .          .          .                   FxHasher { hash: seed }
    .           .          .              .          .          .              .          .          .               }
    .           .          .              .          .          .              .          .          .           
    .           .          .              .          .          .              .          .          .               /// Creates a default `fx` hasher.
    .           .          .              .          .          .              .          .          .               pub const fn default() -> FxHasher {
    .           .          .              .          .          .              .          .          .                   FxHasher { hash: 0 }
1,000 ( 0.01%) 51 ( 0.04%) 1 ( 0.01%)   500 ( 0.02%) 0          0              0          0          0               }
    .           .          .              .          .          .              .          .          .           }
    .           .          .              .          .          .              .          .          .           
    .           .          .              .          .          .              .          .          .           impl Default for FxHasher {
    .           .          .              .          .          .              .          .          .               #[inline]
    .           .          .              .          .          .              .          .          .               fn default() -> FxHasher {
    .           .          .              .          .          .              .          .          .                   Self::default()
    .           .          .              .          .          .              .          .          .               }
    .           .          .              .          .          .              .          .          .           }
    .           .          .              .          .          .              .          .          .           
    .           .          .              .          .          .              .          .          .           impl FxHasher {
    .           .          .              .          .          .              .          .          .               #[inline]
2,000 ( 0.02%) 14 ( 0.01%) 1 ( 0.01%)     0          0          0          2,000 ( 0.06%) 0          0               fn add_to_hash(&mut self, i: usize) {
4,000 ( 0.04%)  0          0          1,000 ( 0.04%) 0          0          3,000 ( 0.10%) 0          0                   self.hash = self.hash.wrapping_add(i).wrapping_mul(K);
1,000 ( 0.01%)  0          0          1,000 ( 0.04%) 0          0              0          0          0               }
    .           .          .              .          .          .              .          .          .           }
    .           .          .              .          .          .              .          .          .           
    .           .          .              .          .          .              .          .          .           impl Hasher for FxHasher {
    .           .          .              .          .          .              .          .          .               #[inline]
5,500 ( 0.06%) 21 ( 0.01%) 2 ( 0.03%) 1,000 ( 0.04%) 0          0          3,000 ( 0.10%) 0          0               fn write(&mut self, bytes: &[u8]) {
    .           .          .              .          .          .              .          .          .                   // Compress the byte string to a single u64 and add to our hash.
2,000 ( 0.02%)  0          0            500 ( 0.02%) 0          0          1,000 ( 0.03%) 0          0                   self.write_u64(hash_bytes(bytes));
1,000 ( 0.01%)  0          0            500 ( 0.02%) 0          0              0          0          0               }
    .           .          .              .          .          .              .          .          .           
    .           .          .              .          .          .              .          .          .               #[inline]
  500 ( 0.01%)  0          0              0          0          0              0          0          0               fn write_u8(&mut self, i: u8) {
  500 ( 0.01%)  0          0              0          0          0              0          0          0                   self.add_to_hash(i as usize);
  500 ( 0.01%)  0          0              0          0          0              0          0          0               }
    .           .          .              .          .          .              .          .          .           
    .           .          .              .          .          .              .          .          .               #[inline]
    .           .          .              .          .          .              .          .          .               fn write_u16(&mut self, i: u16) {
    .           .          .              .          .          .              .          .          .                   self.add_to_hash(i as usize);
    .           .          .              .          .          .              .          .          .               }
    .           .          .              .          .          .              .          .          .           
    .           .          .              .          .          .              .          .          .               #[inline]
    .           .          .              .          .          .              .          .          .               fn write_u32(&mut self, i: u32) {
    .           .          .              .          .          .              .          .          .                   self.add_to_hash(i as usize);
    .           .          .              .          .          .              .          .          .               }
    .           .          .              .          .          .              .          .          .           
    .           .          .              .          .          .              .          .          .               #[inline]
  500 ( 0.01%) 53 ( 0.04%) 1 ( 0.01%)     0          0          0              0          0          0               fn write_u64(&mut self, i: u64) {
  500 ( 0.01%) 50 ( 0.03%) 0              0          0          0            500 ( 0.02%) 0          0                   self.add_to_hash(i as usize);
    .           .          .              .          .          .              .          .          .                   #[cfg(target_pointer_width = "32")]
    .           .          .              .          .          .              .          .          .                   self.add_to_hash((i >> 32) as usize);
1,000 ( 0.01%)  0          0            500 ( 0.02%) 0          0              0          0          0               }
    .           .          .              .          .          .              .          .          .           
    .           .          .              .          .          .              .          .          .               #[inline]
    .           .          .              .          .          .              .          .          .               fn write_u128(&mut self, i: u128) {
    .           .          .              .          .          .              .          .          .                   self.add_to_hash(i as usize);
    .           .          .              .          .          .              .          .          .                   #[cfg(target_pointer_width = "32")]
    .           .          .              .          .          .              .          .          .                   self.add_to_hash((i >> 32) as usize);
    .           .          .              .          .          .              .          .          .                   self.add_to_hash((i >> 64) as usize);
    .           .          .              .          .          .              .          .          .                   #[cfg(target_pointer_width = "32")]
-- line 138 ----------------------------------------
-- line 159 ----------------------------------------
    .           .          .              .          .          .              .          .          .               #[inline]
    .           .          .              .          .          .              .          .          .               fn write_str(&mut self, s: &str) {
    .           .          .              .          .          .              .          .          .                   // Similarly here, write already encodes the length, so nothing special
    .           .          .              .          .          .              .          .          .                   // is needed.
    .           .          .              .          .          .              .          .          .                   self.write(s.as_bytes())
    .           .          .              .          .          .              .          .          .               }
    .           .          .              .          .          .              .          .          .           
    .           .          .              .          .          .              .          .          .               #[inline]
  500 ( 0.01%)  0          0              0          0          0            500 ( 0.02%) 0          0               fn finish(&self) -> u64 {
    .           .          .              .          .          .              .          .          .                   // Since we used a multiplicative hash our top bits have the most
    .           .          .              .          .          .              .          .          .                   // entropy (with the top bit having the most, decreasing as you go).
    .           .          .              .          .          .              .          .          .                   // As most hash table implementations (including hashbrown) compute
    .           .          .              .          .          .              .          .          .                   // the bucket index from the bottom bits we want to move bits from the
    .           .          .              .          .          .              .          .          .                   // top to the bottom. Ideally we'd rotate left by exactly the hash table
    .           .          .              .          .          .              .          .          .                   // size, but as we don't know this we'll choose 20 bits, giving decent
    .           .          .              .          .          .              .          .          .                   // entropy up until 2^20 table sizes. On 32-bit hosts we'll dial it
    .           .          .              .          .          .              .          .          .                   // back down a bit to 15 bits.
    .           .          .              .          .          .              .          .          .           
    .           .          .              .          .          .              .          .          .                   #[cfg(target_pointer_width = "64")]
    .           .          .              .          .          .              .          .          .                   const ROTATE: u32 = 20;
    .           .          .              .          .          .              .          .          .                   #[cfg(target_pointer_width = "32")]
    .           .          .              .          .          .              .          .          .                   const ROTATE: u32 = 15;
    .           .          .              .          .          .              .          .          .           
1,500 ( 0.02%)  0          0            500 ( 0.02%) 0          0          1,000 ( 0.03%) 0          0                   self.hash.rotate_left(ROTATE) as u64
    .           .          .              .          .          .              .          .          .           
    .           .          .              .          .          .              .          .          .                   // A bit reversal would be even better, except hashbrown also expects
    .           .          .              .          .          .              .          .          .                   // good entropy in the top 7 bits and a bit reverse would fill those
    .           .          .              .          .          .              .          .          .                   // bits with low entropy. More importantly, bit reversals are very slow
    .           .          .              .          .          .              .          .          .                   // on x86-64. A byte reversal is relatively fast, but still has a 2
    .           .          .              .          .          .              .          .          .                   // cycle latency on x86-64 compared to the 1 cycle latency of a rotate.
    .           .          .              .          .          .              .          .          .                   // It also suffers from the hashbrown-top-7-bit-issue.
  500 ( 0.01%)  0          0            500 ( 0.02%) 0          0              0          0          0               }
    .           .          .              .          .          .              .          .          .           }
    .           .          .              .          .          .              .          .          .           
    .           .          .              .          .          .              .          .          .           // Nothing special, digits of pi.
    .           .          .              .          .          .              .          .          .           const SEED1: u64 = 0x243f6a8885a308d3;
    .           .          .              .          .          .              .          .          .           const SEED2: u64 = 0x13198a2e03707344;
    .           .          .              .          .          .              .          .          .           const PREVENT_TRIVIAL_ZERO_COLLAPSE: u64 = 0xa4093822299f31d0;
    .           .          .              .          .          .              .          .          .           
    .           .          .              .          .          .              .          .          .           #[inline]
  500 ( 0.01%)  0          0              0          0          0              0          0          0           fn multiply_mix(x: u64, y: u64) -> u64 {
    .           .          .              .          .          .              .          .          .               #[cfg(target_pointer_width = "64")]
    .           .          .              .          .          .              .          .          .               {
    .           .          .              .          .          .              .          .          .                   // We compute the full u64 x u64 -> u128 product, this is a single mul
    .           .          .              .          .          .              .          .          .                   // instruction on x86-64, one mul plus one mulhi on ARM64.
3,000 ( 0.03%)  0          0              0          0          0          1,500 ( 0.05%) 0          0                   let full = (x as u128) * (y as u128);
  500 ( 0.01%)  0          0              0          0          0              0          0          0                   let lo = full as u64;
  500 ( 0.01%)  0          0              0          0          0            500 ( 0.02%) 0          0                   let hi = (full >> 64) as u64;
    .           .          .              .          .          .              .          .          .           
    .           .          .              .          .          .              .          .          .                   // The middle bits of the full product fluctuate the most with small
    .           .          .              .          .          .              .          .          .                   // changes in the input. This is the top bits of lo and the bottom bits
    .           .          .              .          .          .              .          .          .                   // of hi. We can thus make the entire output fluctuate with small
    .           .          .              .          .          .              .          .          .                   // changes to the input by XOR'ing these two halves.
  500 ( 0.01%)  0          0              0          0          0              0          0          0                   lo ^ hi
    .           .          .              .          .          .              .          .          .           
    .           .          .              .          .          .              .          .          .                   // Unfortunately both 2^64 + 1 and 2^64 - 1 have small prime factors,
    .           .          .              .          .          .              .          .          .                   // otherwise combining with + or - could result in a really strong hash, as:
    .           .          .              .          .          .              .          .          .                   //     x * y = 2^64 * hi + lo = (-1) * hi + lo = lo - hi,   (mod 2^64 + 1)
    .           .          .              .          .          .              .          .          .                   //     x * y = 2^64 * hi + lo =    1 * hi + lo = lo + hi,   (mod 2^64 - 1)
    .           .          .              .          .          .              .          .          .                   // Multiplicative hashing is universal in a field (like mod p).
    .           .          .              .          .          .              .          .          .               }
    .           .          .              .          .          .              .          .          .           
-- line 220 ----------------------------------------
-- line 230 ----------------------------------------
    .           .          .              .          .          .              .          .          .                   // u32 x u32 -> u64 the low bits of one with the high bits of the other.
    .           .          .              .          .          .              .          .          .                   let afull = (lx as u64) * (hy as u64);
    .           .          .              .          .          .              .          .          .                   let bfull = (hx as u64) * (ly as u64);
    .           .          .              .          .          .              .          .          .           
    .           .          .              .          .          .              .          .          .                   // Combine, swapping low/high of one of them so the upper bits of the
    .           .          .              .          .          .              .          .          .                   // product of one combine with the lower bits of the other.
    .           .          .              .          .          .              .          .          .                   afull ^ bfull.rotate_right(32)
    .           .          .              .          .          .              .          .          .               }
1,000 ( 0.01%)  0          0            500 ( 0.02%) 0          0              0          0          0           }
    .           .          .              .          .          .              .          .          .           
    .           .          .              .          .          .              .          .          .           /// A wyhash-inspired non-collision-resistant hash for strings/slices designed
    .           .          .              .          .          .              .          .          .           /// by Orson Peters, with a focus on small strings and small codesize.
    .           .          .              .          .          .              .          .          .           ///
    .           .          .              .          .          .              .          .          .           /// The 64-bit version of this hash passes the SMHasher3 test suite on the full
    .           .          .              .          .          .              .          .          .           /// 64-bit output, that is, f(hash_bytes(b) ^ f(seed)) for some good avalanching
    .           .          .              .          .          .              .          .          .           /// permutation f() passed all tests with zero failures. When using the 32-bit
    .           .          .              .          .          .              .          .          .           /// version of multiply_mix this hash has a few non-catastrophic failures where
    .           .          .              .          .          .              .          .          .           /// there are a handful more collisions than an optimal hash would give.
    .           .          .              .          .          .              .          .          .           ///
    .           .          .              .          .          .              .          .          .           /// We don't bother avalanching here as we'll feed this hash into a
    .           .          .              .          .          .              .          .          .           /// multiplication after which we take the high bits, which avalanches for us.
    .           .          .              .          .          .              .          .          .           #[inline]
  500 ( 0.01%) 90 ( 0.06%) 1 ( 0.01%)     0          0          0              0          0          0           fn hash_bytes(bytes: &[u8]) -> u64 {
  500 ( 0.01%)  0          0              0          0          0            500 ( 0.02%) 0          0               let len = bytes.len();
  500 ( 0.01%)  0          0              0          0          0              0          0          0               let mut s0 = SEED1;
  500 ( 0.01%)  0          0              0          0          0              0          0          0               let mut s1 = SEED2;
    .           .          .              .          .          .              .          .          .           
1,000 ( 0.01%)  0          0              0          0          0              0          0          0               if len <= 16 {
    .           .          .              .          .          .              .          .          .                   // XOR the input into s0, s1.
  500 ( 0.01%)  0          0              0          0          0              0          0          0                   if len >= 8 {
1,000 ( 0.01%)  0          0              0          0          0            500 ( 0.02%) 0          0                       s0 ^= u64::from_le_bytes(bytes[0..8].try_into().unwrap());
2,000 ( 0.02%)  0          0              0          0          0          1,000 ( 0.03%) 0          0                       s1 ^= u64::from_le_bytes(bytes[len - 8..].try_into().unwrap());
    .           .          .              .          .          .              .          .          .                   } else if len >= 4 {
    .           .          .              .          .          .              .          .          .                       s0 ^= u32::from_le_bytes(bytes[0..4].try_into().unwrap()) as u64;
    .           .          .              .          .          .              .          .          .                       s1 ^= u32::from_le_bytes(bytes[len - 4..].try_into().unwrap()) as u64;
    .           .          .              .          .          .              .          .          .                   } else if len > 0 {
    .           .          .              .          .          .              .          .          .                       let lo = bytes[0];
    .           .          .              .          .          .              .          .          .                       let mid = bytes[len / 2];
    .           .          .              .          .          .              .          .          .                       let hi = bytes[len - 1];
    .           .          .              .          .          .              .          .          .                       s0 ^= lo as u64;
-- line 269 ----------------------------------------
-- line 288 ----------------------------------------
    .           .          .              .          .          .              .          .          .                       off += 16;
    .           .          .              .          .          .              .          .          .                   }
    .           .          .              .          .          .              .          .          .           
    .           .          .              .          .          .              .          .          .                   let suffix = &bytes[len - 16..];
    .           .          .              .          .          .              .          .          .                   s0 ^= u64::from_le_bytes(suffix[0..8].try_into().unwrap());
    .           .          .              .          .          .              .          .          .                   s1 ^= u64::from_le_bytes(suffix[8..16].try_into().unwrap());
    .           .          .              .          .          .              .          .          .               }
    .           .          .              .          .          .              .          .          .           
  500 ( 0.01%) 65 ( 0.05%) 1 ( 0.01%)   500 ( 0.02%) 0          0              0          0          0               multiply_mix(s0, s1) ^ (len as u64)
  500 ( 0.01%)  0          0              0          0          0              0          0          0           }
    .           .          .              .          .          .              .          .          .           
    .           .          .              .          .          .              .          .          .           /// An implementation of [`BuildHasher`] that produces [`FxHasher`]s.
    .           .          .              .          .          .              .          .          .           ///
    .           .          .              .          .          .              .          .          .           /// ```
    .           .          .              .          .          .              .          .          .           /// use std::hash::BuildHasher;
    .           .          .              .          .          .              .          .          .           /// use rustc_hash::FxBuildHasher;
    .           .          .              .          .          .              .          .          .           /// assert_ne!(FxBuildHasher.hash_one(1), FxBuildHasher.hash_one(2));
    .           .          .              .          .          .              .          .          .           /// ```
   15 ( 0.00%)  1 ( 0.00%) 1 ( 0.01%)     8 ( 0.00%) 0          0              7 ( 0.00%) 0          0           #[derive(Copy, Clone, Default)]
    .           .          .              .          .          .              .          .          .           pub struct FxBuildHasher;
    .           .          .              .          .          .              .          .          .           
    .           .          .              .          .          .              .          .          .           impl BuildHasher for FxBuildHasher {
    .           .          .              .          .          .              .          .          .               type Hasher = FxHasher;
1,000 ( 0.01%)  4 ( 0.00%) 0              0          0          0          1,000 ( 0.03%) 0          0               fn build_hasher(&self) -> FxHasher {
  500 ( 0.01%)  0          0            500 ( 0.02%) 0          0            500 ( 0.02%) 0          0                   FxHasher::default()
1,000 ( 0.01%)  0          0          1,000 ( 0.04%) 0          0              0          0          0               }
    .           .          .              .          .          .              .          .          .           }
    .           .          .              .          .          .              .          .          .           
    .           .          .              .          .          .              .          .          .           #[cfg(test)]
    .           .          .              .          .          .              .          .          .           mod tests {
    .           .          .              .          .          .              .          .          .               #[cfg(not(any(target_pointer_width = "64", target_pointer_width = "32")))]
    .           .          .              .          .          .              .          .          .               compile_error!("The test suite only supports 64 bit and 32 bit usize");
    .           .          .              .          .          .              .          .          .           
    .           .          .              .          .          .              .          .          .               use crate::{FxBuildHasher, FxHasher};
-- line 321 ----------------------------------------

8,500 ( 0.09%) 91 ( 0.06%) 3 ( 0.04%) 3,000 ( 0.12%) 0          0          5,500 ( 0.17%) 3 ( 0.06%) 0           <counts for unidentified lines in /home/ashy5000/.cargo/registry/src/index.crates.io-6f17d22bba15001f/rustc-hash-2.0.0/src/lib.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/ashy5000/.cargo/registry/src/index.crates.io-6f17d22bba15001f/tikv-jemallocator-0.6.0/src/lib.rs
--------------------------------------------------------------------------------
Ir             I1mr         ILmr       Dr             D1mr       DLmr       Dw             D1mw       DLmw       

-- line 64 ----------------------------------------
    .            .          .              .          .          .              .          .          .           const ALIGNOF_MAX_ALIGN_T: usize = 16;
    .            .          .              .          .          .              .          .          .           
    .            .          .              .          .          .              .          .          .           /// If `align` is less than `_Alignof(max_align_t)`, and if the requested
    .            .          .              .          .          .              .          .          .           /// allocation `size` is larger than the alignment, we are guaranteed to get a
    .            .          .              .          .          .              .          .          .           /// suitably aligned allocation by default, without passing extra flags, and
    .            .          .              .          .          .              .          .          .           /// this function returns `0`.
    .            .          .              .          .          .              .          .          .           ///
    .            .          .              .          .          .              .          .          .           /// Otherwise, it returns the alignment flag to pass to the jemalloc APIs.
9,780 ( 0.10%)  26 ( 0.02%) 1 ( 0.01%)     0          0          0          7,824 ( 0.25%) 0          0           fn layout_to_flags(align: usize, size: usize) -> c_int {
7,824 ( 0.08%)   0          0              0          0          0              0          0          0               if align <= ALIGNOF_MAX_ALIGN_T && align <= size {
1,956 ( 0.02%)  46 ( 0.03%) 0              0          0          0          1,956 ( 0.06%) 0          0                   0
    .            .          .              .          .          .              .          .          .               } else {
    .            .          .              .          .          .              .          .          .                   ffi::MALLOCX_ALIGN(align)
    .            .          .              .          .          .              .          .          .               }
5,868 ( 0.06%)   0          0          3,912 ( 0.16%) 0          0              0          0          0           }
    .            .          .              .          .          .              .          .          .           
    .            .          .              .          .          .              .          .          .           // Assumes a condition that always must hold.
    .            .          .              .          .          .              .          .          .           macro_rules! assume {
    .            .          .              .          .          .              .          .          .               ($e:expr) => {
   98 ( 0.00%)   0          0              0          0          0              0          0          0                   debug_assert!($e);
    .            .          .              .          .          .              .          .          .                   if !($e) {
    .            .          .              .          .          .              .          .          .                       core::hint::unreachable_unchecked();
    .            .          .              .          .          .              .          .          .                   }
    .            .          .              .          .          .              .          .          .               };
    .            .          .              .          .          .              .          .          .           }
    .            .          .              .          .          .              .          .          .           
    .            .          .              .          .          .              .          .          .           /// Handle to the jemalloc allocator
    .            .          .              .          .          .              .          .          .           ///
-- line 91 ----------------------------------------
-- line 93 ----------------------------------------
    .            .          .              .          .          .              .          .          .           ///
    .            .          .              .          .          .              .          .          .           /// When the `alloc_trait` feature of this crate is enabled, it also implements the `Alloc` trait,
    .            .          .              .          .          .              .          .          .           /// allowing usage in collections.
    .            .          .              .          .          .              .          .          .           #[derive(Copy, Clone, Default, Debug)]
    .            .          .              .          .          .              .          .          .           pub struct Jemalloc;
    .            .          .              .          .          .              .          .          .           
    .            .          .              .          .          .              .          .          .           unsafe impl GlobalAlloc for Jemalloc {
    .            .          .              .          .          .              .          .          .               #[inline]
3,716 ( 0.04%) 238 ( 0.17%) 1 ( 0.01%)     0          0          0          2,787 ( 0.09%) 0          0               unsafe fn alloc(&self, layout: Layout) -> *mut u8 {
3,716 ( 0.04%) 148 ( 0.10%) 1 ( 0.01%)     0          0          0            929 ( 0.03%) 0          0                   assume!(layout.size() != 0);
  929 ( 0.01%)   0          0              0          0          0              0          0          0                   let flags = layout_to_flags(layout.align(), layout.size());
  929 ( 0.01%)   0          0              0          0          0              0          0          0                   let ptr = if flags == 0 {
  929 ( 0.01%)   0          0              0          0          0              0          0          0                       ffi::malloc(layout.size())
    .            .          .              .          .          .              .          .          .                   } else {
    .            .          .              .          .          .              .          .          .                       ffi::mallocx(layout.size(), flags)
    .            .          .              .          .          .              .          .          .                   };
    .            .          .              .          .          .              .          .          .                   ptr as *mut u8
  929 ( 0.01%)   0          0              0          0          0              0          0          0               }
    .            .          .              .          .          .              .          .          .           
    .            .          .              .          .          .              .          .          .               #[inline]
    .            .          .              .          .          .              .          .          .               unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut u8 {
    .            .          .              .          .          .              .          .          .                   assume!(layout.size() != 0);
    .            .          .              .          .          .              .          .          .                   let flags = layout_to_flags(layout.align(), layout.size());
    .            .          .              .          .          .              .          .          .                   let ptr = if flags == 0 {
    .            .          .              .          .          .              .          .          .                       ffi::calloc(1, layout.size())
    .            .          .              .          .          .              .          .          .                   } else {
    .            .          .              .          .          .              .          .          .                       ffi::mallocx(layout.size(), flags | ffi::MALLOCX_ZERO)
    .            .          .              .          .          .              .          .          .                   };
    .            .          .              .          .          .              .          .          .                   ptr as *mut u8
    .            .          .              .          .          .              .          .          .               }
    .            .          .              .          .          .              .          .          .           
    .            .          .              .          .          .              .          .          .               #[inline]
1,858 ( 0.02%)   9 ( 0.01%) 0              0          0          0            929 ( 0.03%) 0          0               unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout) {
1,858 ( 0.02%) 143 ( 0.10%) 1 ( 0.01%)     0          0          0          1,858 ( 0.06%) 0          0                   assume!(!ptr.is_null());
5,574 ( 0.06%) 176 ( 0.12%) 1 ( 0.01%)     0          0          0          1,858 ( 0.06%) 0          0                   assume!(layout.size() != 0);
  929 ( 0.01%)   0          0              0          0          0              0          0          0                   let flags = layout_to_flags(layout.align(), layout.size());
5,574 ( 0.06%)   0          0          2,787 ( 0.11%) 1 ( 0.02%) 0          1,858 ( 0.06%) 0          0                   ffi::sdallocx(ptr as *mut c_void, layout.size(), flags)
1,858 ( 0.02%)   0          0            929 ( 0.04%) 0          0              0          0          0               }
    .            .          .              .          .          .              .          .          .           
    .            .          .              .          .          .              .          .          .               #[inline]
  392 ( 0.00%)  95 ( 0.07%) 1 ( 0.01%)     0          0          0            294 ( 0.01%) 0          0               unsafe fn realloc(&self, ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8 {
  490 ( 0.01%)  98 ( 0.07%) 1 ( 0.01%)     0          0          0             98 ( 0.00%) 0          0                   assume!(layout.size() != 0);
  294 ( 0.00%)   0          0              0          0          0              0          0          0                   assume!(new_size != 0);
   98 ( 0.00%)   0          0              0          0          0              0          0          0                   let flags = layout_to_flags(layout.align(), new_size);
  196 ( 0.00%)   0          0              0          0          0              0          0          0                   let ptr = if flags == 0 {
  196 ( 0.00%)   5 ( 0.00%) 0             98 ( 0.00%) 0          0            196 ( 0.01%) 0          0                       ffi::realloc(ptr as *mut c_void, new_size)
    .            .          .              .          .          .              .          .          .                   } else {
    .            .          .              .          .          .              .          .          .                       ffi::rallocx(ptr as *mut c_void, new_size, flags)
    .            .          .              .          .          .              .          .          .                   };
   98 ( 0.00%)   0          0             98 ( 0.00%) 0          0              0          0          0                   ptr as *mut u8
  196 ( 0.00%)   0          0             98 ( 0.00%) 0          0              0          0          0               }
    .            .          .              .          .          .              .          .          .           }
    .            .          .              .          .          .              .          .          .           
    .            .          .              .          .          .              .          .          .           #[cfg(feature = "alloc_trait")]
    .            .          .              .          .          .              .          .          .           unsafe impl Alloc for Jemalloc {
    .            .          .              .          .          .              .          .          .               #[inline]
    .            .          .              .          .          .              .          .          .               unsafe fn alloc(&mut self, layout: Layout) -> Result<NonNull<u8>, AllocErr> {
    .            .          .              .          .          .              .          .          .                   NonNull::new(GlobalAlloc::alloc(self, layout)).ok_or(AllocErr)
    .            .          .              .          .          .              .          .          .               }
-- line 151 ----------------------------------------

5,135 ( 0.05%)  33 ( 0.02%) 1 ( 0.01%) 5,135 ( 0.21%) 0          0              0          0          0           <counts for unidentified lines in /home/ashy5000/.cargo/registry/src/index.crates.io-6f17d22bba15001f/tikv-jemallocator-0.6.0/src/lib.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/ashy5000/dev/cryptocurrency/contracts/target/debug/build/tikv-jemalloc-sys-7365f40ecb99e085/out/build/include/jemalloc/internal/sz.h
--------------------------------------------------------------------------------
Ir              I1mr         ILmr        Dr             D1mr        DLmr       Dw              D1mw        DLmw        

-- line 50 ----------------------------------------
     .            .           .              .           .          .               .           .           .            * enable cache index randomization); 0 otherwise.
     .            .           .              .           .          .               .           .           .            */
     .            .           .              .           .          .               .           .           .           extern size_t sz_large_pad;
     .            .           .              .           .          .               .           .           .           
     .            .           .              .           .          .               .           .           .           extern void sz_boot(const sc_data_t *sc_data, bool cache_oblivious);
     .            .           .              .           .          .               .           .           .           
     .            .           .              .           .          .               .           .           .           JEMALLOC_ALWAYS_INLINE pszind_t
     .            .           .              .           .          .               .           .           .           sz_psz2ind(size_t psz) {
 1,040 ( 0.01%)  33 ( 0.02%)  2 ( 0.03%)     0           0          0               0           0           0           	assert(psz > 0);
 1,560 ( 0.02%) 173 ( 0.12%) 11 ( 0.15%)   260 ( 0.01%)  0          0               0           0           0           	if (unlikely(psz > SC_LARGE_MAXCLASS)) {
     .            .           .              .           .          .               .           .           .           		return SC_NPSIZES;
     .            .           .              .           .          .               .           .           .           	}
     .            .           .              .           .          .               .           .           .           	/* x is the lg of the first base >= psz. */
 1,040 ( 0.01%)  35 ( 0.02%)  3 ( 0.04%)   260 ( 0.01%)  0          0             520 ( 0.02%)  1 ( 0.02%)  1 ( 0.02%)  	pszind_t x = lg_ceil(psz);
     .            .           .              .           .          .               .           .           .           	/*
     .            .           .              .           .          .               .           .           .           	 * sc.h introduces a lot of size classes. These size classes are divided
     .            .           .              .           .          .               .           .           .           	 * into different size class groups. There is a very special size class
     .            .           .              .           .          .               .           .           .           	 * group, each size class in or after it is an integer multiple of PAGE.
     .            .           .              .           .          .               .           .           .           	 * We call it first_ps_rg. It means first page size regular group. The
     .            .           .              .           .          .               .           .           .           	 * range of first_ps_rg is (base, base * 2], and base == PAGE *
     .            .           .              .           .          .               .           .           .           	 * SC_NGROUP. off_to_first_ps_rg begins from 1, instead of 0. e.g.
     .            .           .              .           .          .               .           .           .           	 * off_to_first_ps_rg is 1 when psz is (PAGE * SC_NGROUP + 1).
     .            .           .              .           .          .               .           .           .           	 */
   520 ( 0.01%)  33 ( 0.02%)  2 ( 0.03%)     0           0          0             260 ( 0.01%)  0           0           	pszind_t off_to_first_ps_rg = (x < SC_LG_NGROUP + LG_PAGE) ?
 1,040 ( 0.01%)   0           0            260 ( 0.01%)  0          0               0           0           0           	    0 : x - (SC_LG_NGROUP + LG_PAGE);
     .            .           .              .           .          .               .           .           .           
     .            .           .              .           .          .               .           .           .           	/*
     .            .           .              .           .          .               .           .           .           	 * Same as sc_s::lg_delta.
     .            .           .              .           .          .               .           .           .           	 * Delta for off_to_first_ps_rg == 1 is PAGE,
     .            .           .              .           .          .               .           .           .           	 * for each increase in offset, it's multiplied by two.
     .            .           .              .           .          .               .           .           .           	 * Therefore, lg_delta = LG_PAGE + (off_to_first_ps_rg - 1).
     .            .           .              .           .          .               .           .           .           	 */
   260 ( 0.00%)   3 ( 0.00%)  2 ( 0.03%)     0           0          0             260 ( 0.01%)  0           0           	pszind_t lg_delta = (off_to_first_ps_rg == 0) ?
 1,116 ( 0.01%)  85 ( 0.06%)  3 ( 0.04%)   428 ( 0.02%)  0          0               0           0           0           	    LG_PAGE : LG_PAGE + (off_to_first_ps_rg - 1);
     .            .           .              .           .          .               .           .           .           
     .            .           .              .           .          .               .           .           .           	/*
     .            .           .              .           .          .               .           .           .           	 * Let's write psz in binary, e.g. 0011 for 0x3, 0111 for 0x7.
     .            .           .              .           .          .               .           .           .           	 * The leftmost bits whose len is lg_base decide the base of psz.
     .            .           .              .           .          .               .           .           .           	 * The rightmost bits whose len is lg_delta decide (pgz % PAGE).
     .            .           .              .           .          .               .           .           .           	 * The middle bits whose len is SC_LG_NGROUP decide ndelta.
     .            .           .              .           .          .               .           .           .           	 * ndelta is offset to the first size class in the size class group,
     .            .           .              .           .          .               .           .           .           	 * starts from 1.
-- line 91 ----------------------------------------
-- line 92 ----------------------------------------
     .            .           .              .           .          .               .           .           .           	 * If you don't know lg_base, ndelta or lg_delta, see sc.h.
     .            .           .              .           .          .               .           .           .           	 * |xxxxxxxxxxxxxxxxxxxx|------------------------|yyyyyyyyyyyyyyyyyyyyy|
     .            .           .              .           .          .               .           .           .           	 * |<-- len: lg_base -->|<-- len: SC_LG_NGROUP-->|<-- len: lg_delta -->|
     .            .           .              .           .          .               .           .           .           	 *                      |<--      ndelta      -->|
     .            .           .              .           .          .               .           .           .           	 * rg_inner_off = ndelta - 1
     .            .           .              .           .          .               .           .           .           	 * Why use (psz - 1)?
     .            .           .              .           .          .               .           .           .           	 * To handle case: psz % (1 << lg_delta) == 0.
     .            .           .              .           .          .               .           .           .           	 */
 2,080 ( 0.02%)   2 ( 0.00%)  1 ( 0.01%)   520 ( 0.02%)  0          0             260 ( 0.01%)  0           0           	pszind_t rg_inner_off = (((psz - 1)) >> lg_delta) & (SC_NGROUP - 1);
     .            .           .              .           .          .               .           .           .           
   780 ( 0.01%)   0           0            260 ( 0.01%)  0          0             260 ( 0.01%)  0           0           	pszind_t base_ind = off_to_first_ps_rg << SC_LG_NGROUP;
 1,040 ( 0.01%)  64 ( 0.04%)  3 ( 0.04%)   520 ( 0.02%)  0          0             260 ( 0.01%)  0           0           	pszind_t ind = base_ind + rg_inner_off;
   260 ( 0.00%)  32 ( 0.02%)  1 ( 0.01%)   260 ( 0.01%)  0          0               0           0           0           	return ind;
     .            .           .              .           .          .               .           .           .           }
     .            .           .              .           .          .               .           .           .           
     .            .           .              .           .          .               .           .           .           static inline size_t
     .            .           .              .           .          .               .           .           .           sz_pind2sz_compute(pszind_t pind) {
     .            .           .              .           .          .               .           .           .           	if (unlikely(pind == SC_NPSIZES)) {
     .            .           .              .           .          .               .           .           .           		return SC_LARGE_MAXCLASS + PAGE;
     .            .           .              .           .          .               .           .           .           	}
     .            .           .              .           .          .               .           .           .           	size_t grp = pind >> SC_LG_NGROUP;
-- line 112 ----------------------------------------
-- line 120 ----------------------------------------
     .            .           .              .           .          .               .           .           .           	size_t lg_delta = shift + (LG_PAGE-1);
     .            .           .              .           .          .               .           .           .           	size_t mod_size = (mod+1) << lg_delta;
     .            .           .              .           .          .               .           .           .           
     .            .           .              .           .          .               .           .           .           	size_t sz = grp_size + mod_size;
     .            .           .              .           .          .               .           .           .           	return sz;
     .            .           .              .           .          .               .           .           .           }
     .            .           .              .           .          .               .           .           .           
     .            .           .              .           .          .               .           .           .           static inline size_t
   580 ( 0.01%)  96 ( 0.07%)  4 ( 0.06%)     0           0          0             290 ( 0.01%)  0           0           sz_pind2sz_lookup(pszind_t pind) {
   691 ( 0.01%)  63 ( 0.04%)  2 ( 0.03%)   290 ( 0.01%)  6 ( 0.10%) 0             145 ( 0.00%)  0           0           	size_t ret = (size_t)sz_pind2sz_tab[pind];
   580 ( 0.01%)  31 ( 0.02%)  1 ( 0.01%)     0           0          0               0           0           0           	assert(ret == sz_pind2sz_compute(pind));
   145 ( 0.00%)   0           0            145 ( 0.01%)  0          0               0           0           0           	return ret;
   290 ( 0.00%)   0           0            290 ( 0.01%)  0          0               0           0           0           }
     .            .           .              .           .          .               .           .           .           
     .            .           .              .           .          .               .           .           .           static inline size_t
   580 ( 0.01%)  89 ( 0.06%)  5 ( 0.07%)     0           0          0             290 ( 0.01%)  0           0           sz_pind2sz(pszind_t pind) {
   580 ( 0.01%)  21 ( 0.01%)  2 ( 0.03%)     0           0          0               0           0           0           	assert(pind < SC_NPSIZES + 1);
   435 ( 0.00%)  32 ( 0.02%)  1 ( 0.01%)   145 ( 0.01%)  0          0             145 ( 0.00%)  0           0           	return sz_pind2sz_lookup(pind);
   290 ( 0.00%)   0           0            290 ( 0.01%)  0          0               0           0           0           }
     .            .           .              .           .          .               .           .           .           
     .            .           .              .           .          .               .           .           .           static inline size_t
     8 ( 0.00%)   2 ( 0.00%)  1 ( 0.01%)     0           0          0               4 ( 0.00%)  0           0           sz_psz2u(size_t psz) {
    12 ( 0.00%)   2 ( 0.00%)  1 ( 0.01%)     2 ( 0.00%)  0          0               0           0           0           	if (unlikely(psz > SC_LARGE_MAXCLASS)) {
     .            .           .              .           .          .               .           .           .           		return SC_LARGE_MAXCLASS + PAGE;
     .            .           .              .           .          .               .           .           .           	}
    14 ( 0.00%)   0           0              2 ( 0.00%)  0          0               4 ( 0.00%)  0           0           	size_t x = lg_floor((psz<<1)-1);
     4 ( 0.00%)   2 ( 0.00%)  1 ( 0.01%)     0           0          0               2 ( 0.00%)  0           0           	size_t lg_delta = (x < SC_LG_NGROUP + LG_PAGE + 1) ?
     8 ( 0.00%)   0           0              2 ( 0.00%)  0          0               0           0           0           	    LG_PAGE : x - SC_LG_NGROUP - 1;
    12 ( 0.00%)   0           0              2 ( 0.00%)  0          0               2 ( 0.00%)  0           0           	size_t delta = ZU(1) << lg_delta;
     6 ( 0.00%)   0           0              2 ( 0.00%)  0          0               2 ( 0.00%)  0           0           	size_t delta_mask = delta - 1;
    14 ( 0.00%)   1 ( 0.00%)  1 ( 0.01%)     6 ( 0.00%)  0          0               2 ( 0.00%)  0           0           	size_t usize = (psz + delta_mask) & ~delta_mask;
     2 ( 0.00%)   0           0              2 ( 0.00%)  0          0               0           0           0           	return usize;
     4 ( 0.00%)   0           0              4 ( 0.00%)  0          0               0           0           0           }
     .            .           .              .           .          .               .           .           .           
     .            .           .              .           .          .               .           .           .           static inline szind_t
   220 ( 0.00%)  38 ( 0.03%)  3 ( 0.04%)     0           0          0             110 ( 0.00%)  1 ( 0.02%)  0           sz_size2index_compute(size_t size) {
   330 ( 0.00%)   1 ( 0.00%)  1 ( 0.01%)    55 ( 0.00%)  0          0               0           0           0           	if (unlikely(size > SC_LARGE_MAXCLASS)) {
     .            .           .              .           .          .               .           .           .           		return SC_NSIZES;
     .            .           .              .           .          .               .           .           .           	}
     .            .           .              .           .          .               .           .           .           
   110 ( 0.00%)   4 ( 0.00%)  1 ( 0.01%)    55 ( 0.00%)  0          0               0           0           0           	if (size == 0) {
     .            .           .              .           .          .               .           .           .           		return 0;
     .            .           .              .           .          .               .           .           .           	}
     .            .           .              .           .          .               .           .           .           #if (SC_NTINY != 0)
   110 ( 0.00%)  35 ( 0.02%)  2 ( 0.03%)    55 ( 0.00%)  0          0               0           0           0           	if (size <= (ZU(1) << SC_LG_TINY_MAXCLASS)) {
     .            .           .              .           .          .               .           .           .           		szind_t lg_tmin = SC_LG_TINY_MAXCLASS - SC_NTINY + 1;
     .            .           .              .           .          .               .           .           .           		szind_t lg_ceil = lg_floor(pow2_ceil_zu(size));
     .            .           .              .           .          .               .           .           .           		return (lg_ceil < lg_tmin ? 0 : lg_ceil - lg_tmin);
     .            .           .              .           .          .               .           .           .           	}
     .            .           .              .           .          .               .           .           .           #endif
     .            .           .              .           .          .               .           .           .           	{
   330 ( 0.00%)  41 ( 0.03%)  4 ( 0.06%)    55 ( 0.00%)  0          0             110 ( 0.00%)  0           0           		szind_t x = lg_floor((size<<1)-1);
   330 ( 0.00%)   1 ( 0.00%)  1 ( 0.01%)    55 ( 0.00%)  0          0              55 ( 0.00%)  0           0           		szind_t shift = (x < SC_LG_NGROUP + LG_QUANTUM) ? 0 :
     .            .           .              .           .          .               .           .           .           		    x - (SC_LG_NGROUP + LG_QUANTUM);
   165 ( 0.00%)   4 ( 0.00%)  1 ( 0.01%)    55 ( 0.00%)  0          0              55 ( 0.00%)  0           0           		szind_t grp = shift << SC_LG_NGROUP;
     .            .           .              .           .          .               .           .           .           
   110 ( 0.00%)   2 ( 0.00%)  1 ( 0.01%)     0           0          0              55 ( 0.00%)  0           0           		szind_t lg_delta = (x < SC_LG_NGROUP + LG_QUANTUM + 1)
   220 ( 0.00%)  34 ( 0.02%)  1 ( 0.01%)    55 ( 0.00%)  0          0               0           0           0           		    ? LG_QUANTUM : x - SC_LG_NGROUP - 1;
     .            .           .              .           .          .               .           .           .           
   330 ( 0.00%)   1 ( 0.00%)  1 ( 0.01%)    55 ( 0.00%)  0          0              55 ( 0.00%)  0           0           		size_t delta_inverse_mask = ZU(-1) << lg_delta;
   550 ( 0.01%)  38 ( 0.03%)  2 ( 0.03%)   165 ( 0.01%)  0          0              55 ( 0.00%)  0           0           		szind_t mod = ((((size-1) & delta_inverse_mask) >> lg_delta)) &
     .            .           .              .           .          .               .           .           .           		    ((ZU(1) << SC_LG_NGROUP) - 1);
     .            .           .              .           .          .               .           .           .           
   275 ( 0.00%)   2 ( 0.00%)  1 ( 0.01%)   110 ( 0.00%)  0          0              55 ( 0.00%)  0           0           		szind_t index = SC_NTINY + grp + mod;
    55 ( 0.00%)   0           0             55 ( 0.00%)  0          0               0           0           0           		return index;
     .            .           .              .           .          .               .           .           .           	}
   110 ( 0.00%)   0           0            110 ( 0.00%)  0          0               0           0           0           }
     .            .           .              .           .          .               .           .           .           
     .            .           .              .           .          .               .           .           .           JEMALLOC_ALWAYS_INLINE szind_t
     .            .           .              .           .          .               .           .           .           sz_size2index_lookup_impl(size_t size) {
25,886 ( 0.27%) 225 ( 0.16%)  8 ( 0.11%) 5,940 ( 0.24%)  0          0           3,809 ( 0.12%)  0           0           	assert(size <= SC_LOOKUP_MAXCLASS);
15,552 ( 0.16%) 790 ( 0.55%) 21 ( 0.30%) 6,411 ( 0.26%) 10 ( 0.17%) 1 ( 0.03%)  1,015 ( 0.03%)  0           0           	return sz_size2index_tab[(size + (ZU(1) << SC_LG_TINY_MIN) - 1)
 6,548 ( 0.07%) 180 ( 0.12%)  2 ( 0.03%)   322 ( 0.01%)  1 ( 0.02%) 1 ( 0.03%)    333 ( 0.01%)  0           0           	    >> SC_LG_TINY_MIN];
     .            .           .              .           .          .               .           .           .           }
     .            .           .              .           .          .               .           .           .           
     .            .           .              .           .          .               .           .           .           JEMALLOC_ALWAYS_INLINE szind_t
     .            .           .              .           .          .               .           .           .           sz_size2index_lookup(size_t size) {
 2,173 ( 0.02%)  89 ( 0.06%)  1 ( 0.01%)   243 ( 0.01%)  0          0           1,863 ( 0.06%) 15 ( 0.28%) 12 ( 0.29%)  	szind_t ret = sz_size2index_lookup_impl(size);
 8,011 ( 0.08%) 116 ( 0.08%)  6 ( 0.08%)   316 ( 0.01%)  0          0             139 ( 0.00%)  0           0           	assert(ret == sz_size2index_compute(size));
 3,582 ( 0.04%) 526 ( 0.36%) 15 ( 0.21%) 2,141 ( 0.09%)  0          0           1,244 ( 0.04%)  1 ( 0.02%)  1 ( 0.02%)  	return ret;
     .            .           .              .           .          .               .           .           .           }
     .            .           .              .           .          .               .           .           .           
     .            .           .              .           .          .               .           .           .           JEMALLOC_ALWAYS_INLINE szind_t
     .            .           .              .           .          .               .           .           .           sz_size2index(size_t size) {
 3,605 ( 0.04%) 108 ( 0.07%)  7 ( 0.10%)   970 ( 0.04%)  0          0           1,195 ( 0.04%)  8 ( 0.15%)  3 ( 0.07%)  	if (likely(size <= SC_LOOKUP_MAXCLASS)) {
   324 ( 0.00%)   0           0             19 ( 0.00%)  0          0               0           0           0           		return sz_size2index_lookup(size);
     .            .           .              .           .          .               .           .           .           	}
   760 ( 0.01%) 133 ( 0.09%)  8 ( 0.11%)   322 ( 0.01%)  0          0             382 ( 0.01%)  5 ( 0.09%)  4 ( 0.10%)  	return sz_size2index_compute(size);
     .            .           .              .           .          .               .           .           .           }
     .            .           .              .           .          .               .           .           .           
     .            .           .              .           .          .               .           .           .           static inline size_t
     .            .           .              .           .          .               .           .           .           sz_index2size_compute(szind_t index) {
     .            .           .              .           .          .               .           .           .           #if (SC_NTINY > 0)
     .            .           .              .           .          .               .           .           .           	if (index < SC_NTINY) {
     .            .           .              .           .          .               .           .           .           		return (ZU(1) << (SC_LG_TINY_MAXCLASS - SC_NTINY + 1 + index));
     .            .           .              .           .          .               .           .           .           	}
-- line 215 ----------------------------------------
-- line 230 ----------------------------------------
     .            .           .              .           .          .               .           .           .           
     .            .           .              .           .          .               .           .           .           		size_t usize = grp_size + mod_size;
     .            .           .              .           .          .               .           .           .           		return usize;
     .            .           .              .           .          .               .           .           .           	}
     .            .           .              .           .          .               .           .           .           }
     .            .           .              .           .          .               .           .           .           
     .            .           .              .           .          .               .           .           .           JEMALLOC_ALWAYS_INLINE size_t
     .            .           .              .           .          .               .           .           .           sz_index2size_lookup_impl(szind_t index) {
 9,873 ( 0.10%)  28 ( 0.02%)  1 ( 0.01%) 4,987 ( 0.21%) 18 ( 0.31%) 0           1,450 ( 0.05%)  0           0           	return sz_index2size_tab[index];
     .            .           .              .           .          .               .           .           .           }
     .            .           .              .           .          .               .           .           .           
     .            .           .              .           .          .               .           .           .           JEMALLOC_ALWAYS_INLINE size_t
     .            .           .              .           .          .               .           .           .           sz_index2size_lookup(szind_t index) {
11,212 ( 0.12%) 302 ( 0.21%)  8 ( 0.11%)   889 ( 0.04%)  1 ( 0.02%) 0          10,143 ( 0.32%) 12 ( 0.23%)  9 ( 0.21%)  	size_t ret = sz_index2size_lookup_impl(index);
17,436 ( 0.18%) 258 ( 0.18%)  7 ( 0.10%) 1,340 ( 0.06%)  0          0           9,142 ( 0.29%)  0           0           	assert(ret == sz_index2size_compute(index));
23,362 ( 0.25%) 629 ( 0.44%) 15 ( 0.21%) 3,508 ( 0.14%)  1 ( 0.02%) 0          10,018 ( 0.32%)  0           0           	return ret;
     .            .           .              .           .          .               .           .           .           }
     .            .           .              .           .          .               .           .           .           
     .            .           .              .           .          .               .           .           .           JEMALLOC_ALWAYS_INLINE size_t
     .            .           .              .           .          .               .           .           .           sz_index2size(szind_t index) {
11,055 ( 0.12%) 370 ( 0.26%) 11 ( 0.15%) 3,102 ( 0.13%)  0          0           3,103 ( 0.10%)  0           0           	assert(index < SC_NSIZES);
 1,784 ( 0.02%)   0           0            594 ( 0.02%)  0          0              16 ( 0.00%)  0           0           	return sz_index2size_lookup(index);
     .            .           .              .           .          .               .           .           .           }
     .            .           .              .           .          .               .           .           .           
     .            .           .              .           .          .               .           .           .           JEMALLOC_ALWAYS_INLINE void
     .            .           .              .           .          .               .           .           .           sz_size2index_usize_fastpath(size_t size, szind_t *ind, size_t *usize) {
 1,852 ( 0.02%)   0           0            926 ( 0.04%)  0          0             926 ( 0.03%)  2 ( 0.04%)  0           	*ind = sz_size2index_lookup_impl(size);
 4,630 ( 0.05%) 236 ( 0.16%)  1 ( 0.01%) 2,778 ( 0.11%)  0          0           1,852 ( 0.06%)  3 ( 0.06%)  0           	*usize = sz_index2size_lookup_impl(*ind);
   926 ( 0.01%)   0           0              0           0          0               0           0           0           }
     .            .           .              .           .          .               .           .           .           
     .            .           .              .           .          .               .           .           .           JEMALLOC_ALWAYS_INLINE size_t
     .            .           .              .           .          .               .           .           .           sz_s2u_compute(size_t size) {
 4,867 ( 0.05%) 202 ( 0.14%)  6 ( 0.08%)   926 ( 0.04%)  0          0           2,487 ( 0.08%)  0           0           	if (unlikely(size > SC_LARGE_MAXCLASS)) {
 4,414 ( 0.05%) 105 ( 0.07%)  1 ( 0.01%) 1,434 ( 0.06%)  0          0           2,408 ( 0.08%)  0           0           		return 0;
     .            .           .              .           .          .               .           .           .           	}
     .            .           .              .           .          .               .           .           .           
 8,766 ( 0.09%)  11 ( 0.01%)  6 ( 0.08%) 2,950 ( 0.12%)  0          0           3,644 ( 0.12%)  0           0           	if (size == 0) {
 5,480 ( 0.06%)  10 ( 0.01%)  2 ( 0.03%) 2,827 ( 0.12%) 18 ( 0.31%) 0           1,771 ( 0.06%)  0           0           		size++;
     .            .           .              .           .          .               .           .           .           	}
     .            .           .              .           .          .               .           .           .           #if (SC_NTINY > 0)
 7,231 ( 0.08%)   0           0          2,991 ( 0.12%) 22 ( 0.38%) 0           3,023 ( 0.10%)  0           0           	if (size <= (ZU(1) << SC_LG_TINY_MAXCLASS)) {
 4,940 ( 0.05%) 121 ( 0.08%)  4 ( 0.06%) 1,043 ( 0.04%)  0          0           2,206 ( 0.07%)  0           0           		size_t lg_tmin = SC_LG_TINY_MAXCLASS - SC_NTINY + 1;
 5,039 ( 0.05%) 239 ( 0.17%)  6 ( 0.08%) 1,386 ( 0.06%)  0          0           2,799 ( 0.09%)  0           0           		size_t lg_ceil = lg_floor(pow2_ceil_zu(size));
 8,730 ( 0.09%) 133 ( 0.09%)  5 ( 0.07%) 1,398 ( 0.06%)  0          0           4,845 ( 0.15%)  0           0           		return (lg_ceil < lg_tmin ? (ZU(1) << lg_tmin) :
     .            .           .              .           .          .               .           .           .           		    (ZU(1) << lg_ceil));
     .            .           .              .           .          .               .           .           .           	}
     .            .           .              .           .          .               .           .           .           #endif
     .            .           .              .           .          .               .           .           .           	{
18,352 ( 0.19%) 287 ( 0.20%) 15 ( 0.21%) 1,726 ( 0.07%)  0          0           6,776 ( 0.21%)  2 ( 0.04%)  1 ( 0.02%)  		size_t x = lg_floor((size<<1)-1);
12,835 ( 0.14%) 371 ( 0.26%) 11 ( 0.15%) 3,408 ( 0.14%)  0          0           6,620 ( 0.21%)  0           0           		size_t lg_delta = (x < SC_LG_NGROUP + LG_QUANTUM + 1)
 9,201 ( 0.10%) 152 ( 0.11%)  9 ( 0.13%) 1,420 ( 0.06%)  0          0           3,980 ( 0.13%)  2 ( 0.04%)  0           		    ?  LG_QUANTUM : x - SC_LG_NGROUP - 1;
 6,019 ( 0.06%) 125 ( 0.09%)  5 ( 0.07%)   316 ( 0.01%)  0          0           5,203 ( 0.16%)  1 ( 0.02%)  1 ( 0.02%)  		size_t delta = ZU(1) << lg_delta;
12,844 ( 0.14%) 108 ( 0.07%)  3 ( 0.04%) 3,266 ( 0.13%)  0          0           3,731 ( 0.12%)  1 ( 0.02%)  1 ( 0.02%)  		size_t delta_mask = delta - 1;
20,917 ( 0.22%)  98 ( 0.07%)  8 ( 0.11%) 7,481 ( 0.31%)  0          0           4,787 ( 0.15%) 11 ( 0.21%)  1 ( 0.02%)  		size_t usize = (size + delta_mask) & ~delta_mask;
16,460 ( 0.17%) 316 ( 0.22%)  6 ( 0.08%) 8,325 ( 0.34%)  0          0           6,134 ( 0.19%)  0           0           		return usize;
     .            .           .              .           .          .               .           .           .           	}
     .            .           .              .           .          .               .           .           .           }
     .            .           .              .           .          .               .           .           .           
     .            .           .              .           .          .               .           .           .           JEMALLOC_ALWAYS_INLINE size_t
     .            .           .              .           .          .               .           .           .           sz_s2u_lookup(size_t size) {
 2,435 ( 0.03%)  89 ( 0.06%)  1 ( 0.01%)   791 ( 0.03%)  0          0             675 ( 0.02%)  1 ( 0.02%)  0           	size_t ret = sz_index2size_lookup(sz_size2index_lookup(size));
     .            .           .              .           .          .               .           .           .           
18,135 ( 0.19%) 196 ( 0.14%)  4 ( 0.06%)   132 ( 0.01%)  0          0          12,188 ( 0.39%)  0           0           	assert(ret == sz_s2u_compute(size));
 7,488 ( 0.08%) 252 ( 0.17%)  8 ( 0.11%) 2,103 ( 0.09%)  0          0           1,660 ( 0.05%)  0           0           	return ret;
     .            .           .              .           .          .               .           .           .           }
     .            .           .              .           .          .               .           .           .           
     .            .           .              .           .          .               .           .           .           /*
     .            .           .              .           .          .               .           .           .            * Compute usable size that would result from allocating an object with the
     .            .           .              .           .          .               .           .           .            * specified size.
     .            .           .              .           .          .               .           .           .            */
     .            .           .              .           .          .               .           .           .           JEMALLOC_ALWAYS_INLINE size_t
     .            .           .              .           .          .               .           .           .           sz_s2u(size_t size) {
15,434 ( 0.16%) 237 ( 0.16%) 10 ( 0.14%) 2,145 ( 0.09%)  0          0           6,525 ( 0.21%)  5 ( 0.09%)  2 ( 0.05%)  	if (likely(size <= SC_LOOKUP_MAXCLASS)) {
 7,316 ( 0.08%)  34 ( 0.02%)  6 ( 0.08%) 1,223 ( 0.05%)  0          0           3,793 ( 0.12%)  8 ( 0.15%)  5 ( 0.12%)  		return sz_s2u_lookup(size);
     .            .           .              .           .          .               .           .           .           	}
   499 ( 0.01%)   0           0              0           0          0               0           0           0           	return sz_s2u_compute(size);
     .            .           .              .           .          .               .           .           .           }
     .            .           .              .           .          .               .           .           .           
     .            .           .              .           .          .               .           .           .           /*
     .            .           .              .           .          .               .           .           .            * Compute usable size that would result from allocating an object with the
     .            .           .              .           .          .               .           .           .            * specified size and alignment.
     .            .           .              .           .          .               .           .           .            */
     .            .           .              .           .          .               .           .           .           JEMALLOC_ALWAYS_INLINE size_t
     .            .           .              .           .          .               .           .           .           sz_sa2u(size_t size, size_t alignment) {
     .            .           .              .           .          .               .           .           .           	size_t usize;
     .            .           .              .           .          .               .           .           .           
   253 ( 0.00%)   0           0              0           0          0             195 ( 0.01%)  0           0           	assert(alignment != 0 && ((alignment - 1) & alignment) == 0);
     .            .           .              .           .          .               .           .           .           
     .            .           .              .           .          .               .           .           .           	/* Try for a small size class. */
11,999 ( 0.13%)  92 ( 0.06%)  4 ( 0.06%) 6,236 ( 0.26%)  0          0           7,149 ( 0.23%)  0           0           	if (size <= SC_SMALL_MAXCLASS && alignment <= PAGE) {
     .            .           .              .           .          .               .           .           .           		/*
     .            .           .              .           .          .               .           .           .           		 * Round size up to the nearest multiple of alignment.
     .            .           .              .           .          .               .           .           .           		 *
     .            .           .              .           .          .               .           .           .           		 * This done, we can take advantage of the fact that for each
     .            .           .              .           .          .               .           .           .           		 * small size class, every object is aligned at the smallest
     .            .           .              .           .          .               .           .           .           		 * power of two that is non-zero in the base two representation
     .            .           .              .           .          .               .           .           .           		 * of the size.  For example:
     .            .           .              .           .          .               .           .           .           		 *
     .            .           .              .           .          .               .           .           .           		 *   Size |   Base 2 | Minimum alignment
     .            .           .              .           .          .               .           .           .           		 *   -----+----------+------------------
     .            .           .              .           .          .               .           .           .           		 *     96 |  1100000 |  32
     .            .           .              .           .          .               .           .           .           		 *    144 | 10100000 |  32
     .            .           .              .           .          .               .           .           .           		 *    192 | 11000000 |  64
     .            .           .              .           .          .               .           .           .           		 */
30,635 ( 0.32%) 225 ( 0.16%)  3 ( 0.04%) 8,237 ( 0.34%)  0          0           5,651 ( 0.18%)  0           0           		usize = sz_s2u(ALIGNMENT_CEILING(size, alignment));
 2,934 ( 0.03%) 122 ( 0.08%)  2 ( 0.03%)   982 ( 0.04%)  0          0           1,952 ( 0.06%)  0           0           		if (usize < SC_LARGE_MINCLASS) {
   986 ( 0.01%)   0           0              7 ( 0.00%)  0          0               7 ( 0.00%)  0           0           			return usize;
     .            .           .              .           .          .               .           .           .           		}
     .            .           .              .           .          .               .           .           .           	}
     .            .           .              .           .          .               .           .           .           
     .            .           .              .           .          .               .           .           .           	/* Large size class.  Beware of overflow. */
     .            .           .              .           .          .               .           .           .           
   998 ( 0.01%)   2 ( 0.00%)  2 ( 0.03%)   486 ( 0.02%)  0          0              14 ( 0.00%)  0           0           	if (unlikely(alignment > SC_LARGE_MAXCLASS)) {
 1,007 ( 0.01%)   7 ( 0.00%)  1 ( 0.01%)    21 ( 0.00%)  0          0             495 ( 0.02%)  0           0           		return 0;
     .            .           .              .           .          .               .           .           .           	}
     .            .           .              .           .          .               .           .           .           
     .            .           .              .           .          .               .           .           .           	/* Make sure result is a large size class. */
   563 ( 0.01%)  46 ( 0.03%)  3 ( 0.04%)    20 ( 0.00%)  0          0             519 ( 0.02%)  0           0           	if (size <= SC_LARGE_MINCLASS) {
   524 ( 0.01%)   7 ( 0.00%)  1 ( 0.01%)     6 ( 0.00%)  0          0              20 ( 0.00%)  1 ( 0.02%)  0           		usize = SC_LARGE_MINCLASS;
     .            .           .              .           .          .               .           .           .           	} else {
 1,347 ( 0.01%)   0           0            253 ( 0.01%)  0          0             841 ( 0.03%)  5 ( 0.09%)  0           		usize = sz_s2u(size);
 1,318 ( 0.01%)   0           0            452 ( 0.02%)  0          0             449 ( 0.01%)  0           0           		if (usize < size) {
     .            .           .              .           .          .               .           .           .           			/* size_t overflow. */
 1,868 ( 0.02%)  13 ( 0.01%)  1 ( 0.01%)   195 ( 0.01%)  0          0           1,673 ( 0.05%)  0           0           			return 0;
     .            .           .              .           .          .               .           .           .           		}
     .            .           .              .           .          .               .           .           .           	}
     .            .           .              .           .          .               .           .           .           
     .            .           .              .           .          .               .           .           .           	/*
     .            .           .              .           .          .               .           .           .           	 * Calculate the multi-page mapping that large_palloc() would need in
     .            .           .              .           .          .               .           .           .           	 * order to guarantee the alignment.
     .            .           .              .           .          .               .           .           .           	 */
 1,559 ( 0.02%)  11 ( 0.01%)  3 ( 0.04%)   207 ( 0.01%)  1 ( 0.02%) 0             819 ( 0.03%)  0           0           	if (usize + sz_large_pad + PAGE_CEILING(alignment) - PAGE < usize) {
     .            .           .              .           .          .               .           .           .           		/* size_t overflow. */
 1,428 ( 0.02%)   0           0              0           0          0              13 ( 0.00%)  0           0           		return 0;
     .            .           .              .           .          .               .           .           .           	}
 1,459 ( 0.02%)   3 ( 0.00%)  2 ( 0.03%)   421 ( 0.02%)  0          0             425 ( 0.01%)  0           0           	return usize;
     .            .           .              .           .          .               .           .           .           }
     .            .           .              .           .          .               .           .           .           
     .            .           .              .           .          .               .           .           .           size_t sz_psz_quantize_floor(size_t size);
     .            .           .              .           .          .               .           .           .           size_t sz_psz_quantize_ceil(size_t size);
     .            .           .              .           .          .               .           .           .           
     .            .           .              .           .          .               .           .           .           #endif /* JEMALLOC_INTERNAL_SIZE_H */

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/ashy5000/dev/cryptocurrency/contracts/target/debug/build/tikv-jemalloc-sys-7365f40ecb99e085/out/build/include/jemalloc/internal/thread_event.h
--------------------------------------------------------------------------------
Ir             I1mr         ILmr        Dr             D1mr       DLmr       Dw             D1mw        DLmw        

-- line 73 ----------------------------------------
    .            .           .              .          .          .              .           .           .           
    .            .           .              .          .          .              .           .           .           /* Getters directly wrap TSD getters. */
    .            .           .              .          .          .              .           .           .           #define C(counter)							\
    .            .           .              .          .          .              .           .           .           JEMALLOC_ALWAYS_INLINE uint64_t						\
    .            .           .              .          .          .              .           .           .           counter##_get(tsd_t *tsd) {						\
    .            .           .              .          .          .              .           .           .           	return tsd_##counter##_get(tsd);				\
    .            .           .              .          .          .              .           .           .           }
    .            .           .              .          .          .              .           .           .           
    2 ( 0.00%)   0           0              0          0          0              0           0           0           ITERATE_OVER_ALL_COUNTERS
    .            .           .              .          .          .              .           .           .           #undef C
    .            .           .              .          .          .              .           .           .           
    .            .           .              .          .          .              .           .           .           /*
    .            .           .              .          .          .              .           .           .            * Setters call the TSD pointer getters rather than the TSD setters, so that
    .            .           .              .          .          .              .           .           .            * the counters can be modified even when TSD state is reincarnated or
    .            .           .              .          .          .              .           .           .            * minimal_initialized: if an event is triggered in such cases, we will
    .            .           .              .          .          .              .           .           .            * temporarily delay the event and let it be immediately triggered at the next
    .            .           .              .          .          .              .           .           .            * allocation call.
    .            .           .              .          .          .              .           .           .            */
    .            .           .              .          .          .              .           .           .           #define C(counter)							\
    .            .           .              .          .          .              .           .           .           JEMALLOC_ALWAYS_INLINE void						\
    .            .           .              .          .          .              .           .           .           counter##_set(tsd_t *tsd, uint64_t v) {					\
    .            .           .              .          .          .              .           .           .           	*tsd_##counter##p_get(tsd) = v;					\
    .            .           .              .          .          .              .           .           .           }
    .            .           .              .          .          .              .           .           .           
1,832 ( 0.02%)  14 ( 0.01%)  1 ( 0.01%)   916 ( 0.04%) 0          0            916 ( 0.03%)  0           0           ITERATE_OVER_ALL_COUNTERS
    .            .           .              .          .          .              .           .           .           #undef C
    .            .           .              .          .          .              .           .           .           
    .            .           .              .          .          .              .           .           .           /*
    .            .           .              .          .          .              .           .           .            * For generating _event_wait getter / setter functions for each individual
    .            .           .              .          .          .              .           .           .            * event.
    .            .           .              .          .          .              .           .           .            */
    .            .           .              .          .          .              .           .           .           #undef E
    .            .           .              .          .          .              .           .           .           
-- line 105 ----------------------------------------
-- line 107 ----------------------------------------
    .            .           .              .          .          .              .           .           .            * The malloc and free fastpath getters -- use the unsafe getters since tsd may
    .            .           .              .          .          .              .           .           .            * be non-nominal, in which case the fast_threshold will be set to 0.  This
    .            .           .              .          .          .              .           .           .            * allows checking for events and tsd non-nominal in a single branch.
    .            .           .              .          .          .              .           .           .            *
    .            .           .              .          .          .              .           .           .            * Note that these can only be used on the fastpath.
    .            .           .              .          .          .              .           .           .            */
    .            .           .              .          .          .              .           .           .           JEMALLOC_ALWAYS_INLINE void
    .            .           .              .          .          .              .           .           .           te_malloc_fastpath_ctx(tsd_t *tsd, uint64_t *allocated, uint64_t *threshold) {
4,630 ( 0.05%) 166 ( 0.12%)  1 ( 0.01%) 2,778 ( 0.11%) 0          0          1,852 ( 0.06%)  0           0           	*allocated = *tsd_thread_allocatedp_get_unsafe(tsd);
2,778 ( 0.03%)   0           0          1,852 ( 0.08%) 0          0            926 ( 0.03%)  0           0           	*threshold = *tsd_thread_allocated_next_event_fastp_get_unsafe(tsd);
3,704 ( 0.04%)   0           0              0          0          0              0           0           0           	assert(*threshold <= TE_NEXT_EVENT_FAST_MAX);
  926 ( 0.01%) 236 ( 0.16%)  1 ( 0.01%)     0          0          0              0           0           0           }
    .            .           .              .          .          .              .           .           .           
    .            .           .              .          .          .              .           .           .           JEMALLOC_ALWAYS_INLINE void
    .            .           .              .          .          .              .           .           .           te_free_fastpath_ctx(tsd_t *tsd, uint64_t *deallocated, uint64_t *threshold) {
    .            .           .              .          .          .              .           .           .           	/* Unsafe getters since this may happen before tsd_init. */
4,625 ( 0.05%)  50 ( 0.03%)  1 ( 0.01%) 2,775 ( 0.11%) 0          0          1,850 ( 0.06%)  0           0           	*deallocated = *tsd_thread_deallocatedp_get_unsafe(tsd);
2,775 ( 0.03%)   0           0          1,850 ( 0.08%) 0          0            925 ( 0.03%)  0           0           	*threshold = *tsd_thread_deallocated_next_event_fastp_get_unsafe(tsd);
3,700 ( 0.04%)   0           0              0          0          0              0           0           0           	assert(*threshold <= TE_NEXT_EVENT_FAST_MAX);
  925 ( 0.01%) 132 ( 0.09%)  1 ( 0.01%)     0          0          0              0           0           0           }
    .            .           .              .          .          .              .           .           .           
    .            .           .              .          .          .              .           .           .           JEMALLOC_ALWAYS_INLINE bool
    .            .           .              .          .          .              .           .           .           te_ctx_is_alloc(te_ctx_t *ctx) {
    .            .           .              .          .          .              .           .           .           	return ctx->is_alloc;
    .            .           .              .          .          .              .           .           .           }
    .            .           .              .          .          .              .           .           .           
    .            .           .              .          .          .              .           .           .           JEMALLOC_ALWAYS_INLINE uint64_t
    .            .           .              .          .          .              .           .           .           te_ctx_current_bytes_get(te_ctx_t *ctx) {
  925 ( 0.01%)  31 ( 0.02%)  1 ( 0.01%)   919 ( 0.04%) 0          0              4 ( 0.00%)  0           0           	return *ctx->current;
    .            .           .              .          .          .              .           .           .           }
    .            .           .              .          .          .              .           .           .           
    .            .           .              .          .          .              .           .           .           JEMALLOC_ALWAYS_INLINE void
    .            .           .              .          .          .              .           .           .           te_ctx_current_bytes_set(te_ctx_t *ctx, uint64_t v) {
1,254 ( 0.01%)  64 ( 0.04%)  2 ( 0.03%)   654 ( 0.03%) 0          0            574 ( 0.02%)  0           0           	*ctx->current = v;
  881 ( 0.01%)   0           0              0          0          0            445 ( 0.01%)  3 ( 0.06%)  1 ( 0.02%)  }
    .            .           .              .          .          .              .           .           .           
    .            .           .              .          .          .              .           .           .           JEMALLOC_ALWAYS_INLINE uint64_t
    .            .           .              .          .          .              .           .           .           te_ctx_last_event_get(te_ctx_t *ctx) {
   18 ( 0.00%)   0           0             18 ( 0.00%) 0          0              0           0           0           	return *ctx->last_event;
    .            .           .              .          .          .              .           .           .           }
    .            .           .              .          .          .              .           .           .           
    .            .           .              .          .          .              .           .           .           JEMALLOC_ALWAYS_INLINE void
    .            .           .              .          .          .              .           .           .           te_ctx_last_event_set(te_ctx_t *ctx, uint64_t v) {
   16 ( 0.00%)   1 ( 0.00%)  1 ( 0.01%)    12 ( 0.00%) 0          0              4 ( 0.00%)  1 ( 0.02%)  0           	*ctx->last_event = v;
    4 ( 0.00%)   0           0              0          0          0              0           0           0           }
    .            .           .              .          .          .              .           .           .           
    .            .           .              .          .          .              .           .           .           /* Below 3 for next_event_fast. */
    .            .           .              .          .          .              .           .           .           JEMALLOC_ALWAYS_INLINE uint64_t
    .            .           .              .          .          .              .           .           .           te_ctx_next_event_fast_get(te_ctx_t *ctx) {
    .            .           .              .          .          .              .           .           .           	uint64_t v = *ctx->next_event_fast;
    .            .           .              .          .          .              .           .           .           	assert(v <= TE_NEXT_EVENT_FAST_MAX);
    .            .           .              .          .          .              .           .           .           	return v;
    .            .           .              .          .          .              .           .           .           }
    .            .           .              .          .          .              .           .           .           
    .            .           .              .          .          .              .           .           .           JEMALLOC_ALWAYS_INLINE void
    .            .           .              .          .          .              .           .           .           te_ctx_next_event_fast_set(te_ctx_t *ctx, uint64_t v) {
   40 ( 0.00%)   0           0              0          0          0              0           0           0           	assert(v <= TE_NEXT_EVENT_FAST_MAX);
   40 ( 0.00%)   0           0             30 ( 0.00%) 0          0             10 ( 0.00%)  1 ( 0.02%)  0           	*ctx->next_event_fast = v;
   10 ( 0.00%)   0           0              0          0          0              0           0           0           }
    .            .           .              .          .          .              .           .           .           
    .            .           .              .          .          .              .           .           .           JEMALLOC_ALWAYS_INLINE void
    .            .           .              .          .          .              .           .           .           te_next_event_fast_set_non_nominal(tsd_t *tsd) {
    .            .           .              .          .          .              .           .           .           	/*
    .            .           .              .          .          .              .           .           .           	 * Set the fast thresholds to zero when tsd is non-nominal.  Use the
    .            .           .              .          .          .              .           .           .           	 * unsafe getter as this may get called during tsd init and clean up.
    .            .           .              .          .          .              .           .           .           	 */
   12 ( 0.00%)   0           0              4 ( 0.00%) 0          0              8 ( 0.00%)  0           0           	*tsd_thread_allocated_next_event_fastp_get_unsafe(tsd) = 0;
    4 ( 0.00%)   0           0              0          0          0              4 ( 0.00%)  0           0           	*tsd_thread_deallocated_next_event_fastp_get_unsafe(tsd) = 0;
   29 ( 0.00%)   4 ( 0.00%)  1 ( 0.01%)     5 ( 0.00%) 0          0             15 ( 0.00%)  1 ( 0.02%)  1 ( 0.02%)  }
    .            .           .              .          .          .              .           .           .           
    .            .           .              .          .          .              .           .           .           /* For next_event.  Setter also updates the fast threshold. */
    .            .           .              .          .          .              .           .           .           JEMALLOC_ALWAYS_INLINE uint64_t
    .            .           .              .          .          .              .           .           .           te_ctx_next_event_get(te_ctx_t *ctx) {
  993 ( 0.01%)  15 ( 0.01%)  1 ( 0.01%)   890 ( 0.04%) 1 ( 0.02%) 0            103 ( 0.00%)  0           0           	return *ctx->next_event;
    .            .           .              .          .          .              .           .           .           }
    .            .           .              .          .          .              .           .           .           
    .            .           .              .          .          .              .           .           .           JEMALLOC_ALWAYS_INLINE void
    .            .           .              .          .          .              .           .           .           te_ctx_next_event_set(tsd_t *tsd, te_ctx_t *ctx, uint64_t v) {
   16 ( 0.00%)   0           0             12 ( 0.00%) 0          0              4 ( 0.00%)  0           0           	*ctx->next_event = v;
   12 ( 0.00%)   0           0              4 ( 0.00%) 0          0              4 ( 0.00%)  1 ( 0.02%)  1 ( 0.02%)  	te_recompute_fast_threshold(tsd);
    4 ( 0.00%)   0           0              0          0          0              0           0           0           }
    .            .           .              .          .          .              .           .           .           
    .            .           .              .          .          .              .           .           .           /*
    .            .           .              .          .          .              .           .           .            * The function checks in debug mode whether the thread event counters are in
    .            .           .              .          .          .              .           .           .            * a consistent state, which forms the invariants before and after each round
    .            .           .              .          .          .              .           .           .            * of thread event handling that we can rely on and need to promise.
    .            .           .              .          .          .              .           .           .            * The invariants are only temporarily violated in the middle of
    .            .           .              .          .          .              .           .           .            * te_event_advance() if an event is triggered (the te_event_trigger() call at
    .            .           .              .          .          .              .           .           .            * the end will restore the invariants).
    .            .           .              .          .          .              .           .           .            */
    .            .           .              .          .          .              .           .           .           JEMALLOC_ALWAYS_INLINE void
    .            .           .              .          .          .              .           .           .           te_assert_invariants(tsd_t *tsd) {
1,510 ( 0.02%)  19 ( 0.01%)  1 ( 0.01%)   124 ( 0.01%) 0          0             42 ( 0.00%)  0           0           	if (config_debug) {
  227 ( 0.00%)   0           0            124 ( 0.01%) 0          0            103 ( 0.00%)  0           0           		te_assert_invariants_debug(tsd);
    .            .           .              .          .          .              .           .           .           	}
  585 ( 0.01%)  89 ( 0.06%)  5 ( 0.07%)    22 ( 0.00%) 1 ( 0.02%) 0            124 ( 0.00%)  0           0           }
    .            .           .              .          .          .              .           .           .           
    .            .           .              .          .          .              .           .           .           JEMALLOC_ALWAYS_INLINE void
    .            .           .              .          .          .              .           .           .           te_ctx_get(tsd_t *tsd, te_ctx_t *ctx, bool is_alloc) {
  690 ( 0.01%)  20 ( 0.01%)  3 ( 0.04%)   460 ( 0.02%) 0          0            230 ( 0.01%)  0           0           	ctx->is_alloc = is_alloc;
  944 ( 0.01%) 106 ( 0.07%)  3 ( 0.04%)   472 ( 0.02%) 0          0            242 ( 0.01%)  2 ( 0.04%)  2 ( 0.05%)  	if (is_alloc) {
  742 ( 0.01%) 116 ( 0.08%)  4 ( 0.06%)   367 ( 0.02%) 0          0            371 ( 0.01%)  6 ( 0.11%)  3 ( 0.07%)  		ctx->current = tsd_thread_allocatedp_get(tsd);
  921 ( 0.01%)  51 ( 0.04%)  4 ( 0.06%)   363 ( 0.01%) 0          0            558 ( 0.02%)  3 ( 0.06%)  2 ( 0.05%)  		ctx->last_event = tsd_thread_allocated_last_eventp_get(tsd);
  728 ( 0.01%)  20 ( 0.01%)  3 ( 0.04%)   365 ( 0.02%) 0          0            363 ( 0.01%)  1 ( 0.02%)  0           		ctx->next_event = tsd_thread_allocated_next_eventp_get(tsd);
  263 ( 0.00%)   0           0            128 ( 0.01%) 0          0            128 ( 0.00%)  0           0           		ctx->next_event_fast =
    .            .           .              .          .          .              .           .           .           		    tsd_thread_allocated_next_event_fastp_get(tsd);
    .            .           .              .          .          .              .           .           .           	} else {
  675 ( 0.01%)   4 ( 0.00%)  1 ( 0.01%)   334 ( 0.01%) 0          0            341 ( 0.01%)  1 ( 0.02%)  0           		ctx->current = tsd_thread_deallocatedp_get(tsd);
1,010 ( 0.01%)  31 ( 0.02%)  1 ( 0.01%)   327 ( 0.01%) 0          0            683 ( 0.02%)  3 ( 0.06%)  1 ( 0.02%)  		ctx->last_event = tsd_thread_deallocated_last_eventp_get(tsd);
  965 ( 0.01%)  37 ( 0.03%)  3 ( 0.04%)   327 ( 0.01%) 0          0            638 ( 0.02%)  2 ( 0.04%)  1 ( 0.02%)  		ctx->next_event = tsd_thread_deallocated_next_eventp_get(tsd);
1,107 ( 0.01%)  25 ( 0.02%)  2 ( 0.03%)   440 ( 0.02%) 0          0            667 ( 0.02%) 41 ( 0.77%) 40 ( 0.95%)  		ctx->next_event_fast =
    .            .           .              .          .          .              .           .           .           		    tsd_thread_deallocated_next_event_fastp_get(tsd);
    .            .           .              .          .          .              .           .           .           	}
1,281 ( 0.01%) 193 ( 0.13%) 11 ( 0.15%)   251 ( 0.01%) 0          0            445 ( 0.01%) 20 ( 0.38%)  6 ( 0.14%)  }
    .            .           .              .          .          .              .           .           .           
    .            .           .              .          .          .              .           .           .           /*
    .            .           .              .          .          .              .           .           .            * The lookahead functionality facilitates events to be able to lookahead, i.e.
    .            .           .              .          .          .              .           .           .            * without touching the event counters, to determine whether an event would be
    .            .           .              .          .          .              .           .           .            * triggered.  The event counters are not advanced until the end of the
    .            .           .              .          .          .              .           .           .            * allocation / deallocation calls, so the lookahead can be useful if some
    .            .           .              .          .          .              .           .           .            * preparation work for some event must be done early in the allocation /
    .            .           .              .          .          .              .           .           .            * deallocation calls.
-- line 228 ----------------------------------------
-- line 233 ----------------------------------------
    .            .           .              .          .          .              .           .           .            * Surplus is a terminology referring to the amount of bytes beyond what's
    .            .           .              .          .          .              .           .           .            * needed for triggering an event, which can be a useful quantity to have in
    .            .           .              .          .          .              .           .           .            * general when lookahead is being called.
    .            .           .              .          .          .              .           .           .            */
    .            .           .              .          .          .              .           .           .           
    .            .           .              .          .          .              .           .           .           JEMALLOC_ALWAYS_INLINE bool
    .            .           .              .          .          .              .           .           .           te_prof_sample_event_lookahead_surplus(tsd_t *tsd, size_t usize,
    .            .           .              .          .          .              .           .           .               size_t *surplus) {
2,500 ( 0.03%)   0           0            500 ( 0.02%) 0          0          1,500 ( 0.05%)  1 ( 0.02%)  0           	if (surplus != NULL) {
    .            .           .              .          .          .              .           .           .           		/*
    .            .           .              .          .          .              .           .           .           		 * This is a dead store: the surplus will be overwritten before
    .            .           .              .          .          .              .           .           .           		 * any read.  The initialization suppresses compiler warnings.
    .            .           .              .          .          .              .           .           .           		 * Meanwhile, using SIZE_MAX to initialize is good for
    .            .           .              .          .          .              .           .           .           		 * debugging purpose, because a valid surplus value is strictly
    .            .           .              .          .          .              .           .           .           		 * less than usize, which is at most SIZE_MAX.
    .            .           .              .          .          .              .           .           .           		 */
1,500 ( 0.02%)   0           0              0          0          0          1,000 ( 0.03%)  0           0           		*surplus = SIZE_MAX;
    .            .           .              .          .          .              .           .           .           	}
1,500 ( 0.02%)   0           0              0          0          0          1,500 ( 0.05%)  0           0           	if (unlikely(!tsd_nominal(tsd) || tsd_reentrancy_level_get(tsd) > 0)) {
    .            .           .              .          .          .              .           .           .           		return false;
    .            .           .              .          .          .              .           .           .           	}
    .            .           .              .          .          .              .           .           .           	/* The subtraction is intentionally susceptible to underflow. */
2,817 ( 0.03%)   0           0              0          0          0          2,817 ( 0.09%)  0           0           	uint64_t accumbytes = tsd_thread_allocated_get(tsd) + usize -
    .            .           .              .          .          .              .           .           .           	    tsd_thread_allocated_last_event_get(tsd);
    .            .           .              .          .          .              .           .           .           	uint64_t sample_wait = tsd_prof_sample_event_wait_get(tsd);
    .            .           .              .          .          .              .           .           .           	if (accumbytes < sample_wait) {
    .            .           .              .          .          .              .           .           .           		return false;
    .            .           .              .          .          .              .           .           .           	}
    .            .           .              .          .          .              .           .           .           	assert(accumbytes - sample_wait < (uint64_t)usize);
    .            .           .              .          .          .              .           .           .           	if (surplus != NULL) {
    .            .           .              .          .          .              .           .           .           		*surplus = (size_t)(accumbytes - sample_wait);
-- line 263 ----------------------------------------
-- line 270 ----------------------------------------
    .            .           .              .          .          .              .           .           .           	return te_prof_sample_event_lookahead_surplus(tsd, usize, NULL);
    .            .           .              .          .          .              .           .           .           }
    .            .           .              .          .          .              .           .           .           
    .            .           .              .          .          .              .           .           .           JEMALLOC_ALWAYS_INLINE void
    .            .           .              .          .          .              .           .           .           te_event_advance(tsd_t *tsd, size_t usize, bool is_alloc) {
    .            .           .              .          .          .              .           .           .           	te_assert_invariants(tsd);
    .            .           .              .          .          .              .           .           .           
    .            .           .              .          .          .              .           .           .           	te_ctx_t ctx;
1,526 ( 0.02%)  62 ( 0.04%)  3 ( 0.04%)   654 ( 0.03%) 0          0            654 ( 0.02%)  5 ( 0.09%)  2 ( 0.05%)  	te_ctx_get(tsd, &ctx, is_alloc);
    .            .           .              .          .          .              .           .           .           
  244 ( 0.00%)   0           0              0          0          0            244 ( 0.01%)  0           0           	uint64_t bytes_before = te_ctx_current_bytes_get(&ctx);
1,412 ( 0.01%)  36 ( 0.02%)  3 ( 0.04%)   462 ( 0.02%) 0          0            488 ( 0.02%)  2 ( 0.04%)  0           	te_ctx_current_bytes_set(&ctx, bytes_before + usize);
    .            .           .              .          .          .              .           .           .           
    .            .           .              .          .          .              .           .           .           	/* The subtraction is intentionally susceptible to underflow. */
1,961 ( 0.02%) 232 ( 0.16%)  4 ( 0.06%)   652 ( 0.03%) 0          0            237 ( 0.01%)  2 ( 0.04%)  1 ( 0.02%)  	if (likely(usize < te_ctx_next_event_get(&ctx) - bytes_before)) {
    .            .           .              .          .          .              .           .           .           		te_assert_invariants(tsd);
    .            .           .              .          .          .              .           .           .           	} else {
  176 ( 0.00%)   2 ( 0.00%)  0             23 ( 0.00%) 0          0            147 ( 0.00%)  0           0           		te_event_trigger(tsd, &ctx);
    .            .           .              .          .          .              .           .           .           	}
  262 ( 0.00%)  13 ( 0.01%)  1 ( 0.01%)    21 ( 0.00%) 0          0             21 ( 0.00%)  0           0           }
    .            .           .              .          .          .              .           .           .           
    .            .           .              .          .          .              .           .           .           JEMALLOC_ALWAYS_INLINE void
    .            .           .              .          .          .              .           .           .           thread_dalloc_event(tsd_t *tsd, size_t usize) {
    .            .           .              .          .          .              .           .           .           	te_event_advance(tsd, usize, false);
  299 ( 0.00%)   0           0             98 ( 0.00%) 0          0             98 ( 0.00%)  0           0           }
    .            .           .              .          .          .              .           .           .           
    .            .           .              .          .          .              .           .           .           JEMALLOC_ALWAYS_INLINE void
    .            .           .              .          .          .              .           .           .           thread_alloc_event(tsd_t *tsd, size_t usize) {
    .            .           .              .          .          .              .           .           .           	te_event_advance(tsd, usize, true);
1,296 ( 0.01%)  29 ( 0.02%)  1 ( 0.01%)   490 ( 0.02%) 0          0            588 ( 0.02%)  3 ( 0.06%)  2 ( 0.05%)  }
    .            .           .              .          .          .              .           .           .           
    .            .           .              .          .          .              .           .           .           #endif /* JEMALLOC_INTERNAL_THREAD_EVENT_H */

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/ashy5000/dev/cryptocurrency/contracts/target/debug/build/tikv-jemalloc-sys-7365f40ecb99e085/out/build/src/eset.c
--------------------------------------------------------------------------------
Ir             I1mr        ILmr       Dr             D1mr       DLmr       Dw             D1mw       DLmw       

    .           .          .              .          .          .              .          .          .           #include "jemalloc/internal/jemalloc_preamble.h"
    .           .          .              .          .          .              .          .          .           #include "jemalloc/internal/jemalloc_internal_includes.h"
    .           .          .              .          .          .              .          .          .           
    .           .          .              .          .          .              .          .          .           #include "jemalloc/internal/eset.h"
    .           .          .              .          .          .              .          .          .           
    .           .          .              .          .          .              .          .          .           #define ESET_NPSIZES (SC_NPSIZES + 1)
    .           .          .              .          .          .              .          .          .           
    .           .          .              .          .          .              .          .          .           static void
6,000 ( 0.06%)  2 ( 0.00%) 2 ( 0.03%)     0          0          0          2,400 ( 0.08%) 0          0           eset_bin_init(eset_bin_t *bin) {
3,600 ( 0.04%)  0          0          1,200 ( 0.05%) 0          0          1,200 ( 0.04%) 0          0           	edata_heap_new(&bin->heap);
    .           .          .              .          .          .              .          .          .           	/*
    .           .          .              .          .          .              .          .          .           	 * heap_min doesn't need initialization; it gets filled in when the bin
    .           .          .              .          .          .              .          .          .           	 * goes from non-empty to empty.
    .           .          .              .          .          .              .          .          .           	 */
3,600 ( 0.04%)  0          0          2,400 ( 0.10%) 0          0              0          0          0           }
    .           .          .              .          .          .              .          .          .           
    .           .          .              .          .          .              .          .          .           static void
9,600 ( 0.10%)  0          0          1,200 ( 0.05%) 0          0          3,600 ( 0.11%) 0          0           eset_bin_stats_init(eset_bin_stats_t *bin_stats) {
7,200 ( 0.08%)  1 ( 0.00%) 1 ( 0.01%) 2,400 ( 0.10%) 0          0          4,800 ( 0.15%) 0          0           	atomic_store_zu(&bin_stats->nextents, 0, ATOMIC_RELAXED);
8,400 ( 0.09%)  1 ( 0.00%) 1 ( 0.01%) 2,400 ( 0.10%) 0          0          4,800 ( 0.15%) 0          0           	atomic_store_zu(&bin_stats->nbytes, 0, ATOMIC_RELAXED);
7,200 ( 0.08%)  0          0          4,800 ( 0.20%) 0          0              0          0          0           }
    .           .          .              .          .          .              .          .          .           
    .           .          .              .          .          .              .          .          .           void
   36 ( 0.00%)  1 ( 0.00%) 1 ( 0.01%)     0          0          0             18 ( 0.00%) 0          0           eset_init(eset_t *eset, extent_state_t state) {
3,624 ( 0.04%)  1 ( 0.00%) 1 ( 0.01%) 2,406 ( 0.10%) 0          0              6 ( 0.00%) 0          0           	for (unsigned i = 0; i < ESET_NPSIZES; i++) {
9,600 ( 0.10%)  0          0          2,400 ( 0.10%) 0          0          1,200 ( 0.04%) 0          0           		eset_bin_init(&eset->bins[i]);
9,600 ( 0.10%)  0          0          2,400 ( 0.10%) 0          0          1,200 ( 0.04%) 0          0           		eset_bin_stats_init(&eset->bin_stats[i]);
    .           .          .              .          .          .              .          .          .           	}
   24 ( 0.00%)  1 ( 0.00%) 1 ( 0.01%)     6 ( 0.00%) 0          0              6 ( 0.00%) 0          0           	fb_init(eset->bitmap, ESET_NPSIZES);
   24 ( 0.00%)  0          0              6 ( 0.00%) 0          0              6 ( 0.00%) 0          0           	edata_list_inactive_init(&eset->lru);
   18 ( 0.00%)  0          0             12 ( 0.00%) 0          0              6 ( 0.00%) 1 ( 0.02%) 1 ( 0.02%)  	eset->state = state;
   18 ( 0.00%)  0          0             12 ( 0.00%) 0          0              0          0          0           }
    .           .          .              .          .          .              .          .          .           
    .           .          .              .          .          .              .          .          .           size_t
    .           .          .              .          .          .              .          .          .           eset_npages_get(eset_t *eset) {
    .           .          .              .          .          .              .          .          .           	return atomic_load_zu(&eset->npages, ATOMIC_RELAXED);
    .           .          .              .          .          .              .          .          .           }
    .           .          .              .          .          .              .          .          .           
    .           .          .              .          .          .              .          .          .           size_t
    .           .          .              .          .          .              .          .          .           eset_nextents_get(eset_t *eset, pszind_t pind) {
-- line 40 ----------------------------------------
-- line 64 ----------------------------------------
    .           .          .              .          .          .              .          .          .           	atomic_store_zu(&eset->bin_stats[pind].nextents, cur - 1,
    .           .          .              .          .          .              .          .          .           	    ATOMIC_RELAXED);
    .           .          .              .          .          .              .          .          .           	cur = atomic_load_zu(&eset->bin_stats[pind].nbytes, ATOMIC_RELAXED);
    .           .          .              .          .          .              .          .          .           	atomic_store_zu(&eset->bin_stats[pind].nbytes, cur - sz,
    .           .          .              .          .          .              .          .          .           	    ATOMIC_RELAXED);
    .           .          .              .          .          .              .          .          .           }
    .           .          .              .          .          .              .          .          .           
    .           .          .              .          .          .              .          .          .           void
  288 ( 0.00%) 64 ( 0.04%) 2 ( 0.03%)    32 ( 0.00%) 0          0            128 ( 0.00%) 0          0           eset_insert(eset_t *eset, edata_t *edata) {
  128 ( 0.00%)  0          0              0          0          0              0          0          0           	assert(edata_state_get(edata) == eset->state);
    .           .          .              .          .          .              .          .          .           
  128 ( 0.00%) 64 ( 0.04%) 2 ( 0.03%)    32 ( 0.00%) 0          0             64 ( 0.00%) 0          0           	size_t size = edata_size_get(edata);
  192 ( 0.00%)  0          0             64 ( 0.00%) 0          0             96 ( 0.00%) 0          0           	size_t psz = sz_psz_quantize_floor(size);
   32 ( 0.00%)  0          0              0          0          0             32 ( 0.00%) 0          0           	pszind_t pind = sz_psz2ind(psz);
    .           .          .              .          .          .              .          .          .           
  160 ( 0.00%)  0          0             32 ( 0.00%) 0          0             96 ( 0.00%) 0          0           	edata_cmp_summary_t edata_cmp_summary = edata_cmp_summary_get(edata);
  320 ( 0.00%) 32 ( 0.02%) 1 ( 0.01%)    64 ( 0.00%) 0          0             32 ( 0.00%) 0          0           	if (edata_heap_empty(&eset->bins[pind].heap)) {
  160 ( 0.00%)  0          0             64 ( 0.00%) 0          0             32 ( 0.00%) 0          0           		fb_set(eset->bitmap, ESET_NPSIZES, (size_t)pind);
    .           .          .              .          .          .              .          .          .           		/* Only element is automatically the min element. */
  320 ( 0.00%) 32 ( 0.02%) 1 ( 0.01%)   128 ( 0.01%) 0          0             64 ( 0.00%) 1 ( 0.02%) 0           		eset->bins[pind].heap_min = edata_cmp_summary;
    .           .          .              .          .          .              .          .          .           	} else {
    .           .          .              .          .          .              .          .          .           		/*
    .           .          .              .          .          .              .          .          .           		 * There's already a min element; update the summary if we're
    .           .          .              .          .          .              .          .          .           		 * about to insert a lower one.
    .           .          .              .          .          .              .          .          .           		 */
    .           .          .              .          .          .              .          .          .           		if (edata_cmp_summary_comp(edata_cmp_summary,
    .           .          .              .          .          .              .          .          .           		    eset->bins[pind].heap_min) < 0) {
    .           .          .              .          .          .              .          .          .           			eset->bins[pind].heap_min = edata_cmp_summary;
    .           .          .              .          .          .              .          .          .           		}
    .           .          .              .          .          .              .          .          .           	}
  320 ( 0.00%) 64 ( 0.04%) 2 ( 0.03%)    96 ( 0.00%) 0          0             32 ( 0.00%) 0          0           	edata_heap_insert(&eset->bins[pind].heap, edata);
    .           .          .              .          .          .              .          .          .           
   96 ( 0.00%)  0          0              0          0          0              0          0          0           	if (config_stats) {
    .           .          .              .          .          .              .          .          .           		eset_stats_add(eset, pind, size);
    .           .          .              .          .          .              .          .          .           	}
    .           .          .              .          .          .              .          .          .           
  192 ( 0.00%) 32 ( 0.02%) 1 ( 0.01%)    64 ( 0.00%) 0          0             32 ( 0.00%) 0          0           	edata_list_inactive_append(&eset->lru, edata);
   96 ( 0.00%)  0          0             32 ( 0.00%) 0          0             32 ( 0.00%) 0          0           	size_t npages = size >> LG_PAGE;
    .           .          .              .          .          .              .          .          .           	/*
    .           .          .              .          .          .              .          .          .           	 * All modifications to npages hold the mutex (as asserted above), so we
    .           .          .              .          .          .              .          .          .           	 * don't need an atomic fetch-add; we can get by with a load followed by
    .           .          .              .          .          .              .          .          .           	 * a store.
    .           .          .              .          .          .              .          .          .           	 */
    .           .          .              .          .          .              .          .          .           	size_t cur_eset_npages =
  224 ( 0.00%) 32 ( 0.02%) 1 ( 0.01%)    64 ( 0.00%) 0          0            128 ( 0.00%) 0          0           	    atomic_load_zu(&eset->npages, ATOMIC_RELAXED);
  320 ( 0.00%) 32 ( 0.02%) 1 ( 0.01%)   128 ( 0.01%) 0          0            128 ( 0.00%) 0          0           	atomic_store_zu(&eset->npages, cur_eset_npages + npages,
    .           .          .              .          .          .              .          .          .           	    ATOMIC_RELAXED);
  192 ( 0.00%)  0          0            128 ( 0.01%) 0          0              0          0          0           }
    .           .          .              .          .          .              .          .          .           
    .           .          .              .          .          .              .          .          .           void
  310 ( 0.00%) 51 ( 0.04%) 1 ( 0.01%)    31 ( 0.00%) 0          0            155 ( 0.00%) 0          0           eset_remove(eset_t *eset, edata_t *edata) {
  124 ( 0.00%)  0          0              0          0          0              0          0          0           	assert(edata_state_get(edata) == eset->state ||
    .           .          .              .          .          .              .          .          .           	    edata_state_in_transition(edata_state_get(edata)));
    .           .          .              .          .          .              .          .          .           
  124 ( 0.00%) 31 ( 0.02%) 1 ( 0.01%)    31 ( 0.00%) 0          0             62 ( 0.00%) 0          0           	size_t size = edata_size_get(edata);
  186 ( 0.00%) 31 ( 0.02%) 1 ( 0.01%)    62 ( 0.00%) 0          0             93 ( 0.00%) 0          0           	size_t psz = sz_psz_quantize_floor(size);
   31 ( 0.00%)  0          0              0          0          0             31 ( 0.00%) 0          0           	pszind_t pind = sz_psz2ind(psz);
   93 ( 0.00%)  0          0              0          0          0              0          0          0           	if (config_stats) {
    .           .          .              .          .          .              .          .          .           		eset_stats_sub(eset, pind, size);
    .           .          .              .          .          .              .          .          .           	}
    .           .          .              .          .          .              .          .          .           
  155 ( 0.00%) 31 ( 0.02%) 1 ( 0.01%)    31 ( 0.00%) 0          0             93 ( 0.00%) 0          0           	edata_cmp_summary_t edata_cmp_summary = edata_cmp_summary_get(edata);
  310 ( 0.00%) 31 ( 0.02%) 1 ( 0.01%)    93 ( 0.00%) 0          0             31 ( 0.00%) 0          0           	edata_heap_remove(&eset->bins[pind].heap, edata);
  310 ( 0.00%)  0          0             62 ( 0.00%) 0          0             31 ( 0.00%) 0          0           	if (edata_heap_empty(&eset->bins[pind].heap)) {
  186 ( 0.00%) 31 ( 0.02%) 1 ( 0.01%)    62 ( 0.00%) 0          0             31 ( 0.00%) 0          0           		fb_unset(eset->bitmap, ESET_NPSIZES, (size_t)pind);
    .           .          .              .          .          .              .          .          .           	} else {
    .           .          .              .          .          .              .          .          .           		/*
    .           .          .              .          .          .              .          .          .           		 * This is a little weird; we compare if the summaries are
    .           .          .              .          .          .              .          .          .           		 * equal, rather than if the edata we removed was the heap
    .           .          .              .          .          .              .          .          .           		 * minimum.  The reason why is that getting the heap minimum
    .           .          .              .          .          .              .          .          .           		 * can cause a pairing heap merge operation.  We can avoid this
    .           .          .              .          .          .              .          .          .           		 * if we only update the min if it's changed, in which case the
    .           .          .              .          .          .              .          .          .           		 * summaries of the removed element and the min element should
-- line 136 ----------------------------------------
-- line 137 ----------------------------------------
    .           .          .              .          .          .              .          .          .           		 * compare equal.
    .           .          .              .          .          .              .          .          .           		 */
    .           .          .              .          .          .              .          .          .           		if (edata_cmp_summary_comp(edata_cmp_summary,
    .           .          .              .          .          .              .          .          .           		    eset->bins[pind].heap_min) == 0) {
    .           .          .              .          .          .              .          .          .           			eset->bins[pind].heap_min = edata_cmp_summary_get(
    .           .          .              .          .          .              .          .          .           			    edata_heap_first(&eset->bins[pind].heap));
    .           .          .              .          .          .              .          .          .           		}
    .           .          .              .          .          .              .          .          .           	}
  186 ( 0.00%) 31 ( 0.02%) 1 ( 0.01%)    62 ( 0.00%) 0          0             31 ( 0.00%) 0          0           	edata_list_inactive_remove(&eset->lru, edata);
   93 ( 0.00%)  0          0             31 ( 0.00%) 0          0             31 ( 0.00%) 0          0           	size_t npages = size >> LG_PAGE;
    .           .          .              .          .          .              .          .          .           	/*
    .           .          .              .          .          .              .          .          .           	 * As in eset_insert, we hold eset->mtx and so don't need atomic
    .           .          .              .          .          .              .          .          .           	 * operations for updating eset->npages.
    .           .          .              .          .          .              .          .          .           	 */
    .           .          .              .          .          .              .          .          .           	size_t cur_extents_npages =
  217 ( 0.00%) 62 ( 0.04%) 2 ( 0.03%)    62 ( 0.00%) 0          0            124 ( 0.00%) 0          0           	    atomic_load_zu(&eset->npages, ATOMIC_RELAXED);
  124 ( 0.00%)  0          0              0          0          0              0          0          0           	assert(cur_extents_npages >= npages);
  279 ( 0.00%) 31 ( 0.02%) 1 ( 0.01%)    93 ( 0.00%) 0          0            124 ( 0.00%) 0          0           	atomic_store_zu(&eset->npages,
   93 ( 0.00%) 31 ( 0.02%) 1 ( 0.01%)    31 ( 0.00%) 0          0              0          0          0           	    cur_extents_npages - (size >> LG_PAGE), ATOMIC_RELAXED);
  217 ( 0.00%) 31 ( 0.02%) 1 ( 0.01%)   155 ( 0.01%) 0          0              0          0          0           }
    .           .          .              .          .          .              .          .          .           
    .           .          .              .          .          .              .          .          .           /*
    .           .          .              .          .          .              .          .          .            * Find an extent with size [min_size, max_size) to satisfy the alignment
    .           .          .              .          .          .              .          .          .            * requirement.  For each size, try only the first extent in the heap.
    .           .          .              .          .          .              .          .          .            */
    .           .          .              .          .          .              .          .          .           static edata_t *
    .           .          .              .          .          .              .          .          .           eset_fit_alignment(eset_t *eset, size_t min_size, size_t max_size,
    .           .          .              .          .          .              .          .          .               size_t alignment) {
-- line 164 ----------------------------------------
-- line 199 ----------------------------------------
    .           .          .              .          .          .              .          .          .            * lg_max_fit is the (log of the) maximum ratio between the requested size and
    .           .          .              .          .          .              .          .          .            * the returned size that we'll allow.  This can reduce fragmentation by
    .           .          .              .          .          .              .          .          .            * avoiding reusing and splitting large extents for smaller sizes.  In practice,
    .           .          .              .          .          .              .          .          .            * it's set to opt_lg_extent_max_active_fit for the dirty eset and SC_PTR_BITS
    .           .          .              .          .          .              .          .          .            * for others.
    .           .          .              .          .          .              .          .          .            */
    .           .          .              .          .          .              .          .          .           static edata_t *
    .           .          .              .          .          .              .          .          .           eset_first_fit(eset_t *eset, size_t size, bool exact_only,
  576 ( 0.01%) 64 ( 0.04%) 2 ( 0.03%)     0          0          0            320 ( 0.01%) 2 ( 0.04%) 2 ( 0.05%)      unsigned lg_max_fit) {
   64 ( 0.00%)  0          0              0          0          0             64 ( 0.00%) 0          0           	edata_t *ret = NULL;
  128 ( 0.00%)  0          0              0          0          0            128 ( 0.00%) 0          0           	edata_cmp_summary_t ret_summ JEMALLOC_CC_SILENCE_INIT({0});
    .           .          .              .          .          .              .          .          .           
  320 ( 0.00%)  0          0             64 ( 0.00%) 0          0            192 ( 0.01%) 3 ( 0.06%) 1 ( 0.02%)  	pszind_t pind = sz_psz2ind(sz_psz_quantize_ceil(size));
    .           .          .              .          .          .              .          .          .           
  128 ( 0.00%)  0          0             64 ( 0.00%) 0          0              0          0          0           	if (exact_only) {
    .           .          .              .          .          .              .          .          .           		return edata_heap_empty(&eset->bins[pind].heap) ? NULL :
    .           .          .              .          .          .              .          .          .           		    edata_heap_first(&eset->bins[pind].heap);
    .           .          .              .          .          .              .          .          .           	}
    .           .          .              .          .          .              .          .          .           
  128 ( 0.00%)  0          0              0          0          0             64 ( 0.00%) 0          0           	for (pszind_t i =
  320 ( 0.00%) 32 ( 0.02%) 1 ( 0.01%)   128 ( 0.01%) 0          0             64 ( 0.00%) 0          0           	    (pszind_t)fb_ffs(eset->bitmap, ESET_NPSIZES, (size_t)pind);
  254 ( 0.00%)  0          0             95 ( 0.00%) 0          0              0          0          0           	    i < ESET_NPSIZES;
  217 ( 0.00%) 31 ( 0.02%) 1 ( 0.01%)    62 ( 0.00%) 0          0             62 ( 0.00%) 0          0           	    i = (pszind_t)fb_ffs(eset->bitmap, ESET_NPSIZES, (size_t)i + 1)) {
  124 ( 0.00%) 31 ( 0.02%) 1 ( 0.01%)     0          0          0              0          0          0           		assert(!edata_heap_empty(&eset->bins[i].heap));
   62 ( 0.00%) 31 ( 0.02%) 1 ( 0.01%)    31 ( 0.00%) 0          0              0          0          0           		if (lg_max_fit == SC_PTR_BITS) {
    .           .          .              .          .          .              .          .          .           			/*
    .           .          .              .          .          .              .          .          .           			 * We'll shift by this below, and shifting out all the
    .           .          .              .          .          .              .          .          .           			 * bits is undefined.  Decreasing is safe, since the
    .           .          .              .          .          .              .          .          .           			 * page size is larger than 1 byte.
    .           .          .              .          .          .              .          .          .           			 */
   31 ( 0.00%)  0          0              0          0          0             31 ( 0.00%) 0          0           			lg_max_fit = SC_PTR_BITS - 1;
    .           .          .              .          .          .              .          .          .           		}
  310 ( 0.00%) 31 ( 0.02%) 1 ( 0.01%)    93 ( 0.00%) 0          0             31 ( 0.00%) 0          0           		if ((sz_pind2sz(i) >> lg_max_fit) > size) {
    .           .          .              .          .          .              .          .          .           			break;
    .           .          .              .          .          .              .          .          .           		}
   62 ( 0.00%)  0          0             31 ( 0.00%) 0          0              0          0          0           		if (ret == NULL || edata_cmp_summary_comp(
    .           .          .              .          .          .              .          .          .           		    eset->bins[i].heap_min, ret_summ) < 0) {
    .           .          .              .          .          .              .          .          .           			/*
    .           .          .              .          .          .              .          .          .           			 * We grab the edata as early as possible, even though
    .           .          .              .          .          .              .          .          .           			 * we might change it later.  Practically, a large
    .           .          .              .          .          .              .          .          .           			 * portion of eset_fit calls succeed at the first valid
    .           .          .              .          .          .              .          .          .           			 * index, so this doesn't cost much, and we get the
    .           .          .              .          .          .              .          .          .           			 * effect of prefetching the edata as early as possible.
    .           .          .              .          .          .              .          .          .           			 */
  279 ( 0.00%) 31 ( 0.02%) 1 ( 0.01%)    62 ( 0.00%) 0          0             62 ( 0.00%) 0          0           			edata_t *edata = edata_heap_first(&eset->bins[i].heap);
  124 ( 0.00%)  0          0              0          0          0              0          0          0           			assert(edata_size_get(edata) >= size);
  124 ( 0.00%) 31 ( 0.02%) 1 ( 0.01%)     0          0          0              0          0          0           			assert(ret == NULL || edata_snad_comp(edata, ret) < 0);
  124 ( 0.00%) 31 ( 0.02%) 1 ( 0.01%)     0          0          0              0          0          0           			assert(ret == NULL || edata_cmp_summary_comp(
    .           .          .              .          .          .              .          .          .           			    eset->bins[i].heap_min,
    .           .          .              .          .          .              .          .          .           			    edata_cmp_summary_get(edata)) == 0);
   62 ( 0.00%) 31 ( 0.02%) 1 ( 0.01%)    31 ( 0.00%) 0          0             31 ( 0.00%) 0          0           			ret = edata;
  279 ( 0.00%) 31 ( 0.02%) 1 ( 0.01%)   124 ( 0.01%) 0          0             62 ( 0.00%) 0          0           			ret_summ = eset->bins[i].heap_min;
    .           .          .              .          .          .              .          .          .           		}
   62 ( 0.00%)  0          0             31 ( 0.00%) 0          0              0          0          0           		if (i == SC_NPSIZES) {
    .           .          .              .          .          .              .          .          .           			break;
    .           .          .              .          .          .              .          .          .           		}
  124 ( 0.00%)  0          0              0          0          0              0          0          0           		assert(i < SC_NPSIZES);
    .           .          .              .          .          .              .          .          .           	}
    .           .          .              .          .          .              .          .          .           
   64 ( 0.00%)  0          0             64 ( 0.00%) 0          0              0          0          0           	return ret;
  128 ( 0.00%)  0          0            128 ( 0.01%) 0          0              0          0          0           }
    .           .          .              .          .          .              .          .          .           
    .           .          .              .          .          .              .          .          .           edata_t *
    .           .          .              .          .          .              .          .          .           eset_fit(eset_t *eset, size_t esize, size_t alignment, bool exact_only,
  640 ( 0.01%) 32 ( 0.02%) 1 ( 0.01%)     0          0          0            384 ( 0.01%) 0          0               unsigned lg_max_fit) {
  512 ( 0.01%) 32 ( 0.02%) 1 ( 0.01%)   128 ( 0.01%) 0          0             64 ( 0.00%) 0          0           	size_t max_size = esize + PAGE_CEILING(alignment) - PAGE;
    .           .          .              .          .          .              .          .          .           	/* Beware size_t wrap-around. */
  192 ( 0.00%)  0          0            128 ( 0.01%) 0          0              0          0          0           	if (max_size < esize) {
    .           .          .              .          .          .              .          .          .           		return NULL;
    .           .          .              .          .          .              .          .          .           	}
    .           .          .              .          .          .              .          .          .           
  448 ( 0.00%) 32 ( 0.02%) 1 ( 0.01%)   256 ( 0.01%) 0          0            128 ( 0.00%) 0          0           	edata_t *edata = eset_first_fit(eset, max_size, exact_only, lg_max_fit);
    .           .          .              .          .          .              .          .          .           
  128 ( 0.00%)  0          0             64 ( 0.00%) 0          0              0          0          0           	if (alignment > PAGE && edata == NULL) {
    .           .          .              .          .          .              .          .          .           		/*
    .           .          .              .          .          .              .          .          .           		 * max_size guarantees the alignment requirement but is rather
    .           .          .              .          .          .              .          .          .           		 * pessimistic.  Next we try to satisfy the aligned allocation
    .           .          .              .          .          .              .          .          .           		 * with sizes in [esize, max_size).
    .           .          .              .          .          .              .          .          .           		 */
    .           .          .              .          .          .              .          .          .           		edata = eset_fit_alignment(eset, esize, max_size, alignment);
    .           .          .              .          .          .              .          .          .           	}
    .           .          .              .          .          .              .          .          .           
   64 ( 0.00%)  0          0             64 ( 0.00%) 0          0              0          0          0           	return edata;
  128 ( 0.00%)  0          0            128 ( 0.01%) 0          0              0          0          0           }

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/ashy5000/dev/cryptocurrency/contracts/target/debug/build/tikv-jemalloc-sys-7365f40ecb99e085/out/build/include/jemalloc/internal/tcache_inlines.h
--------------------------------------------------------------------------------
Ir              I1mr         ILmr       Dr             D1mr       DLmr       Dw              D1mw       DLmw       

-- line 24 ----------------------------------------
     .            .          .              .          .          .               .          .          .           	}
     .            .          .              .          .          .               .          .          .           	/* Commit the state last.  Above calls check current state. */
     .            .          .              .          .          .               .          .          .           	tsd_tcache_enabled_set(tsd, enabled);
     .            .          .              .          .          .               .          .          .           	tsd_slow_update(tsd);
     .            .          .              .          .          .               .          .          .           }
     .            .          .              .          .          .               .          .          .           
     .            .          .              .          .          .               .          .          .           JEMALLOC_ALWAYS_INLINE bool
     .            .          .              .          .          .               .          .          .           tcache_small_bin_disabled(szind_t ind, cache_bin_t *bin) {
   711 ( 0.01%)  20 ( 0.01%) 2 ( 0.03%)     0          0          0             631 ( 0.02%) 0          0           	assert(ind < SC_NBINS);
   200 ( 0.00%)  20 ( 0.01%) 2 ( 0.03%)    40 ( 0.00%) 1 ( 0.02%) 0              40 ( 0.00%) 0          0           	bool ret = (cache_bin_info_ncached_max(&tcache_bin_info[ind]) == 0);
   892 ( 0.01%)  51 ( 0.04%) 3 ( 0.04%)    48 ( 0.00%) 0          0             824 ( 0.03%) 0          0           	if (ret && bin != NULL) {
     .            .          .              .          .          .               .          .          .           		/* small size class but cache bin disabled. */
   528 ( 0.01%)   0          0            176 ( 0.01%) 0          0              56 ( 0.00%) 0          0           		assert(ind >= nhbins);
 2,794 ( 0.03%)   0          0            475 ( 0.02%) 0          0           1,844 ( 0.06%) 0          0           		assert((uintptr_t)(*bin->stack_head) ==
     .            .          .              .          .          .               .          .          .           		    cache_bin_preceding_junk);
     .            .          .              .          .          .               .          .          .           	}
     .            .          .              .          .          .               .          .          .           
 1,104 ( 0.01%)  25 ( 0.02%) 2 ( 0.03%)    20 ( 0.00%) 0          0              56 ( 0.00%) 0          0           	return ret;
     .            .          .              .          .          .               .          .          .           }
     .            .          .              .          .          .               .          .          .           
     .            .          .              .          .          .               .          .          .           JEMALLOC_ALWAYS_INLINE void *
     .            .          .              .          .          .               .          .          .           tcache_alloc_small(tsd_t *tsd, arena_t *arena, tcache_t *tcache,
     .            .          .              .          .          .               .          .          .               size_t size, szind_t binind, bool zero, bool slow_path) {
     .            .          .              .          .          .               .          .          .           	void *ret;
     .            .          .              .          .          .               .          .          .           	bool tcache_success;
     .            .          .              .          .          .               .          .          .           
   192 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)     0          0          0               1 ( 0.00%) 0          0           	assert(binind < SC_NBINS);
   942 ( 0.01%) 118 ( 0.08%) 5 ( 0.07%)   274 ( 0.01%) 1 ( 0.02%) 0             339 ( 0.01%) 6 ( 0.11%) 6 ( 0.14%)  	cache_bin_t *bin = &tcache->bins[binind];
   312 ( 0.00%)   0          0              2 ( 0.00%) 0          0             310 ( 0.01%) 2 ( 0.04%) 2 ( 0.05%)  	ret = cache_bin_alloc(bin, &tcache_success);
46,327 ( 0.49%) 320 ( 0.22%) 3 ( 0.04%)     0          0          0          42,422 ( 1.35%) 0          0           	assert(tcache_success == (ret != NULL));
 9,739 ( 0.10%)  46 ( 0.03%) 2 ( 0.03%)   310 ( 0.01%) 0          0               1 ( 0.00%) 0          0           	if (unlikely(!tcache_success)) {
     .            .          .              .          .          .               .          .          .           		bool tcache_hard_success;
 8,338 ( 0.09%)  15 ( 0.01%) 1 ( 0.01%)    40 ( 0.00%) 0          0              41 ( 0.00%) 0          0           		arena = arena_choose(tsd, arena);
   103 ( 0.00%)   6 ( 0.00%) 2 ( 0.03%)    20 ( 0.00%) 0          0               1 ( 0.00%) 0          0           		if (unlikely(arena == NULL)) {
    81 ( 0.00%)   0          0             41 ( 0.00%) 0          0              41 ( 0.00%) 0          0           			return NULL;
     .            .          .              .          .          .               .          .          .           		}
   644 ( 0.01%)   0          0             56 ( 0.00%) 0          0              28 ( 0.00%) 0          0           		if (unlikely(tcache_small_bin_disabled(binind, bin))) {
     .            .          .              .          .          .               .          .          .           			/* stats and zero are handled directly by the arena. */
 1,582 ( 0.02%)  89 ( 0.06%) 2 ( 0.03%)   791 ( 0.03%) 0          0             291 ( 0.01%) 0          0           			return arena_malloc_hard(tsd_tsdn(tsd), arena, size,
     .            .          .              .          .          .               .          .          .           			    binind, zero);
     .            .          .              .          .          .               .          .          .           		}
 3,495 ( 0.04%)  40 ( 0.03%) 4 ( 0.06%)   100 ( 0.00%) 0          0           2,566 ( 0.08%) 2 ( 0.04%) 2 ( 0.05%)  		tcache_bin_flush_stashed(tsd, tcache, bin, binind,
     .            .          .              .          .          .               .          .          .           		    /* is_small */ true);
     .            .          .              .          .          .               .          .          .           
 2,532 ( 0.03%)  34 ( 0.02%) 2 ( 0.03%)   343 ( 0.01%) 0          0           2,109 ( 0.07%) 0          0           		ret = tcache_alloc_small_hard(tsd_tsdn(tsd), arena, tcache,
     .            .          .              .          .          .               .          .          .           		    bin, binind, &tcache_hard_success);
   275 ( 0.00%)  18 ( 0.01%) 1 ( 0.01%)   215 ( 0.01%) 0          0               0          0          0           		if (tcache_hard_success == false) {
   780 ( 0.01%)   0          0              0          0          0             585 ( 0.02%) 0          0           			return NULL;
     .            .          .              .          .          .               .          .          .           		}
     .            .          .              .          .          .               .          .          .           	}
     .            .          .              .          .          .               .          .          .           
 1,036 ( 0.01%)  25 ( 0.02%) 0            458 ( 0.02%) 0          0             195 ( 0.01%) 0          0           	assert(ret);
 2,260 ( 0.02%) 148 ( 0.10%) 3 ( 0.04%)   919 ( 0.04%) 0          0             760 ( 0.02%) 0          0           	if (unlikely(zero)) {
     .            .          .              .          .          .               .          .          .           		size_t usize = sz_index2size(binind);
     8 ( 0.00%)   0          0              4 ( 0.00%) 0          0               4 ( 0.00%) 0          0           		assert(tcache_salloc(tsd_tsdn(tsd), ret) == usize);
 1,338 ( 0.01%)   0          0              6 ( 0.00%) 0          0              13 ( 0.00%) 0          0           		memset(ret, 0, usize);
     .            .          .              .          .          .               .          .          .           	}
 3,527 ( 0.04%)  45 ( 0.03%) 2 ( 0.03%)     0          0          0           1,333 ( 0.04%) 0          0           	if (config_stats) {
 2,652 ( 0.03%)   0          0              7 ( 0.00%) 0          0           1,131 ( 0.04%) 0          0           		bin->tstats.nrequests++;
     .            .          .              .          .          .               .          .          .           	}
 4,550 ( 0.05%) 100 ( 0.07%) 4 ( 0.06%) 1,561 ( 0.06%) 0          0           2,059 ( 0.07%) 0          0           	return ret;
     .            .          .              .          .          .               .          .          .           }
     .            .          .              .          .          .               .          .          .           
     .            .          .              .          .          .               .          .          .           JEMALLOC_ALWAYS_INLINE void *
     .            .          .              .          .          .               .          .          .           tcache_alloc_large(tsd_t *tsd, arena_t *arena, tcache_t *tcache, size_t size,
     .            .          .              .          .          .               .          .          .               szind_t binind, bool zero, bool slow_path) {
     .            .          .              .          .          .               .          .          .           	void *ret;
     .            .          .              .          .          .               .          .          .           	bool tcache_success;
     .            .          .              .          .          .               .          .          .           
10,219 ( 0.11%) 191 ( 0.13%) 1 ( 0.01%) 1,858 ( 0.08%) 0          0           5,574 ( 0.18%) 0          0           	assert(binind >= SC_NBINS && binind < nhbins);
   705 ( 0.01%)   0          0              6 ( 0.00%) 0          0             501 ( 0.02%) 0          0           	cache_bin_t *bin = &tcache->bins[binind];
   176 ( 0.00%)   0          0             88 ( 0.00%) 0          0              88 ( 0.00%) 0          0           	ret = cache_bin_alloc(bin, &tcache_success);
     .            .          .              .          .          .               .          .          .           	assert(tcache_success == (ret != NULL));
    29 ( 0.00%)   0          0             15 ( 0.00%) 0          0              14 ( 0.00%) 0          0           	if (unlikely(!tcache_success)) {
     .            .          .              .          .          .               .          .          .           		/*
     .            .          .              .          .          .               .          .          .           		 * Only allocate one large object at a time, because it's quite
     .            .          .              .          .          .               .          .          .           		 * expensive to create one and not use it.
     .            .          .              .          .          .               .          .          .           		 */
     9 ( 0.00%)   0          0              8 ( 0.00%) 0          0               1 ( 0.00%) 0          0           		arena = arena_choose(tsd, arena);
     2 ( 0.00%)   0          0              1 ( 0.00%) 0          0               1 ( 0.00%) 0          0           		if (unlikely(arena == NULL)) {
     5 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)     2 ( 0.00%) 0          0               3 ( 0.00%) 0          0           			return NULL;
     .            .          .              .          .          .               .          .          .           		}
     3 ( 0.00%)   0          0              2 ( 0.00%) 0          0               1 ( 0.00%) 0          0           		tcache_bin_flush_stashed(tsd, tcache, bin, binind,
     .            .          .              .          .          .               .          .          .           		    /* is_small */ false);
     .            .          .              .          .          .               .          .          .           
    62 ( 0.00%)   1 ( 0.00%) 1 ( 0.01%)    33 ( 0.00%) 0          0              26 ( 0.00%) 0          0           		ret = large_malloc(tsd_tsdn(tsd), arena, sz_s2u(size), zero);
    93 ( 0.00%)   0          0              2 ( 0.00%) 0          0              87 ( 0.00%) 0          0           		if (ret == NULL) {
   221 ( 0.00%)   0          0             73 ( 0.00%) 0          0              75 ( 0.00%) 0          0           			return NULL;
     .            .          .              .          .          .               .          .          .           		}
     .            .          .              .          .          .               .          .          .           	} else {
    86 ( 0.00%)  10 ( 0.01%) 2 ( 0.03%)     0          0          0              86 ( 0.00%) 0          0           		if (unlikely(zero)) {
10,980 ( 0.12%)   1 ( 0.00%) 1 ( 0.01%) 2,744 ( 0.11%) 0          0           2,748 ( 0.09%) 0          0           			size_t usize = sz_index2size(binind);
 8,252 ( 0.09%) 104 ( 0.07%) 1 ( 0.01%) 2,748 ( 0.11%) 0          0           5,498 ( 0.17%) 0          0           			assert(usize <= tcache_maxclass);
 8,242 ( 0.09%)   0          0              0          0          0           5,495 ( 0.17%) 0          0           			memset(ret, 0, usize);
     .            .          .              .          .          .               .          .          .           		}
     .            .          .              .          .          .               .          .          .           
 5,494 ( 0.06%)   0          0          2,747 ( 0.11%) 0          0           2,747 ( 0.09%) 0          0           		if (config_stats) {
10,988 ( 0.12%) 106 ( 0.07%) 1 ( 0.01%)     0          0          0           5,494 ( 0.17%) 0          0           			bin->tstats.nrequests++;
     .            .          .              .          .          .               .          .          .           		}
     .            .          .              .          .          .               .          .          .           	}
     .            .          .              .          .          .               .          .          .           
 8,243 ( 0.09%)   0          0          2,747 ( 0.11%) 0          0               2 ( 0.00%) 0          0           	return ret;
     .            .          .              .          .          .               .          .          .           }
     .            .          .              .          .          .               .          .          .           
     .            .          .              .          .          .               .          .          .           JEMALLOC_ALWAYS_INLINE void
     .            .          .              .          .          .               .          .          .           tcache_dalloc_small(tsd_t *tsd, tcache_t *tcache, void *ptr, szind_t binind,
     .            .          .              .          .          .               .          .          .               bool slow_path) {
   140 ( 0.00%)   3 ( 0.00%) 1 ( 0.01%)     0          0          0               0          0          0           	assert(tcache_salloc(tsd_tsdn(tsd), ptr) <= SC_SMALL_MAXCLASS);
     .            .          .              .          .          .               .          .          .           
   385 ( 0.00%)  35 ( 0.02%) 3 ( 0.04%)   105 ( 0.00%) 0          0              70 ( 0.00%) 3 ( 0.06%) 1 ( 0.02%)  	cache_bin_t *bin = &tcache->bins[binind];
     .            .          .              .          .          .               .          .          .           	/*
     .            .          .              .          .          .               .          .          .           	 * Not marking the branch unlikely because this is past free_fastpath()
     .            .          .              .          .          .               .          .          .           	 * (which handles the most common cases), i.e. at this point it's often
     .            .          .              .          .          .               .          .          .           	 * uncommon cases.
     .            .          .              .          .          .               .          .          .           	 */
    70 ( 0.00%)   4 ( 0.00%) 1 ( 0.01%)     0          0          0               0          0          0           	if (cache_bin_nonfast_aligned(ptr)) {
     .            .          .              .          .          .               .          .          .           		/* Junk unconditionally, even if bin is full. */
     .            .          .              .          .          .               .          .          .           		san_junk_ptr(ptr, sz_index2size(binind));
     .            .          .              .          .          .               .          .          .           		if (cache_bin_stash(bin, ptr)) {
     .            .          .              .          .          .               .          .          .           			return;
     .            .          .              .          .          .               .          .          .           		}
   210 ( 0.00%)  59 ( 0.04%) 3 ( 0.04%)   105 ( 0.00%) 0          0             105 ( 0.00%) 9 ( 0.17%) 6 ( 0.14%)  		assert(cache_bin_full(bin));
     .            .          .              .          .          .               .          .          .           		/* Bin full; fall through into the flush branch. */
     .            .          .              .          .          .               .          .          .           	}
     .            .          .              .          .          .               .          .          .           
   140 ( 0.00%)   0          0              0          0          0               0          0          0           	if (unlikely(!cache_bin_dalloc_easy(bin, ptr))) {
     .            .          .              .          .          .               .          .          .           		if (unlikely(tcache_small_bin_disabled(binind, bin))) {
     .            .          .              .          .          .               .          .          .           			arena_dalloc_small(tsd_tsdn(tsd), ptr);
     .            .          .              .          .          .               .          .          .           			return;
     .            .          .              .          .          .               .          .          .           		}
     .            .          .              .          .          .               .          .          .           		cache_bin_sz_t max = cache_bin_info_ncached_max(
     .            .          .              .          .          .               .          .          .           		    &tcache_bin_info[binind]);
     .            .          .              .          .          .               .          .          .           		unsigned remain = max >> opt_lg_tcache_flush_small_div;
     .            .          .              .          .          .               .          .          .           		tcache_bin_flush_small(tsd, tcache, bin, binind, remain);
-- line 157 ----------------------------------------
-- line 175 ----------------------------------------
     .            .          .              .          .          .               .          .          .           		tcache_bin_flush_large(tsd, tcache, bin, binind, remain);
     .            .          .              .          .          .               .          .          .           		bool ret = cache_bin_dalloc_easy(bin, ptr);
     .            .          .              .          .          .               .          .          .           		assert(ret);
     .            .          .              .          .          .               .          .          .           	}
     .            .          .              .          .          .               .          .          .           }
     .            .          .              .          .          .               .          .          .           
     .            .          .              .          .          .               .          .          .           JEMALLOC_ALWAYS_INLINE tcache_t *
     .            .          .              .          .          .               .          .          .           tcaches_get(tsd_t *tsd, unsigned ind) {
    44 ( 0.00%)   0          0              3 ( 0.00%) 0          0               3 ( 0.00%) 0          0           	tcaches_t *elm = &tcaches[ind];
    85 ( 0.00%)   0          0              6 ( 0.00%) 0          0              41 ( 0.00%) 0          0           	if (unlikely(elm->tcache == NULL)) {
    79 ( 0.00%)   4 ( 0.00%) 1 ( 0.01%)     3 ( 0.00%) 0          0              76 ( 0.00%) 0          0           		malloc_printf("<jemalloc>: invalid tcache id (%u).\n", ind);
   126 ( 0.00%)   4 ( 0.00%) 1 ( 0.01%)     3 ( 0.00%) 0          0              47 ( 0.00%) 0          0           		abort();
    59 ( 0.00%)   3 ( 0.00%) 1 ( 0.01%)     9 ( 0.00%) 0          0              47 ( 0.00%) 0          0           	} else if (unlikely(elm->tcache == TCACHES_ELM_NEED_REINIT)) {
    43 ( 0.00%)   0          0              3 ( 0.00%) 0          0               0          0          0           		elm->tcache = tcache_create_explicit(tsd);
     .            .          .              .          .          .               .          .          .           	}
    80 ( 0.00%)  20 ( 0.01%) 1 ( 0.01%)    80 ( 0.00%) 0          0               0          0          0           	return elm->tcache;
     .            .          .              .          .          .               .          .          .           }
     .            .          .              .          .          .               .          .          .           
     .            .          .              .          .          .               .          .          .           #endif /* JEMALLOC_INTERNAL_TCACHE_INLINES_H */

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/ashy5000/.cargo/registry/src/index.crates.io-6f17d22bba15001f/smartstring-1.0.1/src/marker_byte.rs
--------------------------------------------------------------------------------
Ir              I1mr         ILmr       Dr              D1mr       DLmr       Dw              D1mw       DLmw       

     .            .          .               .          .          .               .          .          .           // This Source Code Form is subject to the terms of the Mozilla Public
     .            .          .               .          .          .               .          .          .           // License, v. 2.0. If a copy of the MPL was not distributed with this
     .            .          .               .          .          .               .          .          .           // file, You can obtain one at http://mozilla.org/MPL/2.0/.
     .            .          .               .          .          .               .          .          .           
    45 ( 0.00%)   6 ( 0.00%) 2 ( 0.03%)      9 ( 0.00%) 1 ( 0.02%) 1 ( 0.03%)     12 ( 0.00%) 0          0           #[derive(Clone, Copy, PartialEq, Eq, Debug)]
     .            .          .               .          .          .               .          .          .           pub(crate) enum Discriminant {
     .            .          .               .          .          .               .          .          .               Boxed,
     .            .          .               .          .          .               .          .          .               Inline,
     .            .          .               .          .          .               .          .          .           }
     .            .          .               .          .          .               .          .          .           
     .            .          .               .          .          .               .          .          .           impl Discriminant {
     .            .          .               .          .          .               .          .          .               #[inline(always)]
     .            .          .               .          .          .               .          .          .               pub(crate) const fn from_bit(bit: bool) -> Self {
13,970 ( 0.15%) 101 ( 0.07%) 2 ( 0.03%)      0          0          0               0          0          0                   if bit {
11,034 ( 0.12%) 125 ( 0.09%) 0               0          0          0          11,034 ( 0.35%) 0          0                       Self::Inline
     .            .          .               .          .          .               .          .          .                   } else {
    96 ( 0.00%)   0          0               0          0          0              96 ( 0.00%) 0          0                       Self::Boxed
     .            .          .               .          .          .               .          .          .                   }
22,106 ( 0.23%)   0          0          11,130 ( 0.46%) 0          0           5,488 ( 0.17%) 0          0               }
     .            .          .               .          .          .               .          .          .           
     .            .          .               .          .          .               .          .          .               #[inline(always)]
     .            .          .               .          .          .               .          .          .               const fn bit(self) -> u8 {
21,530 ( 0.23%)   0          0           4,306 ( 0.18%) 0          0               0          0          0                   match self {
     .            .          .               .          .          .               .          .          .                       Self::Boxed => 0,
 4,306 ( 0.05%)  38 ( 0.03%) 1 ( 0.01%)      0          0          0           4,306 ( 0.14%) 0          0                       Self::Inline => 1,
     .            .          .               .          .          .               .          .          .                   }
 2,640 ( 0.03%)   0          0           1,562 ( 0.06%) 0          0           1,078 ( 0.03%) 0          0               }
     .            .          .               .          .          .               .          .          .           }
     .            .          .               .          .          .               .          .          .           
     .            .          .               .          .          .               .          .          .           #[derive(Clone, Copy, Debug)]
     .            .          .               .          .          .               .          .          .           pub(crate) struct Marker(u8);
     .            .          .               .          .          .               .          .          .           
     .            .          .               .          .          .               .          .          .           impl Marker {
     .            .          .               .          .          .               .          .          .               #[inline(always)]
     .            .          .               .          .          .               .          .          .               const fn assemble(discriminant: Discriminant, data: u8) -> u8 {
16,140 ( 0.17%)  43 ( 0.03%) 1 ( 0.01%)  2,744 ( 0.11%) 0          0           6,456 ( 0.20%) 0          0                   data << 1 | discriminant.bit()
     .            .          .               .          .          .               .          .          .               }
     .            .          .               .          .          .               .          .          .           
     .            .          .               .          .          .               .          .          .               #[inline(always)]
     .            .          .               .          .          .               .          .          .               pub(crate) const fn empty() -> Self {
 8,624 ( 0.09%)   0          0           1,078 ( 0.04%) 0          0           4,312 ( 0.14%) 0          0                   Self(Self::assemble(Discriminant::Inline, 0))
     .            .          .               .          .          .               .          .          .               }
     .            .          .               .          .          .               .          .          .           
     .            .          .               .          .          .               .          .          .               #[inline(always)]
     .            .          .               .          .          .               .          .          .               pub(crate) const fn new_inline(data: u8) -> Self {
   968 ( 0.01%)   0          0               0          0          0               0          0          0                   debug_assert!(data < 0x80);
 2,904 ( 0.03%)   0          0             484 ( 0.02%) 0          0           1,452 ( 0.05%) 0          0                   Self(Self::assemble(Discriminant::Inline, data))
     .            .          .               .          .          .               .          .          .               }
     .            .          .               .          .          .               .          .          .           
     .            .          .               .          .          .               .          .          .               #[inline(always)]
     .            .          .               .          .          .               .          .          .               pub(crate) const fn discriminant(self) -> Discriminant {
16,464 ( 0.17%)   0          0               0          0          0           2,744 ( 0.09%) 0          0                   Discriminant::from_bit(self.0 & 0x01 != 0)
     .            .          .               .          .          .               .          .          .               }
     .            .          .               .          .          .               .          .          .           
     .            .          .               .          .          .               .          .          .               #[inline(always)]
     .            .          .               .          .          .               .          .          .               pub(crate) const fn data(self) -> u8 {
 7,673 ( 0.08%)   0          0               0          0          0               0          0          0                   self.0 >> 1
     .            .          .               .          .          .               .          .          .               }
     .            .          .               .          .          .               .          .          .           
     .            .          .               .          .          .               .          .          .               #[inline(always)]
     .            .          .               .          .          .               .          .          .               pub(crate) fn set_data(&mut self, byte: u8) {
 5,488 ( 0.06%)   0          0               0          0          0               0          0          0                   debug_assert!(byte < 0x80);
 8,232 ( 0.09%)   0          0           2,744 ( 0.11%) 0          0           5,488 ( 0.17%) 0          0                   self.0 = Self::assemble(self.discriminant(), byte);
     .            .          .               .          .          .               .          .          .               }
     .            .          .               .          .          .               .          .          .           }

11,944 ( 0.13%)  38 ( 0.03%) 1 ( 0.01%) 11,944 ( 0.49%) 0          0               0          0          0           <counts for unidentified lines in /home/ashy5000/.cargo/registry/src/index.crates.io-6f17d22bba15001f/smartstring-1.0.1/src/marker_byte.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/ashy5000/dev/cryptocurrency/contracts/target/debug/build/tikv-jemalloc-sys-7365f40ecb99e085/out/build/include/jemalloc/internal/prof_inlines.h
--------------------------------------------------------------------------------
Ir              I1mr        ILmr       Dr             D1mr       DLmr       Dw              D1mw       DLmw       

-- line 2 ----------------------------------------
     .           .          .              .          .          .               .          .          .           #define JEMALLOC_INTERNAL_PROF_INLINES_H
     .           .          .              .          .          .               .          .          .           
     .           .          .              .          .          .               .          .          .           #include "jemalloc/internal/safety_check.h"
     .           .          .              .          .          .               .          .          .           #include "jemalloc/internal/sz.h"
     .           .          .              .          .          .               .          .          .           #include "jemalloc/internal/thread_event.h"
     .           .          .              .          .          .               .          .          .           
     .           .          .              .          .          .               .          .          .           JEMALLOC_ALWAYS_INLINE void
     .           .          .              .          .          .               .          .          .           prof_active_assert() {
 6,370 ( 0.07%) 54 ( 0.04%) 1 ( 0.01%) 3,430 ( 0.14%) 0          0           1,470 ( 0.05%) 0          0           	cassert(config_prof);
     .           .          .              .          .          .               .          .          .           	/*
     .           .          .              .          .          .               .          .          .           	 * If opt_prof is off, then prof_active must always be off, regardless
     .           .          .              .          .          .               .          .          .           	 * of whether prof_active_mtx is in effect or not.
     .           .          .              .          .          .               .          .          .           	 */
 1,470 ( 0.02%)  0          0            490 ( 0.02%) 0          0             980 ( 0.03%) 0          0           	assert(opt_prof || !prof_active_state);
     .           .          .              .          .          .               .          .          .           }
     .           .          .              .          .          .               .          .          .           
     .           .          .              .          .          .               .          .          .           JEMALLOC_ALWAYS_INLINE bool
     .           .          .              .          .          .               .          .          .           prof_active_get_unlocked(void) {
     .           .          .              .          .          .               .          .          .           	prof_active_assert();
     .           .          .              .          .          .               .          .          .           	/*
     .           .          .              .          .          .               .          .          .           	 * Even if opt_prof is true, sampling can be temporarily disabled by
     .           .          .              .          .          .               .          .          .           	 * setting prof_active to false.  No locking is used when reading
-- line 23 ----------------------------------------
-- line 40 ----------------------------------------
     .           .          .              .          .          .               .          .          .           JEMALLOC_ALWAYS_INLINE prof_tdata_t *
     .           .          .              .          .          .               .          .          .           prof_tdata_get(tsd_t *tsd, bool create) {
     .           .          .              .          .          .               .          .          .           	prof_tdata_t *tdata;
     .           .          .              .          .          .               .          .          .           
     .           .          .              .          .          .               .          .          .           	cassert(config_prof);
     .           .          .              .          .          .               .          .          .           
     .           .          .              .          .          .               .          .          .           	tdata = tsd_prof_tdata_get(tsd);
     .           .          .              .          .          .               .          .          .           	if (create) {
18,354 ( 0.19%)  0          0              0          0          0          18,354 ( 0.58%) 0          0           		assert(tsd_reentrancy_level_get(tsd) == 0);
     .           .          .              .          .          .               .          .          .           		if (unlikely(tdata == NULL)) {
    73 ( 0.00%)  0          0              0          0          0              73 ( 0.00%) 0          0           			if (tsd_nominal(tsd)) {
   365 ( 0.00%)  0          0             73 ( 0.00%) 0          0             219 ( 0.01%) 0          0           				tdata = prof_tdata_init(tsd);
     .           .          .              .          .          .               .          .          .           				tsd_prof_tdata_set(tsd, tdata);
     .           .          .              .          .          .               .          .          .           			}
 1,168 ( 0.01%) 42 ( 0.03%) 1 ( 0.01%)     0          0          0             584 ( 0.02%) 0          0           		} else if (unlikely(tdata->expired)) {
 1,752 ( 0.02%)  0          0              0          0          0               0          0          0           			tdata = prof_tdata_reinit(tsd, tdata);
     .           .          .              .          .          .               .          .          .           			tsd_prof_tdata_set(tsd, tdata);
     .           .          .              .          .          .               .          .          .           		}
   195 ( 0.00%) 12 ( 0.01%) 1 ( 0.01%)     0          0          0               0          0          0           		assert(tdata == NULL || tdata->attached);
     .           .          .              .          .          .               .          .          .           	}
     .           .          .              .          .          .               .          .          .           
     .           .          .              .          .          .               .          .          .           	return tdata;
     .           .          .              .          .          .               .          .          .           }
     .           .          .              .          .          .               .          .          .           
     .           .          .              .          .          .               .          .          .           JEMALLOC_ALWAYS_INLINE void
     .           .          .              .          .          .               .          .          .           prof_info_get(tsd_t *tsd, const void *ptr, emap_alloc_ctx_t *alloc_ctx,
     .           .          .              .          .          .               .          .          .               prof_info_t *prof_info) {
-- line 66 ----------------------------------------
-- line 78 ----------------------------------------
     .           .          .              .          .          .               .          .          .           	assert(ptr != NULL);
     .           .          .              .          .          .               .          .          .           	assert(prof_info != NULL);
     .           .          .              .          .          .               .          .          .           
     .           .          .              .          .          .               .          .          .           	arena_prof_info_get(tsd, ptr, alloc_ctx, prof_info, true);
     .           .          .              .          .          .               .          .          .           }
     .           .          .              .          .          .               .          .          .           
     .           .          .              .          .          .               .          .          .           JEMALLOC_ALWAYS_INLINE void
     .           .          .              .          .          .               .          .          .           prof_tctx_reset(tsd_t *tsd, const void *ptr, emap_alloc_ctx_t *alloc_ctx) {
   745 ( 0.01%) 13 ( 0.01%) 1 ( 0.01%)   238 ( 0.01%) 0          0             293 ( 0.01%) 0          0           	cassert(config_prof);
   103 ( 0.00%) 12 ( 0.01%) 1 ( 0.01%)    24 ( 0.00%) 0          0              19 ( 0.00%) 0          0           	assert(ptr != NULL);
     .           .          .              .          .          .               .          .          .           
     .           .          .              .          .          .               .          .          .           	arena_prof_tctx_reset(tsd, ptr, alloc_ctx);
 1,170 ( 0.01%)  0          0              0          0          0             124 ( 0.00%) 0          0           }
     .           .          .              .          .          .               .          .          .           
     .           .          .              .          .          .               .          .          .           JEMALLOC_ALWAYS_INLINE void
     .           .          .              .          .          .               .          .          .           prof_tctx_reset_sampled(tsd_t *tsd, const void *ptr) {
     .           .          .              .          .          .               .          .          .           	cassert(config_prof);
     .           .          .              .          .          .               .          .          .           	assert(ptr != NULL);
     .           .          .              .          .          .               .          .          .           
     .           .          .              .          .          .               .          .          .           	arena_prof_tctx_reset_sampled(tsd, ptr);
     .           .          .              .          .          .               .          .          .           }
-- line 98 ----------------------------------------
-- line 103 ----------------------------------------
     .           .          .              .          .          .               .          .          .           	assert(edata != NULL);
     .           .          .              .          .          .               .          .          .           	assert((uintptr_t)tctx > (uintptr_t)1U);
     .           .          .              .          .          .               .          .          .           
     .           .          .              .          .          .               .          .          .           	arena_prof_info_set(tsd, edata, tctx, size);
     .           .          .              .          .          .               .          .          .           }
     .           .          .              .          .          .               .          .          .           
     .           .          .              .          .          .               .          .          .           JEMALLOC_ALWAYS_INLINE bool
     .           .          .              .          .          .               .          .          .           prof_sample_should_skip(tsd_t *tsd, bool sample_event) {
14,085 ( 0.15%)  0          0          2,817 ( 0.12%) 0          0           5,634 ( 0.18%) 0          0           	cassert(config_prof);
     .           .          .              .          .          .               .          .          .           
     .           .          .              .          .          .               .          .          .           	/* Fastpath: no need to load tdata */
     .           .          .              .          .          .               .          .          .           	if (likely(!sample_event)) {
     .           .          .              .          .          .               .          .          .           		return true;
     .           .          .              .          .          .               .          .          .           	}
     .           .          .              .          .          .               .          .          .           
     .           .          .              .          .          .               .          .          .           	/*
     .           .          .              .          .          .               .          .          .           	 * sample_event is always obtained from the thread event module, and
     .           .          .              .          .          .               .          .          .           	 * whenever it's true, it means that the thread event module has
     .           .          .              .          .          .               .          .          .           	 * already checked the reentrancy level.
     .           .          .              .          .          .               .          .          .           	 */
 2,817 ( 0.03%)  0          0          2,817 ( 0.12%) 0          0               0          0          0           	assert(tsd_reentrancy_level_get(tsd) == 0);
     .           .          .              .          .          .               .          .          .           
     .           .          .              .          .          .               .          .          .           	prof_tdata_t *tdata = prof_tdata_get(tsd, true);
     .           .          .              .          .          .               .          .          .           	if (unlikely(tdata == NULL)) {
    48 ( 0.00%)  0          0              0          0          0              48 ( 0.00%) 0          0           		return true;
     .           .          .              .          .          .               .          .          .           	}
     .           .          .              .          .          .               .          .          .           
     .           .          .              .          .          .               .          .          .           	return !tdata->active;
     .           .          .              .          .          .               .          .          .           }
     .           .          .              .          .          .               .          .          .           
     .           .          .              .          .          .               .          .          .           JEMALLOC_ALWAYS_INLINE prof_tctx_t *
     .           .          .              .          .          .               .          .          .           prof_alloc_prep(tsd_t *tsd, bool prof_active, bool sample_event) {
     .           .          .              .          .          .               .          .          .           	prof_tctx_t *ret;
     .           .          .              .          .          .               .          .          .           
    24 ( 0.00%)  0          0              0          0          0               0          0          0           	if (!prof_active ||
    72 ( 0.00%) 23 ( 0.02%) 1 ( 0.01%)     0          0          0              48 ( 0.00%) 0          0           	    likely(prof_sample_should_skip(tsd, sample_event))) {
    96 ( 0.00%)  0          0              0          0          0              72 ( 0.00%) 1 ( 0.02%) 1 ( 0.02%)  		ret = (prof_tctx_t *)(uintptr_t)1U;
     .           .          .              .          .          .               .          .          .           	} else {
    48 ( 0.00%) 23 ( 0.02%) 1 ( 0.01%)     0          0          0              48 ( 0.00%) 0          0           		ret = prof_tctx_create(tsd);
     .           .          .              .          .          .               .          .          .           	}
     .           .          .              .          .          .               .          .          .           
    96 ( 0.00%)  0          0             24 ( 0.00%) 0          0              24 ( 0.00%) 0          0           	return ret;
     .           .          .              .          .          .               .          .          .           }
     .           .          .              .          .          .               .          .          .           
     .           .          .              .          .          .               .          .          .           JEMALLOC_ALWAYS_INLINE void
     .           .          .              .          .          .               .          .          .           prof_malloc(tsd_t *tsd, const void *ptr, size_t size, size_t usize,
     .           .          .              .          .          .               .          .          .               emap_alloc_ctx_t *alloc_ctx, prof_tctx_t *tctx) {
    40 ( 0.00%)  5 ( 0.00%) 1 ( 0.01%)    20 ( 0.00%) 0          0              20 ( 0.00%) 0          0           	cassert(config_prof);
    15 ( 0.00%)  0          0              5 ( 0.00%) 0          0              10 ( 0.00%) 0          0           	assert(ptr != NULL);
   944 ( 0.01%) 17 ( 0.01%) 2 ( 0.03%)    27 ( 0.00%) 0          0             460 ( 0.01%) 0          0           	assert(usize == isalloc(tsd_tsdn(tsd), ptr));
     .           .          .              .          .          .               .          .          .           
 1,656 ( 0.02%) 19 ( 0.01%) 1 ( 0.01%)    12 ( 0.00%) 0          0             828 ( 0.03%) 0          0           	if (unlikely((uintptr_t)tctx > (uintptr_t)1U)) {
 1,206 ( 0.01%) 12 ( 0.01%) 1 ( 0.01%)   585 ( 0.02%) 0          0               0          0          0           		prof_malloc_sample_object(tsd, ptr, size, usize, tctx);
     .           .          .              .          .          .               .          .          .           	} else {
     .           .          .              .          .          .               .          .          .           		prof_tctx_reset(tsd, ptr, alloc_ctx);
     .           .          .              .          .          .               .          .          .           	}
 2,996 ( 0.03%) 67 ( 0.05%) 2 ( 0.03%)   195 ( 0.01%) 0          0           2,021 ( 0.06%) 0          0           }
     .           .          .              .          .          .               .          .          .           
     .           .          .              .          .          .               .          .          .           JEMALLOC_ALWAYS_INLINE void
     .           .          .              .          .          .               .          .          .           prof_realloc(tsd_t *tsd, const void *ptr, size_t size, size_t usize,
     .           .          .              .          .          .               .          .          .               prof_tctx_t *tctx, bool prof_active, const void *old_ptr, size_t old_usize,
     .           .          .              .          .          .               .          .          .               prof_info_t *old_prof_info, bool sample_event) {
     .           .          .              .          .          .               .          .          .           	bool sampled, old_sampled, moved;
     .           .          .              .          .          .               .          .          .           
     .           .          .              .          .          .               .          .          .           	cassert(config_prof);
-- line 167 ----------------------------------------
-- line 217 ----------------------------------------
     .           .          .              .          .          .               .          .          .           }
     .           .          .              .          .          .               .          .          .           
     .           .          .              .          .          .               .          .          .           JEMALLOC_ALWAYS_INLINE size_t
     .           .          .              .          .          .               .          .          .           prof_sample_align(size_t orig_align) {
     .           .          .              .          .          .               .          .          .           	/*
     .           .          .              .          .          .               .          .          .           	 * Enforce page alignment, so that sampled allocations can be identified
     .           .          .              .          .          .               .          .          .           	 * w/o metadata lookup.
     .           .          .              .          .          .               .          .          .           	 */
 1,347 ( 0.01%)  0          0              0          0          0             898 ( 0.03%) 0          0           	assert(opt_prof);
     .           .          .              .          .          .               .          .          .           	return (opt_cache_oblivious && orig_align < PAGE) ? PAGE :
     .           .          .              .          .          .               .          .          .           	    orig_align;
     .           .          .              .          .          .               .          .          .           }
     .           .          .              .          .          .               .          .          .           
     .           .          .              .          .          .               .          .          .           JEMALLOC_ALWAYS_INLINE bool
     .           .          .              .          .          .               .          .          .           prof_sample_aligned(const void *ptr) {
    15 ( 0.00%)  5 ( 0.00%) 1 ( 0.01%)     5 ( 0.00%) 0          0              10 ( 0.00%) 0          0           	return ((uintptr_t)ptr & PAGE_MASK) == 0;
     .           .          .              .          .          .               .          .          .           }
     .           .          .              .          .          .               .          .          .           
     .           .          .              .          .          .               .          .          .           JEMALLOC_ALWAYS_INLINE bool
     .           .          .              .          .          .               .          .          .           prof_sampled(tsd_t *tsd, const void *ptr) {
     .           .          .              .          .          .               .          .          .           	prof_info_t prof_info;
     .           .          .              .          .          .               .          .          .           	prof_info_get(tsd, ptr, NULL, &prof_info);
     .           .          .              .          .          .               .          .          .           	bool sampled = (uintptr_t)prof_info.alloc_tctx > (uintptr_t)1U;
     .           .          .              .          .          .               .          .          .           	if (sampled) {
-- line 240 ----------------------------------------

--------------------------------------------------------------------------------
The following files chosen for auto-annotation could not be found:
--------------------------------------------------------------------------------
  ./elf/../sysdeps/x86_64/dl-machine.h
  ./elf/./elf/dl-lookup.c
  ./elf/./elf/dl-tunables.c
  ./elf/./elf/do-rel.h
  ./stdio-common/./stdio-common/vfscanf-internal.c
  ./stdlib/../stdlib/strtol_l.c
  ./string/../sysdeps/x86_64/multiarch/memcmp-avx2-movbe.S
  ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S
  ./string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S
  ./string/../sysdeps/x86_64/strcmp.S
  /rust/deps/hashbrown-0.14.5/src/raw/bitmask.rs
  /rust/deps/hashbrown-0.14.5/src/raw/mod.rs
  /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/alloc/src/alloc.rs
  /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/alloc/src/raw_vec.rs
  /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/alloc/src/slice.rs
  /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/alloc/src/vec/mod.rs
  /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/core/src/../../stdarch/crates/core_arch/src/x86/sse2.rs
  /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/core/src/alloc/layout.rs
  /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/core/src/array/mod.rs
  /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/core/src/char/convert.rs
  /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/core/src/char/methods.rs
  /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/core/src/cmp.rs
  /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/core/src/fmt/mod.rs
  /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/core/src/intrinsics.rs
  /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/core/src/iter/adapters/skip.rs
  /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/core/src/iter/adapters/take.rs
  /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/core/src/mem/manually_drop.rs
  /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/core/src/mem/maybe_uninit.rs
  /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/core/src/num/uint_macros.rs
  /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/core/src/ops/function.rs
  /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/core/src/option.rs
  /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/core/src/ptr/const_ptr.rs
  /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/core/src/ptr/mod.rs
  /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/core/src/ptr/mut_ptr.rs
  /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/core/src/ptr/non_null.rs
  /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/core/src/result.rs
  /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/core/src/slice/cmp.rs
  /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/core/src/slice/index.rs
  /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/core/src/slice/iter/macros.rs
  /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/core/src/slice/mod.rs
  /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/core/src/slice/raw.rs
  /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/core/src/str/converts.rs
  /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/core/src/str/iter.rs
  /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/core/src/str/mod.rs
  /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/core/src/str/pattern.rs
  /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/core/src/str/traits.rs
  /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/core/src/str/validations.rs
  /rustc/051478957371ee0084a7c0913941d2a8c4757bb9/library/core/src/ub_checks.rs

--------------------------------------------------------------------------------
Ir                 I1mr            ILmr           Dr               D1mr           DLmr         Dw                 D1mw           DLmw           
--------------------------------------------------------------------------------
3,718,910 (39.20%) 68,081 (47.23%) 2,629 (37.02%) 879,819 (36.17%) 1,153 (19.99%) 178 ( 4.96%) 1,319,499 (41.84%) 2,320 (43.63%) 1,579 (37.68%)  events annotated

